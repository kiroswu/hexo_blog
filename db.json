{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/Staticfile","path":"Staticfile","modified":0,"renderable":0},{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"themes/TKL/source/css/all.styl","path":"css/all.styl","modified":0,"renderable":1},{"_id":"themes/TKL/source/css/animate.css","path":"css/animate.css","modified":0,"renderable":1},{"_id":"themes/TKL/source/css/animsition.min.css","path":"css/animsition.min.css","modified":0,"renderable":1},{"_id":"themes/TKL/source/css/custom.css","path":"css/custom.css","modified":0,"renderable":1},{"_id":"themes/TKL/source/css/flexslider.css","path":"css/flexslider.css","modified":0,"renderable":1},{"_id":"themes/TKL/source/css/iconList.css","path":"css/iconList.css","modified":0,"renderable":1},{"_id":"themes/TKL/source/css/ie8.css","path":"css/ie8.css","modified":0,"renderable":1},{"_id":"themes/TKL/source/css/screen.css","path":"css/screen.css","modified":0,"renderable":1},{"_id":"themes/TKL/source/css/slidebars.min.css","path":"css/slidebars.min.css","modified":0,"renderable":1},{"_id":"themes/TKL/source/css/syntax.styl","path":"css/syntax.styl","modified":0,"renderable":1},{"_id":"themes/TKL/source/fonts/icons.eot","path":"fonts/icons.eot","modified":0,"renderable":1},{"_id":"themes/TKL/source/fonts/icons.ttf","path":"fonts/icons.ttf","modified":0,"renderable":1},{"_id":"themes/TKL/source/fonts/icons.woff","path":"fonts/icons.woff","modified":0,"renderable":1},{"_id":"themes/TKL/source/highlightjs/arta.css","path":"highlightjs/arta.css","modified":0,"renderable":1},{"_id":"themes/TKL/source/highlightjs/ascetic.css","path":"highlightjs/ascetic.css","modified":0,"renderable":1},{"_id":"themes/TKL/source/highlightjs/brown_paper.css","path":"highlightjs/brown_paper.css","modified":0,"renderable":1},{"_id":"themes/TKL/source/highlightjs/brown_papersq.png","path":"highlightjs/brown_papersq.png","modified":0,"renderable":1},{"_id":"themes/TKL/source/highlightjs/dark.css","path":"highlightjs/dark.css","modified":0,"renderable":1},{"_id":"themes/TKL/source/highlightjs/default.css","path":"highlightjs/default.css","modified":0,"renderable":1},{"_id":"themes/TKL/source/highlightjs/docco.css","path":"highlightjs/docco.css","modified":0,"renderable":1},{"_id":"themes/TKL/source/highlightjs/far.css","path":"highlightjs/far.css","modified":0,"renderable":1},{"_id":"themes/TKL/source/highlightjs/foundation.css","path":"highlightjs/foundation.css","modified":0,"renderable":1},{"_id":"themes/TKL/source/highlightjs/github.css","path":"highlightjs/github.css","modified":0,"renderable":1},{"_id":"themes/TKL/source/highlightjs/googlecode.css","path":"highlightjs/googlecode.css","modified":0,"renderable":1},{"_id":"themes/TKL/source/highlightjs/idea.css","path":"highlightjs/idea.css","modified":0,"renderable":1},{"_id":"themes/TKL/source/highlightjs/ir_black.css","path":"highlightjs/ir_black.css","modified":0,"renderable":1},{"_id":"themes/TKL/source/highlightjs/magula.css","path":"highlightjs/magula.css","modified":0,"renderable":1},{"_id":"themes/TKL/source/highlightjs/mono-blue.css","path":"highlightjs/mono-blue.css","modified":0,"renderable":1},{"_id":"themes/TKL/source/highlightjs/monokai.css","path":"highlightjs/monokai.css","modified":0,"renderable":1},{"_id":"themes/TKL/source/highlightjs/monokai_sublime.css","path":"highlightjs/monokai_sublime.css","modified":0,"renderable":1},{"_id":"themes/TKL/source/highlightjs/obsidian.css","path":"highlightjs/obsidian.css","modified":0,"renderable":1},{"_id":"themes/TKL/source/highlightjs/pojoaque.css","path":"highlightjs/pojoaque.css","modified":0,"renderable":1},{"_id":"themes/TKL/source/highlightjs/pojoaque.jpg","path":"highlightjs/pojoaque.jpg","modified":0,"renderable":1},{"_id":"themes/TKL/source/highlightjs/railscasts.css","path":"highlightjs/railscasts.css","modified":0,"renderable":1},{"_id":"themes/TKL/source/highlightjs/rainbow.css","path":"highlightjs/rainbow.css","modified":0,"renderable":1},{"_id":"themes/TKL/source/highlightjs/school_book.css","path":"highlightjs/school_book.css","modified":0,"renderable":1},{"_id":"themes/TKL/source/highlightjs/school_book.png","path":"highlightjs/school_book.png","modified":0,"renderable":1},{"_id":"themes/TKL/source/highlightjs/solarized_dark.css","path":"highlightjs/solarized_dark.css","modified":0,"renderable":1},{"_id":"themes/TKL/source/highlightjs/solarized_light.css","path":"highlightjs/solarized_light.css","modified":0,"renderable":1},{"_id":"themes/TKL/source/highlightjs/sunburst.css","path":"highlightjs/sunburst.css","modified":0,"renderable":1},{"_id":"themes/TKL/source/highlightjs/tomorrow-night-blue.css","path":"highlightjs/tomorrow-night-blue.css","modified":0,"renderable":1},{"_id":"themes/TKL/source/highlightjs/tomorrow-night-bright.css","path":"highlightjs/tomorrow-night-bright.css","modified":0,"renderable":1},{"_id":"themes/TKL/source/highlightjs/tomorrow-night-eighties.css","path":"highlightjs/tomorrow-night-eighties.css","modified":0,"renderable":1},{"_id":"themes/TKL/source/highlightjs/tomorrow-night.css","path":"highlightjs/tomorrow-night.css","modified":0,"renderable":1},{"_id":"themes/TKL/source/highlightjs/tomorrow.css","path":"highlightjs/tomorrow.css","modified":0,"renderable":1},{"_id":"themes/TKL/source/highlightjs/vs.css","path":"highlightjs/vs.css","modified":0,"renderable":1},{"_id":"themes/TKL/source/highlightjs/xcode.css","path":"highlightjs/xcode.css","modified":0,"renderable":1},{"_id":"themes/TKL/source/highlightjs/zenburn.css","path":"highlightjs/zenburn.css","modified":0,"renderable":1},{"_id":"themes/TKL/source/img/13.jpg","path":"img/13.jpg","modified":0,"renderable":1},{"_id":"themes/TKL/source/img/17.jpg","path":"img/17.jpg","modified":0,"renderable":1},{"_id":"themes/TKL/source/img/18.jpg","path":"img/18.jpg","modified":0,"renderable":1},{"_id":"themes/TKL/source/img/19.jpg","path":"img/19.jpg","modified":0,"renderable":1},{"_id":"themes/TKL/source/img/3.jpg","path":"img/3.jpg","modified":0,"renderable":1},{"_id":"themes/TKL/source/img/Kelly.png","path":"img/Kelly.png","modified":0,"renderable":1},{"_id":"themes/TKL/source/img/close.png","path":"img/close.png","modified":0,"renderable":1},{"_id":"themes/TKL/source/img/favicon_bak.ico","path":"img/favicon_bak.ico","modified":0,"renderable":1},{"_id":"themes/TKL/source/img/kiros.png","path":"img/kiros.png","modified":0,"renderable":1},{"_id":"themes/TKL/source/img/kiros_i.png","path":"img/kiros_i.png","modified":0,"renderable":1},{"_id":"themes/TKL/source/img/search.png","path":"img/search.png","modified":0,"renderable":1},{"_id":"themes/TKL/source/img/updown.png","path":"img/updown.png","modified":0,"renderable":1},{"_id":"themes/TKL/source/js/html5shiv.min.js","path":"js/html5shiv.min.js","modified":0,"renderable":1},{"_id":"themes/TKL/source/js/jquery.ajaxchimp.min.js","path":"js/jquery.ajaxchimp.min.js","modified":0,"renderable":1},{"_id":"themes/TKL/source/js/jquery.flexslider-min.js","path":"js/jquery.flexslider-min.js","modified":0,"renderable":1},{"_id":"themes/TKL/source/js/respond.min.js","path":"js/respond.min.js","modified":0,"renderable":1},{"_id":"themes/TKL/source/js/scripts.js","path":"js/scripts.js","modified":0,"renderable":1},{"_id":"themes/TKL/source/css/bootstrap.min.css","path":"css/bootstrap.min.css","modified":0,"renderable":1},{"_id":"themes/TKL/source/css/style.css","path":"css/style.css","modified":0,"renderable":1},{"_id":"themes/TKL/source/fonts/icons.svg","path":"fonts/icons.svg","modified":0,"renderable":1},{"_id":"themes/TKL/source/img/1.jpg","path":"img/1.jpg","modified":0,"renderable":1},{"_id":"themes/TKL/source/img/10.jpg","path":"img/10.jpg","modified":0,"renderable":1},{"_id":"themes/TKL/source/img/11.jpg","path":"img/11.jpg","modified":0,"renderable":1},{"_id":"themes/TKL/source/img/12.jpg","path":"img/12.jpg","modified":0,"renderable":1},{"_id":"themes/TKL/source/img/16.jpg","path":"img/16.jpg","modified":0,"renderable":1},{"_id":"themes/TKL/source/img/5.jpg","path":"img/5.jpg","modified":0,"renderable":1},{"_id":"themes/TKL/source/img/7.jpg","path":"img/7.jpg","modified":0,"renderable":1},{"_id":"themes/TKL/source/img/9.jpg","path":"img/9.jpg","modified":0,"renderable":1},{"_id":"themes/TKL/source/img/favicon.ico","path":"img/favicon.ico","modified":0,"renderable":1},{"_id":"themes/TKL/source/js/embed.js","path":"js/embed.js","modified":0,"renderable":1},{"_id":"themes/TKL/source/js/jquery-1.11.1.min.js","path":"js/jquery-1.11.1.min.js","modified":0,"renderable":1},{"_id":"themes/TKL/source/img/14.jpg","path":"img/14.jpg","modified":0,"renderable":1},{"_id":"themes/TKL/source/img/15.jpg","path":"img/15.jpg","modified":0,"renderable":1},{"_id":"themes/TKL/source/img/2.jpg","path":"img/2.jpg","modified":0,"renderable":1},{"_id":"themes/TKL/source/img/20.jpg","path":"img/20.jpg","modified":0,"renderable":1},{"_id":"themes/TKL/source/img/4.jpg","path":"img/4.jpg","modified":0,"renderable":1},{"_id":"themes/TKL/source/img/6.jpg","path":"img/6.jpg","modified":0,"renderable":1},{"_id":"themes/TKL/source/js/plugins.min.js","path":"js/plugins.min.js","modified":0,"renderable":1},{"_id":"themes/TKL/source/img/0.jpg","path":"img/0.jpg","modified":0,"renderable":1},{"_id":"themes/TKL/source/img/8.jpg","path":"img/8.jpg","modified":0,"renderable":1},{"_id":"themes/TKL/source/img/blog.png","path":"img/blog.png","modified":0,"renderable":1}],"Cache":[{"_id":"source/Staticfile","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1479476346925},{"_id":"source/CNAME","hash":"b3d55a011bd4876abc82a8f17ec346f55edeac54","modified":1479476346925},{"_id":"themes/TKL/LICENSE","hash":"c700a8b9312d24bdc57570f7d6a131cf63d89016","modified":1479476347495},{"_id":"themes/TKL/README.md","hash":"9ec2d6af15ebbd0d33efbb46a9c7adafd9331284","modified":1479476347495},{"_id":"themes/TKL/_config.yml","hash":"cc1be1ce01f2b418dc1a318f2a07d9cfc9449a51","modified":1481028277049},{"_id":"source/_posts/JVM_machine.md","hash":"7c37e8576ee3b386d31b15719fde40a31de52fae","modified":1480943509695},{"_id":"source/_posts/Java8_lambda.md","hash":"a5e3d489081ff856a4730c5324a356021680fa31","modified":1480943463073},{"_id":"source/_posts/Tomcat_performance_optimization.md","hash":"ebb11bb1f0e03d1bfca5876bd38ce5365a9a80bd","modified":1480943534569},{"_id":"source/_posts/mysql_bestpractice.md","hash":"f22411591b5353079fb4f8da816fcac1984b40e2","modified":1480946065191},{"_id":"source/_posts/vim_keyboard_shortcuts.md","hash":"d4018689770467c4f7668b914e599570228213e3","modified":1480947017618},{"_id":"themes/TKL/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1479476347342},{"_id":"themes/TKL/.git/config","hash":"096be49f42954eccf85049e2a6de27bc98968a32","modified":1479476347325},{"_id":"themes/TKL/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1479476347325},{"_id":"themes/TKL/.git/index","hash":"23d0688e72758225aead597b17745846b1ed7c49","modified":1480942920358},{"_id":"themes/TKL/.git/packed-refs","hash":"09574cc51c191d6e20e8ad88c2c0720fc763f0d7","modified":1479476347409},{"_id":"themes/TKL/layout/about.ejs","hash":"9a6da09178130877fa7c6852fe41c714b46b773c","modified":1479476347409},{"_id":"themes/TKL/layout/archive.ejs","hash":"43e2dd0a6f82acba7e8dae563ff358854e63338d","modified":1479476347409},{"_id":"themes/TKL/layout/category.ejs","hash":"7b863018dd9b05f8a1ebabf58e96add0049d7abe","modified":1479476347448},{"_id":"themes/TKL/layout/index.ejs","hash":"eaf7e49f416afce6685e36a24a65a01bb3fe9ae7","modified":1479476347448},{"_id":"themes/TKL/layout/layout.ejs","hash":"dc2eb5e29323758d9dedd2f27c0ec6d7b2e3c504","modified":1479476347463},{"_id":"themes/TKL/layout/page.ejs","hash":"f2c2725c591d5b24da9cf632fd6c3587867cc2c0","modified":1479476347463},{"_id":"themes/TKL/layout/post.ejs","hash":"13a176d843e7d44921e2705203011f0fcb46fcda","modified":1479476347479},{"_id":"themes/TKL/layout/tag.ejs","hash":"3e22a8a5281d7648d90b604f95cbdd1790008a70","modified":1479476347479},{"_id":"themes/TKL/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1479476347344},{"_id":"themes/TKL/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1479476347345},{"_id":"themes/TKL/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1479476347346},{"_id":"themes/TKL/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1479476347347},{"_id":"themes/TKL/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1479476347347},{"_id":"themes/TKL/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1479476347347},{"_id":"themes/TKL/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1479476347363},{"_id":"themes/TKL/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1479476347363},{"_id":"themes/TKL/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1479476347363},{"_id":"themes/TKL/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1479476347363},{"_id":"themes/TKL/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1479476347363},{"_id":"themes/TKL/.git/logs/HEAD","hash":"27ab9c7c5b42d3c14b20c9f5b221e6392656a173","modified":1479476347363},{"_id":"themes/TKL/layout/_widget/archive.ejs","hash":"985fbeb01142b9d526cda8ebc372c1d361d69a6b","modified":1479476347479},{"_id":"themes/TKL/layout/_widget/category.ejs","hash":"36ab37878129d152e3cbdeb839c08e52af1acd58","modified":1479476347479},{"_id":"themes/TKL/layout/_widget/recent_posts.ejs","hash":"feba7c00fa59ba13bf870b358a499fde4473d335","modified":1479476347479},{"_id":"themes/TKL/layout/_widget/tag.ejs","hash":"b3f321ddda6be2702a286d5b11af9533509506fb","modified":1479476347479},{"_id":"themes/TKL/layout/_widget/tagcloud.ejs","hash":"34dc8cdd96cdb41dd11cb7513f13714373e5104a","modified":1479476347479},{"_id":"themes/TKL/layout/casper/about.ejs","hash":"97ae41d0fd04f336a1669db673961265ed231747","modified":1481028855450},{"_id":"themes/TKL/layout/casper/after_all.ejs","hash":"8acc6944bbe0c005bea0259a6d8bfbad32ff17fa","modified":1479476347425},{"_id":"themes/TKL/layout/casper/archive.ejs","hash":"b5050dc7b0a3ae6aee29960941e64fe458657707","modified":1479476347442},{"_id":"themes/TKL/layout/casper/footer.ejs","hash":"461bd90bdcc1b5e382199dc5c78718159e2a3fed","modified":1479476347444},{"_id":"themes/TKL/layout/casper/head.ejs","hash":"980c60286641b58d3c9b8d4913bf4a00164dfcc3","modified":1479476347446},{"_id":"themes/TKL/layout/casper/header.ejs","hash":"a66d9266a7d35347c9cceed220bc8d877a65b9be","modified":1479476347448},{"_id":"themes/TKL/layout/casper/index.ejs","hash":"3e302f4b1b97e3b720e0c95ad2dc1053467120ff","modified":1479476347448},{"_id":"themes/TKL/layout/casper/post.ejs","hash":"6dd19f31f64d9bbdfef260ea021460237de1efa7","modified":1479476732853},{"_id":"themes/TKL/source/css/all.styl","hash":"b281ab5f908e16005c9e4e57f51ac7da9c4aab29","modified":1479476347495},{"_id":"themes/TKL/source/css/animate.css","hash":"fca75b84887199a0ed8e0f056ff30f5a1302f324","modified":1479476347510},{"_id":"themes/TKL/source/css/animsition.min.css","hash":"59033074f6594a0d87c759e2b8cf9baa3a62ed6a","modified":1479476347526},{"_id":"themes/TKL/source/css/custom.css","hash":"02e701a0dddde40f940df04f48aa3b0e27fd9f5b","modified":1479476347564},{"_id":"themes/TKL/source/css/flexslider.css","hash":"faebc8c54ca41e3c9936edaffbabbebd512c6d5a","modified":1479476347564},{"_id":"themes/TKL/source/css/iconList.css","hash":"f78ffffb4be40a6b0eb6ee109c958ccd062d1ae5","modified":1479476347564},{"_id":"themes/TKL/source/css/ie8.css","hash":"e50192947e5d0a68c1954bf551dbf273e6a1ed97","modified":1479476347564},{"_id":"themes/TKL/source/css/screen.css","hash":"a13c2c6fe420f76083df2da6d7b2d765dd8b467e","modified":1479476347579},{"_id":"themes/TKL/source/css/slidebars.min.css","hash":"a802c15d9bf06005b463901be8325d8ce38b5b04","modified":1479476347679},{"_id":"themes/TKL/source/css/syntax.styl","hash":"f39ea1e483c9244f39003d3efd20deb535ecddc7","modified":1479476347743},{"_id":"themes/TKL/source/fonts/icons.eot","hash":"e307fc2d61d13bbc3aafc9abd75e727cbebadee1","modified":1477149861841},{"_id":"themes/TKL/source/fonts/icons.ttf","hash":"2169592997f694ffa05b1d4c23d5a1abf35d3203","modified":1477149861842},{"_id":"themes/TKL/source/fonts/icons.woff","hash":"af538de6ac19d5da1cada203c7451ce32f5daceb","modified":1477149861843},{"_id":"themes/TKL/source/highlightjs/arta.css","hash":"08766ac9d70bde457fea9c553140029f57ace65a","modified":1479476347808},{"_id":"themes/TKL/source/highlightjs/ascetic.css","hash":"ef259aecdc8f1367dcf890d6467369300c4c0d07","modified":1479476347811},{"_id":"themes/TKL/source/highlightjs/brown_paper.css","hash":"2a987d30dd142a5c316ace70e919e3312707ebbd","modified":1479476347812},{"_id":"themes/TKL/source/highlightjs/brown_papersq.png","hash":"3a1332ede3a75a3d24f60b6ed69035b72da5e182","modified":1477149861844},{"_id":"themes/TKL/source/highlightjs/dark.css","hash":"2c2b4eb2562d812d95a26da0ffae51371b383713","modified":1479476347815},{"_id":"themes/TKL/source/highlightjs/default.css","hash":"108ad8410aa3004eafc452ae60771a2ae24d7988","modified":1479476347817},{"_id":"themes/TKL/source/highlightjs/docco.css","hash":"70199b44d688d0a22851bd5481260f24160a38ee","modified":1479476347819},{"_id":"themes/TKL/source/highlightjs/far.css","hash":"8178ac70abe577ae8345f1f6291bf7d489ad384d","modified":1479476347821},{"_id":"themes/TKL/source/highlightjs/foundation.css","hash":"308c2e0458fc117b323f7d9ce1644f7b4e52d99e","modified":1479476347824},{"_id":"themes/TKL/source/highlightjs/github.css","hash":"53f47e65e6e0e6068baf5c4b638b04d2f4e0b0bc","modified":1479476347831},{"_id":"themes/TKL/source/highlightjs/googlecode.css","hash":"731e74bcdfd1b68aae5b5805540f727c31309ba2","modified":1479476347833},{"_id":"themes/TKL/source/highlightjs/idea.css","hash":"fb77c293850c454c1f0c72628c0b301537765ad2","modified":1479476347836},{"_id":"themes/TKL/source/highlightjs/ir_black.css","hash":"2da52e8562b412039b5816e1a3a2f59e7dff0c27","modified":1479476347838},{"_id":"themes/TKL/source/highlightjs/magula.css","hash":"9c53982a77259331c1dc3b24ef744dd76b3fe643","modified":1479476347840},{"_id":"themes/TKL/source/highlightjs/mono-blue.css","hash":"c143e9d8c62dc71ca39bc0b6c127464ed2396e4f","modified":1479476347843},{"_id":"themes/TKL/source/highlightjs/monokai.css","hash":"a0edb8327c191516a04d456db8aae9044055a5cf","modified":1479476347845},{"_id":"themes/TKL/source/highlightjs/monokai_sublime.css","hash":"6b4716416b1bba643d3a7926221ce6d83a139141","modified":1479476347847},{"_id":"themes/TKL/source/highlightjs/obsidian.css","hash":"d6c264e1973beb9f20001b9a4013e9983923b34e","modified":1479476347849},{"_id":"themes/TKL/source/highlightjs/pojoaque.css","hash":"c9b048dc71c5b45d5cb3daac8f332a7e5d13b20f","modified":1479476347851},{"_id":"themes/TKL/source/highlightjs/pojoaque.jpg","hash":"c5fe6533b88b21f8d90d3d03954c6b29baa67791","modified":1477149861847},{"_id":"themes/TKL/source/highlightjs/railscasts.css","hash":"aeb6ecd79552b9611d447fe56de5266954ea055c","modified":1479476347855},{"_id":"themes/TKL/source/highlightjs/rainbow.css","hash":"b0e18f0f7fa08d5ad11956e2d9cc5e2ffdd514f3","modified":1479476347858},{"_id":"themes/TKL/source/highlightjs/school_book.css","hash":"f257d41cdca2609fa4c664df9cc14b48e2bcb09f","modified":1479476347861},{"_id":"themes/TKL/source/highlightjs/school_book.png","hash":"711ec983c874e093bb89eb77afcbdf6741fa61ee","modified":1477149861848},{"_id":"themes/TKL/source/highlightjs/solarized_dark.css","hash":"007f9f1e7addf7e2040734cd1f733d041432c335","modified":1479476347864},{"_id":"themes/TKL/source/highlightjs/solarized_light.css","hash":"a85878fd70ecd03c71944df1acbbf320bac7979f","modified":1479476347866},{"_id":"themes/TKL/source/highlightjs/sunburst.css","hash":"e72bc116795505c1fcae35bc69045043fc34a243","modified":1479476347868},{"_id":"themes/TKL/source/highlightjs/tomorrow-night-blue.css","hash":"e2bed22abcdf3f2b8ca3a1a73624751d3edc4e64","modified":1479476347870},{"_id":"themes/TKL/source/highlightjs/tomorrow-night-bright.css","hash":"afdb004743a8d2b52d38c7a1fce32d631a0f3ded","modified":1479476347872},{"_id":"themes/TKL/source/highlightjs/tomorrow-night-eighties.css","hash":"9603bc778de2dabd0ce1e7ee272a047338a8b99c","modified":1479476347876},{"_id":"themes/TKL/source/highlightjs/tomorrow-night.css","hash":"48cd18ce93daa491d89eb63e5fe3ab640ff56d74","modified":1479476347879},{"_id":"themes/TKL/source/highlightjs/tomorrow.css","hash":"a184e23b28b6a6401ecfc35e0a94de0bada589e4","modified":1479476347881},{"_id":"themes/TKL/source/highlightjs/vs.css","hash":"13e2f7ec2e197d79f4fc36768ea4a0663d41e1c0","modified":1479476347883},{"_id":"themes/TKL/source/highlightjs/xcode.css","hash":"78cb5758ce4085aa51edb6c5beb64d8f4511edd7","modified":1479476347885},{"_id":"themes/TKL/source/highlightjs/zenburn.css","hash":"73dafd21563f5fc3bb74856d4abf97c447a27772","modified":1479476347887},{"_id":"themes/TKL/source/img/13.jpg","hash":"11311be43d6f1d58d7e728fa5ed18d952a78075c","modified":1479393070574},{"_id":"themes/TKL/source/img/17.jpg","hash":"a851ad319f22600c37a4ab029ba3fc7df063cd48","modified":1479393070574},{"_id":"themes/TKL/source/img/18.jpg","hash":"a0177ffaf289eabaaa5dd4e6dbc7dcab8067b212","modified":1479393070574},{"_id":"themes/TKL/source/img/19.jpg","hash":"a681d47423d2cbc8eff6ad5042713c463f0ad527","modified":1479393070574},{"_id":"themes/TKL/source/img/3.jpg","hash":"6c121093cea0ac3d7256e28a78a23dd39909a4a1","modified":1479393070574},{"_id":"themes/TKL/source/img/Kelly.png","hash":"bd297cb8b575f068d86859c59ba1b5a3dc6fa754","modified":1479393070574},{"_id":"themes/TKL/source/img/close.png","hash":"47ba00cedad7355d869c8a4f53c7b9dab46795d0","modified":1479393070574},{"_id":"themes/TKL/source/img/favicon_bak.ico","hash":"70fbd67d92be00781652fed26bda9af8d931fb0a","modified":1478960566050},{"_id":"themes/TKL/source/img/kiros.png","hash":"4d4138f508fff3911496110a901e78d76aecedb1","modified":1479393070574},{"_id":"themes/TKL/source/img/kiros_i.png","hash":"89bcf21e985d9400bcd281b2805b38bb6de7151b","modified":1479393070574},{"_id":"themes/TKL/source/img/search.png","hash":"149e4bdfca287f4b5846db656e51f595e43deb56","modified":1479393070574},{"_id":"themes/TKL/source/img/updown.png","hash":"f06fc884fc7ff98281c83f2280d07fdb7f0aefab","modified":1479393070574},{"_id":"themes/TKL/source/js/html5shiv.min.js","hash":"bb51a5f6c394989bb06e4171179354c6d05ec8f8","modified":1479476348111},{"_id":"themes/TKL/source/js/jquery.ajaxchimp.min.js","hash":"9be17785b0d816e1cd6bc45908e1805e0522fe18","modified":1479476348134},{"_id":"themes/TKL/source/js/jquery.flexslider-min.js","hash":"51b3a7d882f438d53dc69ca5289e92254160c09a","modified":1479476348139},{"_id":"themes/TKL/source/js/respond.min.js","hash":"b5aba40d65b0d6f85859db47f757ea971a0efd30","modified":1479476348170},{"_id":"themes/TKL/source/js/scripts.js","hash":"0c6e99768269f960abf2a539a7f833a33b2a23b7","modified":1479476348173},{"_id":"themes/TKL/source/css/bootstrap.min.css","hash":"973e37a8502921d56bc02bb55321f45b072b6f71","modified":1479476347564},{"_id":"themes/TKL/source/css/style.css","hash":"5375977ce9031355508d01a6796bffda077f23ed","modified":1480947381995},{"_id":"themes/TKL/source/fonts/icons.svg","hash":"4b8357c608c01f304789e34bfd133081c1fc8b9d","modified":1479476347787},{"_id":"themes/TKL/source/img/1.jpg","hash":"0ea81d39593a5617a571f5a6c738c70ffc5005f8","modified":1479393070574},{"_id":"themes/TKL/source/img/10.jpg","hash":"b0fcaeafc2e3e62699f2fac68a4205c254e906cf","modified":1479393070574},{"_id":"themes/TKL/source/img/11.jpg","hash":"fb3ab435913c891a27d3826b18bbaaaa66b5c355","modified":1479393070578},{"_id":"themes/TKL/source/img/12.jpg","hash":"4b95bc850f5d6c3ce341e0ca77f2526ca61d9a59","modified":1479393070574},{"_id":"themes/TKL/source/img/16.jpg","hash":"02ed1c83487158f6dd99d0cf898bbe8758a097df","modified":1479393070574},{"_id":"themes/TKL/source/img/5.jpg","hash":"376380b2da2ce18814809b76b37fa6dd3197bb1f","modified":1479393070574},{"_id":"themes/TKL/source/img/7.jpg","hash":"f0ba806da2cf6c7e09e7dada07b0f1d3a2be8353","modified":1479393070574},{"_id":"themes/TKL/source/img/9.jpg","hash":"844137812ebd3a4a7825ce17486831b5423aea2c","modified":1479393070574},{"_id":"themes/TKL/source/img/favicon.ico","hash":"7b44e58643e529b728c9631bfb0b79952308f03b","modified":1478960566050},{"_id":"themes/TKL/source/js/embed.js","hash":"2210ec5e8fb7575e22098f6d77f55eed809d25e1","modified":1479476348109},{"_id":"themes/TKL/source/js/jquery-1.11.1.min.js","hash":"d6c1f41972de07b09bfa63d2e50f9ab41ec372bd","modified":1479476348131},{"_id":"themes/TKL/.git/objects/pack/pack-01f59e31ed4f7c5329280feb5ad8d445c078f6f7.idx","hash":"d47178729e86e3a6bd55bf9e8f625da16273510d","modified":1477149861654},{"_id":"themes/TKL/.git/refs/heads/master","hash":"d723c331deaa96e58af0aa46b7f25a3446bf0d20","modified":1479476347409},{"_id":"themes/TKL/layout/casper/post/comments.ejs","hash":"8246718d5a5838d6093971d52b8b217da3f4ea8c","modified":1479476347448},{"_id":"themes/TKL/layout/casper/post/duoshuo.ejs","hash":"3083a38fbb2dd8e9c84a6e7f187063d9167ef455","modified":1479476347448},{"_id":"themes/TKL/layout/casper/post/meta.ejs","hash":"c984cdc774bc884b33c8d87e3b59728cfdee773c","modified":1479476347448},{"_id":"themes/TKL/layout/casper/post/navigation.ejs","hash":"2cdf5a26df9e43d0df1a08aad1cb934e7aea3b4a","modified":1479476347448},{"_id":"themes/TKL/source/img/14.jpg","hash":"b6200819c28a441259ba73e2f24f7ff741cefc92","modified":1478960566059},{"_id":"themes/TKL/source/img/15.jpg","hash":"2f175fb1334e629ecc511210b640592359f2bdb5","modified":1479393070574},{"_id":"themes/TKL/source/img/2.jpg","hash":"bc7355e1a5174a29553ed37944a48c7ba29958cf","modified":1479393070574},{"_id":"themes/TKL/source/img/20.jpg","hash":"1393ec65de1b85f9b4fca21c25fecaf71f38fd9a","modified":1479393070574},{"_id":"themes/TKL/source/img/4.jpg","hash":"822d282a49a9a46f8cdcab2c4050f1d97dfe3c5c","modified":1479393070574},{"_id":"themes/TKL/source/img/6.jpg","hash":"d1897725e5334efa751e7730c26a7d97eddd714f","modified":1479393070574},{"_id":"themes/TKL/source/js/plugins.min.js","hash":"5d2edd4ecc4b27af81a3255ca8a253d23fc518e1","modified":1479476348167},{"_id":"themes/TKL/source/img/0.jpg","hash":"cdaa35848efbca159bcecbc95bcf97c0b4996bc6","modified":1479393070574},{"_id":"themes/TKL/source/img/8.jpg","hash":"4c9f852000d8681b173fb3175dbd5a17c96cc3ad","modified":1478960566072},{"_id":"themes/TKL/.git/logs/refs/heads/master","hash":"27ab9c7c5b42d3c14b20c9f5b221e6392656a173","modified":1479476347363},{"_id":"themes/TKL/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1479476347409},{"_id":"themes/TKL/.git/logs/refs/remotes/origin/HEAD","hash":"27ab9c7c5b42d3c14b20c9f5b221e6392656a173","modified":1479476347363},{"_id":"themes/TKL/source/img/blog.png","hash":"cca602b5c4158de6bf79e749511e8ed89b924635","modified":1477321350702},{"_id":"themes/TKL/.git/objects/pack/pack-01f59e31ed4f7c5329280feb5ad8d445c078f6f7.pack","hash":"7cfdc41a72ae1afb6bc3a4ba8f1bcab306814399","modified":1477149861683},{"_id":"public/highlightjs/brown_papersq.png","hash":"59a240c704e2d000e97a1e43f4781a90b3a0e619","modified":1480946094409},{"_id":"public/highlightjs/pojoaque.jpg","hash":"c311970ddf9b88aa160abbb051f505107bdae151","modified":1480946094409},{"_id":"public/highlightjs/school_book.png","hash":"69f15ca1f4f7d867e74eccd4f6dfc59234f6e243","modified":1480946094473},{"_id":"public/img/13.jpg","hash":"c4a5389b4c654b7e782c21e0c3b79b03f5c7d5db","modified":1480946094473},{"_id":"public/img/17.jpg","hash":"0e20cc553c29d8dbc7c266219aa71160a9d81164","modified":1480946094478},{"_id":"public/img/18.jpg","hash":"6d0b1ff7ab673811ec06cf9ce3f8187ff56b888c","modified":1480946094478},{"_id":"public/img/19.jpg","hash":"b29d7a7a033be3d75eaf28f3ae7389241370ee56","modified":1480946094478},{"_id":"public/img/3.jpg","hash":"ac97999195d291e39eda2b09cb3738e142089534","modified":1480946094478},{"_id":"public/fonts/icons.svg","hash":"f70e244175be4f96a237a748577f28f39dd3c7cb","modified":1480946094479},{"_id":"public/img/1.jpg","hash":"da6f3e9763b6f626b60a1a4db5b165c3de0fbf38","modified":1480946094479},{"_id":"public/img/10.jpg","hash":"fd3970717c7671b3f52c510bb8795e6e125e8fe3","modified":1480946094479},{"_id":"public/img/11.jpg","hash":"bfe3101dc4cfbd3fa1a5e3af2278e55e2b09a30a","modified":1480946094479},{"_id":"public/img/12.jpg","hash":"e35dcc5054f4582735bb706aa7c755837375774c","modified":1480946094479},{"_id":"public/img/16.jpg","hash":"bb6db0137c2b1711087692cb3e300945c17ea348","modified":1480946094479},{"_id":"public/img/5.jpg","hash":"96bf06dd75ceb6d1786926c92bd77b44712cdd6c","modified":1480946094479},{"_id":"public/img/7.jpg","hash":"ad87a926bf587bb60c3819efb9412ecb34960df1","modified":1480946094479},{"_id":"public/img/9.jpg","hash":"48ac66de6905d3b8bfc3be95f4a6f7134a63c3e0","modified":1480946094479},{"_id":"public/img/15.jpg","hash":"f69293bf3694f028404f267562ba7d25f5a47ebb","modified":1480946094479},{"_id":"public/img/2.jpg","hash":"8ea6fa0c1d5bebcef06e48163ec9002ade7c1e5e","modified":1480946094479},{"_id":"public/img/20.jpg","hash":"6a8a2f0643f608f6003618787b18caf7b808d370","modified":1480946094479},{"_id":"public/img/4.jpg","hash":"b8f7d5c1022ce5ea2a56eaa4d8b00a0a6d52aea9","modified":1480946094480},{"_id":"public/img/0.jpg","hash":"97f284673182053b776d433a606b7ae9ef4a5a67","modified":1480946094480},{"_id":"public/img/6.jpg","hash":"ae251eafc77ce5da0f088fd5d9d85cb0bf56f37a","modified":1480946094480},{"_id":"public/img/blog.png","hash":"8cd78f5b2e0c5f5eff34bebeb8f6adba8d9d63af","modified":1480946094480},{"_id":"public/search.xml","hash":"b246485ce7efce5ef354a8325d1e63f55360c5c9","modified":1480947078441},{"_id":"public/2016/09/19/vim_keyboard_shortcuts/index.html","hash":"a077126b8e86af5317d5af114488063a18c3918e","modified":1481029636945},{"_id":"public/archives/index.html","hash":"57eb48a2e6bf44fdc123e5c4d07604121d165095","modified":1481029636945},{"_id":"public/archives/2016/index.html","hash":"1f3fe63b30c859cefbb253cce6087ae4d14980bc","modified":1481029636945},{"_id":"public/archives/2016/08/index.html","hash":"9bce85c7e448c97fb8159cb0ca108c8df537815a","modified":1481029636945},{"_id":"public/archives/2016/09/index.html","hash":"747a3fefb8ac7414c171381258b32d74d99027df","modified":1481029636945},{"_id":"public/archives/2016/10/index.html","hash":"ca30ca41240c06fb37be42d68afb5502d7e5f8f1","modified":1481029636945},{"_id":"public/archives/2016/12/index.html","hash":"b362988431f784e2b6d72fb44e2c6a9c07c6fbc6","modified":1481029636945},{"_id":"public/categories/Java/index.html","hash":"1b6eec7ff8421ddf0d80cc5f147ae29a788279c7","modified":1481029636945},{"_id":"public/categories/Linux/index.html","hash":"05bc9eff95546acff0cb4c18c3e7e731d0cab232","modified":1481029636945},{"_id":"public/tags/Java/index.html","hash":"3fcd4fb4d2e01c32b100cbac059bb7fe735e657e","modified":1481029636945},{"_id":"public/tags/jvm/index.html","hash":"f8989d8c36cd360acc299e86a69113ad3fad3d61","modified":1481029636945},{"_id":"public/tags/虚拟机/index.html","hash":"e5de5343c275db52f464ddfcc0987cc716fbca7b","modified":1481029636945},{"_id":"public/tags/Tomcat/index.html","hash":"97349e81d47221d8d2334c6bd8de2d4084597c07","modified":1481029636945},{"_id":"public/tags/Linux/index.html","hash":"5218a7b1d83f23cdcaa6b4ecb9339a0c00f07e8e","modified":1481029636945},{"_id":"public/tags/vim/index.html","hash":"54f08ba69569a457df5a74d42e5dab651df2f361","modified":1481029636945},{"_id":"public/2016/12/05/Tomcat_performance_optimization/index.html","hash":"44d5ee685644d34f43532989b0b8213cd3f6e051","modified":1481029636945},{"_id":"public/2016/10/18/Java8_lambda/index.html","hash":"52d40986840486ea144a8ac4e18d6e7116c9b3ef","modified":1481029636945},{"_id":"public/2016/08/20/JVM_machine/index.html","hash":"6027adc3747c6792df10a19187ee4e6e5e2756c6","modified":1481029636945},{"_id":"public/index.html","hash":"80d10e9bc04f55872d2053be6bbdc3516206eae5","modified":1481029636945},{"_id":"public/categories/DB/index.html","hash":"10b9298ef882c4110ebb2e59100f656cc6a7ccb6","modified":1481029636945},{"_id":"public/tags/Mysql/index.html","hash":"42fad4aefe7be68a190c8169d77b18f2b60afe9c","modified":1481029636945},{"_id":"public/tags/DB/index.html","hash":"b493413d6712d48e48a71a551ed2195277e2d3bd","modified":1481029636945},{"_id":"public/tags/数据库/index.html","hash":"5abeffa46f43848abe9c3e23b826974c5d7f7b94","modified":1481029636945},{"_id":"public/2016/12/06/mysql_bestpractice/index.html","hash":"382f95379ceae0bd7c908c1079e56d6655c023ea","modified":1481029636945},{"_id":"public/Staticfile","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1480946094528},{"_id":"public/CNAME","hash":"b3d55a011bd4876abc82a8f17ec346f55edeac54","modified":1480946094534},{"_id":"public/fonts/icons.ttf","hash":"2169592997f694ffa05b1d4c23d5a1abf35d3203","modified":1480946094534},{"_id":"public/fonts/icons.eot","hash":"e307fc2d61d13bbc3aafc9abd75e727cbebadee1","modified":1480946094534},{"_id":"public/fonts/icons.woff","hash":"af538de6ac19d5da1cada203c7451ce32f5daceb","modified":1480946094534},{"_id":"public/img/close.png","hash":"47ba00cedad7355d869c8a4f53c7b9dab46795d0","modified":1480946094534},{"_id":"public/img/Kelly.png","hash":"bd297cb8b575f068d86859c59ba1b5a3dc6fa754","modified":1480946094534},{"_id":"public/img/favicon_bak.ico","hash":"70fbd67d92be00781652fed26bda9af8d931fb0a","modified":1480946094534},{"_id":"public/img/kiros.png","hash":"4d4138f508fff3911496110a901e78d76aecedb1","modified":1480946094534},{"_id":"public/img/kiros_i.png","hash":"89bcf21e985d9400bcd281b2805b38bb6de7151b","modified":1480946094534},{"_id":"public/img/search.png","hash":"149e4bdfca287f4b5846db656e51f595e43deb56","modified":1480946094534},{"_id":"public/img/updown.png","hash":"f06fc884fc7ff98281c83f2280d07fdb7f0aefab","modified":1480946094534},{"_id":"public/img/favicon.ico","hash":"7b44e58643e529b728c9631bfb0b79952308f03b","modified":1480946094827},{"_id":"public/js/html5shiv.min.js","hash":"d4368e7507f6aa4db736445ca4d9e50467dca191","modified":1480946098177},{"_id":"public/js/jquery.ajaxchimp.min.js","hash":"b3c0d8dd1dfac7b5289f553ccb1d904b3dd1c64a","modified":1480946098182},{"_id":"public/js/respond.min.js","hash":"299deb71717ba858906eb30a98f3e68be5987280","modified":1480946098182},{"_id":"public/js/scripts.js","hash":"4d98033b3fd8a377c1218c4380dc3dd9ce5f416c","modified":1480946098182},{"_id":"public/js/jquery.flexslider-min.js","hash":"9cd9ee2e1d559347cf68f8c10923a8b4ce67b7e8","modified":1480946098182},{"_id":"public/js/jquery-1.11.1.min.js","hash":"8629b5f1e7663aaf413909977564fbffe8abb283","modified":1480946098182},{"_id":"public/js/embed.js","hash":"2babc8f46ba9445da8928614cab224973a10d420","modified":1480946098182},{"_id":"public/js/plugins.min.js","hash":"acbccd036eb065bc35bba7d76484b9a8802c708c","modified":1480946098182},{"_id":"public/img/14.jpg","hash":"b6200819c28a441259ba73e2f24f7ff741cefc92","modified":1480946098182},{"_id":"public/css/screen.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1480946098188},{"_id":"public/css/animate.css","hash":"2724117db3f5eb4d25f9e3e19628a45123878423","modified":1480946098188},{"_id":"public/css/custom.css","hash":"766247e88acb85dec87e0e53050ee010f3445ba1","modified":1480946098188},{"_id":"public/css/iconList.css","hash":"53e9b9c3d5dcbd5b27fa5302a47e1ab2c5e3f0c0","modified":1480946098189},{"_id":"public/css/flexslider.css","hash":"cb5a95b76d724365fabb54d1b2f9a829b6ab8a7e","modified":1480946098189},{"_id":"public/css/ie8.css","hash":"44e5507b0efa856feb5385ed5f616bd0d90a7441","modified":1480946098189},{"_id":"public/css/slidebars.min.css","hash":"ffb2415fe4c7add46e9cfaa35a6ce6b4549629f5","modified":1480946098189},{"_id":"public/css/syntax.css","hash":"f1869da475fe216f2b3d8d43d974ffd6de26c056","modified":1480946098189},{"_id":"public/highlightjs/arta.css","hash":"8ec49c97680409bd2978b94742342401e16f6f4b","modified":1480946098189},{"_id":"public/highlightjs/ascetic.css","hash":"ec865b4c173b1031f981fd4e32b14abc62a4d9dd","modified":1480946098189},{"_id":"public/highlightjs/brown_paper.css","hash":"9a79eb004cfb8306b8cbbfb08363b9d849f31c6e","modified":1480946098189},{"_id":"public/highlightjs/dark.css","hash":"dc05ee900d965199b0d61025f7b1a7a6a0b89456","modified":1480946098189},{"_id":"public/highlightjs/default.css","hash":"c84b11f7fe23d68eb4b8000b3c53556b5d32b395","modified":1480946098189},{"_id":"public/highlightjs/docco.css","hash":"f5acce2d4625d15f146ead7ec5644f53d95f9e81","modified":1480946098189},{"_id":"public/highlightjs/foundation.css","hash":"eca88495060bdc7ab54cdb4ad50d32a4b5319d9b","modified":1480946098189},{"_id":"public/highlightjs/far.css","hash":"e2371ddd1456abfe8bdcebc0f8043a95952df25d","modified":1480946098189},{"_id":"public/highlightjs/github.css","hash":"1c08c5868371b16f07ba0f7614ce240619911bc1","modified":1480946098189},{"_id":"public/highlightjs/idea.css","hash":"541d326845918badc6bafc8c93f9dc8979626f20","modified":1480946098189},{"_id":"public/highlightjs/googlecode.css","hash":"3a56bfaa41421cbe7b7e5b6de4b631905e871fe7","modified":1480946098189},{"_id":"public/highlightjs/ir_black.css","hash":"9ab9fd0335bf4a1a1bcafb65e3962999eede3794","modified":1480946098189},{"_id":"public/highlightjs/magula.css","hash":"0f1dd3e2f40f34254feb1f73420fe9b22784d77e","modified":1480946098189},{"_id":"public/highlightjs/mono-blue.css","hash":"9e26e354852c1f648a7a4bd04f0a497071c0263b","modified":1480946098189},{"_id":"public/highlightjs/monokai.css","hash":"660b7bd0fa25710db79e6341abb6a1e061e409f0","modified":1480946098189},{"_id":"public/highlightjs/obsidian.css","hash":"9d5efd2d0eeb6e5941f2436c01826cf91cd22083","modified":1480946098190},{"_id":"public/highlightjs/monokai_sublime.css","hash":"5db9e793d1b8a1f115c6ac2e96039be21fedb8e2","modified":1480946098190},{"_id":"public/highlightjs/rainbow.css","hash":"ec8cc2d8f21fee88f27d9487074dac65088e7963","modified":1480946098190},{"_id":"public/highlightjs/pojoaque.css","hash":"308c8c4f4e86568f6083a0372ceda9613a997b5c","modified":1480946098190},{"_id":"public/highlightjs/railscasts.css","hash":"09fff420ea6a6375b43eea0895cc77589e8f6225","modified":1480946098190},{"_id":"public/highlightjs/school_book.css","hash":"902c332fe339e839b70cda0981fd5cbd03fb64df","modified":1480946098190},{"_id":"public/highlightjs/solarized_dark.css","hash":"8649adb922f61a44a1fc72510dde15aae46fbe53","modified":1480946098190},{"_id":"public/highlightjs/solarized_light.css","hash":"d31f137574a3b050a298f1d410995727eae201e3","modified":1480946098190},{"_id":"public/highlightjs/sunburst.css","hash":"bca04fa74761bf76994646fddd787ac79fdc1804","modified":1480946098190},{"_id":"public/highlightjs/tomorrow-night-blue.css","hash":"eeccb7e77e70a3ec29a1649a509d1c6e462fea9f","modified":1480946098190},{"_id":"public/highlightjs/tomorrow-night-eighties.css","hash":"8cd7af2fc2792c75e6a8f2b032dcd71ae36021b9","modified":1480946098190},{"_id":"public/highlightjs/tomorrow-night-bright.css","hash":"bf6b789cfe65c028f7ec516bbd204e015363cdab","modified":1480946098190},{"_id":"public/highlightjs/tomorrow-night.css","hash":"59bc690df306ffa299f38cfc1ccd3b15f6b6d971","modified":1480946098190},{"_id":"public/highlightjs/tomorrow.css","hash":"08444cf07e0f4b54e3e2e1d7aa370a053b7d8f55","modified":1480946098190},{"_id":"public/highlightjs/xcode.css","hash":"920057d87442d67b4e617591e713d43957a8018d","modified":1480946098190},{"_id":"public/highlightjs/vs.css","hash":"173762b8e120e42fbff635d23432136b1b492ed9","modified":1480946098190},{"_id":"public/highlightjs/zenburn.css","hash":"e33262862cfb26713ce2361e165938d0b403172d","modified":1480946098190},{"_id":"public/css/all.css","hash":"ea6606aaa9433ccd166e8b44b7104f8069d76227","modified":1480946098190},{"_id":"public/css/animsition.min.css","hash":"4e8fac6c3f095904dccdc7b0d4ecbc873b956466","modified":1480946098190},{"_id":"public/css/bootstrap.min.css","hash":"d77fa9faceb61f70af8a3677430ab75fc429c11f","modified":1480946098190},{"_id":"public/css/style.css","hash":"c873084ccb4a72dcb40d353cf60697fb7ec1c53d","modified":1480947474120},{"_id":"public/img/8.jpg","hash":"4c9f852000d8681b173fb3175dbd5a17c96cc3ad","modified":1480946098190},{"_id":"source/404.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1481029409918},{"_id":"source/about.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1481029398342},{"_id":"public/404.html","hash":"bdb561383e2f0ba5182ceec5f98ad597db251296","modified":1481029636945},{"_id":"public/about.html","hash":"bdb561383e2f0ba5182ceec5f98ad597db251296","modified":1481029636945}],"Category":[{"name":"Java","_id":"ciwc5273f0002o8l07f8bpjw1"},{"name":"DB","_id":"ciwc5273y000do8l0skjp66hv"},{"name":"Linux","_id":"ciwc52741000ho8l0flwucetx"}],"Data":[],"Page":[{"_content":"","source":"404.md","raw":"","date":"2016-12-06T13:03:34.314Z","updated":"2016-12-06T13:03:29.918Z","path":"404.html","title":"","comments":1,"layout":"page","_id":"ciwdistjw0000r4l0b9ghz3jw","content":"","excerpt":"","more":""},{"_content":"","source":"about.md","raw":"","date":"2016-12-06T13:03:24.213Z","updated":"2016-12-06T13:03:18.342Z","path":"about.html","title":"","comments":1,"layout":"page","_id":"ciwdistjw0001r4l0mci4janb","content":"","excerpt":"","more":""}],"Post":[{"title":"Jvm虚拟机深入总结","toc":true,"date":"2016-08-19T16:00:00.000Z","_content":"## JVM内存区域\n\n我们在编写程序时，经常会遇到OOM（out of Memory）以及内存泄漏等问题。为了避免出现这些问题，我们首先必须对JVM的内存划分有个具体的认识。JVM将内存主要划分为：方法区、虚拟机栈、本地方法栈、堆、程序计数器。JVM运行时数据区如下： \n\n### 程序计数器\n\n程序计数器是线程私有的区域，很好理解嘛~，每个线程当然得有个计数器记录当前执行到那个指令。占用的内存空间小，可以把它看成是当前线程所执行的字节码的行号指示器。如果线程在执行Java方法，这个计数器记录的是正在执行的虚拟机字节码指令地址；如果执行的是Native方法，这个计数器的值为空（Undefined）。此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。\n\n### Java虚拟机栈\n\n与程序计数器一样，Java虚拟机栈也是线程私有的。其生命周期与线程相同。如何理解虚拟机栈呢？本质上来讲，就是个栈。里面存放的元素叫栈帧，栈帧好像很复杂的样子，其实它很简单！它里面存放的是一个函数的上下文，具体存放的是执行的函数的一些数据。执行的函数需要的数据无非就是局部变量表（保存函数内部的变量）、操作数栈（执行引擎计算时需要），方法出口等等。\n\n执行引擎每调用一个函数时，就为这个函数创建一个栈帧，并加入虚拟机栈。换个角度理解，每个函数从调用到执行结束，其实是对应一个栈帧的入栈和出栈。\n\n注意这个区域可能出现的两种异常：一种是StackOverflowError，当前线程请求的栈深度大于虚拟机所允许的深度时，会抛出这个异常。制造这种异常很简单：将一个函数反复递归自己，最终会出现栈溢出错误（StackOverflowError）。另一种异常是OutOfMemoryError异常，当虚拟机栈可以动态扩展时（当前大部分虚拟机都可以），如果无法申请足够多的内存就会抛出OutOfMemoryError，如何制作虚拟机栈OOM呢，参考一下代码：\n\n```\npublic void stackLeakByThread(){\n    while(true){\n        new Thread(){\n            public void run(){\n                while(true){\n                }\n            }\n        }.start()\n    }\n}\n```\n这段代码有风险，可能会导致操作系统假死，请谨慎使用~~~\n\n### 本地方法栈\n\n本地方法栈与虚拟机栈所发挥的作用很相似，他们的区别在于虚拟机栈为执行Java代码方法服务，而本地方法栈是为Native方法服务。与虚拟机栈一样，本地方法栈也会抛出StackOverflowError和OutOfMemoryError异常。\n\n### Java堆\n\nJava堆可以说是虚拟机中最大一块内存了。它是所有线程所共享的内存区域，几乎所有的实例对象都是在这块区域中存放。当然，睡着JIT编译器的发展，所有对象在堆上分配渐渐变得不那么“绝对”了。\n\nJava堆是垃圾收集器管理的主要区域。由于现在的收集器基本上采用的都是分代收集算法，所有Java堆可以细分为：新生代和老年代。在细致分就是把新生代分为：Eden空间、From Survivor空间、To Survivor空间。当堆无法再扩展时，会抛出OutOfMemoryError异常。\n\n### 方法区\n\n方法区存放的是类信息、常量、静态变量等。方法区是各个线程共享区域，很容易理解，我们在写Java代码时，每个线程度可以访问同一个类的静态变量对象。由于使用反射机制的原因，虚拟机很难推测那个类信息不再使用，因此这块区域的回收很难。另外，对这块区域主要是针对常量池回收，值得注意的是JDK1.7已经把常量池转移到堆里面了。同样，当方法区无法满足内存分配需求时，会抛出OutOfMemoryError。 \n制造方法区内存溢出，注意，必须在JDK1.6及之前版本才会导致方法区溢出，原因后面解释,执行之前，可以把虚拟机的参数-XXpermSize和-XX：MaxPermSize限制方法区大小。\n\n```\nList<String> list =new ArrayList<String>();\nint i =0;\nwhile(true){\n    list.add(String.valueOf(i).intern());\n} \n```\n运行后会抛出java.lang.OutOfMemoryError:PermGen space异常。 \n解释一下，String的intern()函数作用是如果当前的字符串在常量池中不存在，则放入到常量池中。上面的代码不断将字符串添加到常量池，最终肯定会导致内存不足，抛出方法区的OOM。\n\n下面解释一下，为什么必须将上面的代码在JDK1.6之前运行。我们前面提到，JDK1.7后，把常量池放入到堆空间中，这导致intern()函数的功能不同，具体怎么个不同法，且看看下面代码：\n ```\n\nString str1 =new StringBuilder(\"hua\").append(\"chao\").toString();\nSystem.out.println(str1.intern()==str1);\n\nString str2=new StringBuilder(\"ja\").append(\"va\").toString();\nSystem.out.println(str2.intern()==str2);\n```\n这段代码在JDK1.6和JDK1.7运行的结果不同。JDK1.6结果是：false,false ，JDK1.7结果是true, false。原因是：JDK1.6中，intern()方法会吧首次遇到的字符串实例复制到常量池中，返回的也是常量池中的字符串的引用，而StringBuilder创建的字符串实例是在堆上面，所以必然不是同一个引用，返回false。在JDK1.7中，intern不再复制实例，常量池中只保存首次出现的实例的引用，因此intern()返回的引用和由StringBuilder创建的字符串实例是同一个。为什么对str2比较返回的是false呢？这是因为，JVM中内部在加载类的时候，就已经有”java”这个字符串，不符合“首次出现”的原则，因此返回false。\n\n## 垃圾回收（GC）\n\nJVM的垃圾回收机制中，判断一个对象是否死亡，并不是根据是否还有对象对其有引用，而是通过可达性分析。对象之间的引用可以抽象成树形结构，通过树根（GC Roots）作为起点，从这些树根往下搜索，搜索走过的链称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明这个对象是不可用的，该对象会被判定为可回收的对象。\n\n那么那些对象可作为GC Roots呢？主要有以下几种：\n\n- 1.虚拟机栈（栈帧中的本地变量表）中引用的对象。 \n- 2.方法区中类静态属性引用的对象。 \n- 3.方法区中常量引用的对象 \n- 4.本地方法栈中JNI（即一般说的Native方法）引用的对象。\n\n另外，Java还提供了软引用和弱引用，这两个引用是可以随时被虚拟机回收的对象，我们将一些比较占内存但是又可能后面用的对象，比如Bitmap对象，可以声明为软引用货弱引用。但是注意一点，每次使用这个对象时候，需要显示判断一下是否为null，以免出错。\n\n## 三种常见的垃圾收集算法\n\n- 1,标记-清除算法\n\n首先，通过可达性分析将可回收的对象进行标记，标记后再统一回收所有被标记的对象，标记过程其实就是可达性分析的过程。这种方法有2个不足点：效率问题，标记和清除两个过程的效率都不高；另一个是空间问题，标记清除之后会产生大量的不连续的内存碎片。\n\n- 2, 复制算法\n\n为了解决效率问题，复制算法是将内存分为大小相同的两块，每次只使用其中一块。当这块内存用完了，就将还存活的对象复制到另一块内存上面。然后再把已经使用过的内存一次清理掉。这使得每次只对半个区域进行垃圾回收，内存分配时也不用考虑内存碎片情况。\n\n但是，这代价实在是让人无法接受，需要牺牲一般的内存空间。研究发现，大部分对象都是“朝生夕死”，所以不需要安装1:1比例划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden空间和一块Survivor空间，默认比例为Eden：Survivor=8:1.新生代区域就是这么划分，每次实例在Eden和一块Survivor中分配，回收时，将存活的对象复制到剩下的另一块Survivor。这样只有10%的内存会被浪费，但是带来的效率却很高。当剩下的Survivor内存不足时，可以去老年代内存进行分配担保。如何理解分配担保呢，其实就是，内存不足时，去老年代内存空间分配，然后等新生代内存缓过来了之后，把内存归还给老年代，保持新生代中的Eden：Survivor=8:1.另外，两个Survivor分别有自己的名称：From Survivor、To Survivor。二者身份经常调换，即有时这块内存与Eden一起参与分配，有时是另一块。因为他们之间经常相互复制。\n\n- 3.标记-整理算法\n\n标记整理算法很简单，就是先标记需要回收的对象，然后把所有存活的对象移动到内存的一端。这样的好处是避免了内存碎片。\n\n## 类加载机制\n\n类从被加载到虚拟机内存开始，到卸载出内存为止，整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载七个阶段。\n\n其中加载、验证、准备、初始化、和卸载这5个阶段的顺序是确定的。而解析阶段不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java的运行时绑定。\n\n关于初始化：JVM规范明确规定，有且只有5中情况必须执行对类的初始化（加载、验证、准备自然再此之前要发生）： \n- 1.遇到new、getstatic、putstatic、invokestatic，如果类没有初始化，则必须初始化，这几条指令分别是指：new新对象、读取静态变量、设置静态变量，调用静态函数。 \n- 2.使用java.lang.reflect包的方法对类进行反射调用时，如果类没初始化，则需要初始化 \n- 3.当初始化一个类时，如果发现父类没有初始化，则需要先触发父类初始化。 \n- 4.当虚拟机启动时，用户需要制定一个执行的主类（包含main函数的类），虚拟机会先初始化这个类。 \n- 5.但是用JDK1.7启的动态语言支持时，如果一个MethodHandle实例最后解析的结果是REF_getStatic、REF_putStatic、Ref_invokeStatic的方法句柄时，并且这个方法句柄所对应的类没有进行初始化，则要先触发其初始化。\n\n另外要注意的是：通过子类来引用父类的静态字段，不会导致子类初始化：\n\n```\npublic class SuperClass{\n    public static int value=123;\n    static{\n        System.out.printLn(\"SuperClass init!\");\n    }\n}\n\npublic class SubClass extends SuperClass{\n    static{\n        System.out.println(\"SubClass init!\");\n    }\n\n\n}\n\npublic class Test{\n\n    public static void main(String[] args){\n        System.out.println(SubClass.value);\n    }\n}\n```\n最后只会打印：SuperClass init! \n对应静态变量，只有直接定义这个字段的类才会被初始化，因此通过子类类引用父类中定义的静态变量只会触发父类初始化而不会触发子类初始化。\n\n通过数组定义来引用类，不会触发此类的初始化：\n\n```\npublic class Test{\n\n    public static void main(String[] args){\n        SuperClass[] sca=new SuperClass[10];\n    }\n}\n```\n常量会在编译阶段存入调用者的常量池，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类初始化，示例代码如下：\n\n```\npublic class ConstClass{\n    public static final String HELLO_WORLD=\"hello world\";\n    static {\n        System.out.println(\"ConstClass init!\");\n    }\n\n}\n\npublic class Test{\n    public static void main(String[] args){\n\n        System.out.print(ConstClass.HELLO_WORLD);\n    }\n\n\n}\n```\n上面代码不会出现ConstClass init!\n\n### 加载\n\n加载过程主要做以下3件事 \n1.通过一个类的全限定名称来获取此类的二进制流 \n2.强这个字节流所代表的静态存储结构转化为方法区的运行时数据结构 \n3.在内存中生成一个代表这个类的java.lang.Class对象,作为方法区这个类的各种数据访问入口。\n\n### 验证\n\n这个阶段主要是为了确保Class文件字节流中包含信息符合当前虚拟机的要求，并且不会出现危害虚拟机自身的安全。\n\n### 准备\n\n准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都在方法区中分配。首先，这个时候分配内存仅仅包括类变量（被static修饰的变量），而不包括实例变量。实例变量会在对象实例化时随着对象一起分配在java堆中。其次这里所说的初始值“通常情况下”是数据类型的零值，假设一个类变量定义为\n\npublic static int value=123;\n那变量value在准备阶段后的初始值是0，而不是123，因为还没有执行任何Java方法，而把value赋值为123是在程序编译后，存放在类构造函数< clinit >()方法中。 \n解析\n\n解析阶段是把虚拟机中常量池的符号引用替换为直接引用的过程。\n\n### 初始化\n\n类初始化时类加载的最后一步，前面类加载过程中，除了加载阶段用户可以通过自定义类加载器参与以外，其余动作都是虚拟机主导和控制。到了初始化阶段，才是真正执行类中定义Java程序代码。\n\n准备阶段中，变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划初始化类变量。初始化过程其实是执行类构造器< clinit >()方法的过程。\n\n< clinit >()方法是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的。收集的顺序是按照语句在源文件中出现的顺序。静态语句块中只能访问定义在静态语句块之前的变量，定义在它之后的变量可以赋值，但不能访问。如下所示：\n\n```\npublic class Test{\n    static{\n        i=0;//給变量赋值，可以通过编译\n        System.out.print(i);//这句编译器会提示：“非法向前引用”\n    }\n    static int i=1;\n\n}\n```\n< clinit >()方法与类构造函数（或者说实例构造器< init >()）不同，他不需要显式地调用父类构造器，虚拟机会保证子类的< clinit >()方法执行之前，父类的< clinit >()已经执行完毕。","source":"_posts/JVM_machine.md","raw":"---\ntitle: Jvm虚拟机深入总结\ntags: [Java,jvm,虚拟机]\ncategories: Java\ntoc: true\ndate: 2016-08-20\n\n---\n## JVM内存区域\n\n我们在编写程序时，经常会遇到OOM（out of Memory）以及内存泄漏等问题。为了避免出现这些问题，我们首先必须对JVM的内存划分有个具体的认识。JVM将内存主要划分为：方法区、虚拟机栈、本地方法栈、堆、程序计数器。JVM运行时数据区如下： \n\n### 程序计数器\n\n程序计数器是线程私有的区域，很好理解嘛~，每个线程当然得有个计数器记录当前执行到那个指令。占用的内存空间小，可以把它看成是当前线程所执行的字节码的行号指示器。如果线程在执行Java方法，这个计数器记录的是正在执行的虚拟机字节码指令地址；如果执行的是Native方法，这个计数器的值为空（Undefined）。此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。\n\n### Java虚拟机栈\n\n与程序计数器一样，Java虚拟机栈也是线程私有的。其生命周期与线程相同。如何理解虚拟机栈呢？本质上来讲，就是个栈。里面存放的元素叫栈帧，栈帧好像很复杂的样子，其实它很简单！它里面存放的是一个函数的上下文，具体存放的是执行的函数的一些数据。执行的函数需要的数据无非就是局部变量表（保存函数内部的变量）、操作数栈（执行引擎计算时需要），方法出口等等。\n\n执行引擎每调用一个函数时，就为这个函数创建一个栈帧，并加入虚拟机栈。换个角度理解，每个函数从调用到执行结束，其实是对应一个栈帧的入栈和出栈。\n\n注意这个区域可能出现的两种异常：一种是StackOverflowError，当前线程请求的栈深度大于虚拟机所允许的深度时，会抛出这个异常。制造这种异常很简单：将一个函数反复递归自己，最终会出现栈溢出错误（StackOverflowError）。另一种异常是OutOfMemoryError异常，当虚拟机栈可以动态扩展时（当前大部分虚拟机都可以），如果无法申请足够多的内存就会抛出OutOfMemoryError，如何制作虚拟机栈OOM呢，参考一下代码：\n\n```\npublic void stackLeakByThread(){\n    while(true){\n        new Thread(){\n            public void run(){\n                while(true){\n                }\n            }\n        }.start()\n    }\n}\n```\n这段代码有风险，可能会导致操作系统假死，请谨慎使用~~~\n\n### 本地方法栈\n\n本地方法栈与虚拟机栈所发挥的作用很相似，他们的区别在于虚拟机栈为执行Java代码方法服务，而本地方法栈是为Native方法服务。与虚拟机栈一样，本地方法栈也会抛出StackOverflowError和OutOfMemoryError异常。\n\n### Java堆\n\nJava堆可以说是虚拟机中最大一块内存了。它是所有线程所共享的内存区域，几乎所有的实例对象都是在这块区域中存放。当然，睡着JIT编译器的发展，所有对象在堆上分配渐渐变得不那么“绝对”了。\n\nJava堆是垃圾收集器管理的主要区域。由于现在的收集器基本上采用的都是分代收集算法，所有Java堆可以细分为：新生代和老年代。在细致分就是把新生代分为：Eden空间、From Survivor空间、To Survivor空间。当堆无法再扩展时，会抛出OutOfMemoryError异常。\n\n### 方法区\n\n方法区存放的是类信息、常量、静态变量等。方法区是各个线程共享区域，很容易理解，我们在写Java代码时，每个线程度可以访问同一个类的静态变量对象。由于使用反射机制的原因，虚拟机很难推测那个类信息不再使用，因此这块区域的回收很难。另外，对这块区域主要是针对常量池回收，值得注意的是JDK1.7已经把常量池转移到堆里面了。同样，当方法区无法满足内存分配需求时，会抛出OutOfMemoryError。 \n制造方法区内存溢出，注意，必须在JDK1.6及之前版本才会导致方法区溢出，原因后面解释,执行之前，可以把虚拟机的参数-XXpermSize和-XX：MaxPermSize限制方法区大小。\n\n```\nList<String> list =new ArrayList<String>();\nint i =0;\nwhile(true){\n    list.add(String.valueOf(i).intern());\n} \n```\n运行后会抛出java.lang.OutOfMemoryError:PermGen space异常。 \n解释一下，String的intern()函数作用是如果当前的字符串在常量池中不存在，则放入到常量池中。上面的代码不断将字符串添加到常量池，最终肯定会导致内存不足，抛出方法区的OOM。\n\n下面解释一下，为什么必须将上面的代码在JDK1.6之前运行。我们前面提到，JDK1.7后，把常量池放入到堆空间中，这导致intern()函数的功能不同，具体怎么个不同法，且看看下面代码：\n ```\n\nString str1 =new StringBuilder(\"hua\").append(\"chao\").toString();\nSystem.out.println(str1.intern()==str1);\n\nString str2=new StringBuilder(\"ja\").append(\"va\").toString();\nSystem.out.println(str2.intern()==str2);\n```\n这段代码在JDK1.6和JDK1.7运行的结果不同。JDK1.6结果是：false,false ，JDK1.7结果是true, false。原因是：JDK1.6中，intern()方法会吧首次遇到的字符串实例复制到常量池中，返回的也是常量池中的字符串的引用，而StringBuilder创建的字符串实例是在堆上面，所以必然不是同一个引用，返回false。在JDK1.7中，intern不再复制实例，常量池中只保存首次出现的实例的引用，因此intern()返回的引用和由StringBuilder创建的字符串实例是同一个。为什么对str2比较返回的是false呢？这是因为，JVM中内部在加载类的时候，就已经有”java”这个字符串，不符合“首次出现”的原则，因此返回false。\n\n## 垃圾回收（GC）\n\nJVM的垃圾回收机制中，判断一个对象是否死亡，并不是根据是否还有对象对其有引用，而是通过可达性分析。对象之间的引用可以抽象成树形结构，通过树根（GC Roots）作为起点，从这些树根往下搜索，搜索走过的链称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明这个对象是不可用的，该对象会被判定为可回收的对象。\n\n那么那些对象可作为GC Roots呢？主要有以下几种：\n\n- 1.虚拟机栈（栈帧中的本地变量表）中引用的对象。 \n- 2.方法区中类静态属性引用的对象。 \n- 3.方法区中常量引用的对象 \n- 4.本地方法栈中JNI（即一般说的Native方法）引用的对象。\n\n另外，Java还提供了软引用和弱引用，这两个引用是可以随时被虚拟机回收的对象，我们将一些比较占内存但是又可能后面用的对象，比如Bitmap对象，可以声明为软引用货弱引用。但是注意一点，每次使用这个对象时候，需要显示判断一下是否为null，以免出错。\n\n## 三种常见的垃圾收集算法\n\n- 1,标记-清除算法\n\n首先，通过可达性分析将可回收的对象进行标记，标记后再统一回收所有被标记的对象，标记过程其实就是可达性分析的过程。这种方法有2个不足点：效率问题，标记和清除两个过程的效率都不高；另一个是空间问题，标记清除之后会产生大量的不连续的内存碎片。\n\n- 2, 复制算法\n\n为了解决效率问题，复制算法是将内存分为大小相同的两块，每次只使用其中一块。当这块内存用完了，就将还存活的对象复制到另一块内存上面。然后再把已经使用过的内存一次清理掉。这使得每次只对半个区域进行垃圾回收，内存分配时也不用考虑内存碎片情况。\n\n但是，这代价实在是让人无法接受，需要牺牲一般的内存空间。研究发现，大部分对象都是“朝生夕死”，所以不需要安装1:1比例划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden空间和一块Survivor空间，默认比例为Eden：Survivor=8:1.新生代区域就是这么划分，每次实例在Eden和一块Survivor中分配，回收时，将存活的对象复制到剩下的另一块Survivor。这样只有10%的内存会被浪费，但是带来的效率却很高。当剩下的Survivor内存不足时，可以去老年代内存进行分配担保。如何理解分配担保呢，其实就是，内存不足时，去老年代内存空间分配，然后等新生代内存缓过来了之后，把内存归还给老年代，保持新生代中的Eden：Survivor=8:1.另外，两个Survivor分别有自己的名称：From Survivor、To Survivor。二者身份经常调换，即有时这块内存与Eden一起参与分配，有时是另一块。因为他们之间经常相互复制。\n\n- 3.标记-整理算法\n\n标记整理算法很简单，就是先标记需要回收的对象，然后把所有存活的对象移动到内存的一端。这样的好处是避免了内存碎片。\n\n## 类加载机制\n\n类从被加载到虚拟机内存开始，到卸载出内存为止，整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载七个阶段。\n\n其中加载、验证、准备、初始化、和卸载这5个阶段的顺序是确定的。而解析阶段不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java的运行时绑定。\n\n关于初始化：JVM规范明确规定，有且只有5中情况必须执行对类的初始化（加载、验证、准备自然再此之前要发生）： \n- 1.遇到new、getstatic、putstatic、invokestatic，如果类没有初始化，则必须初始化，这几条指令分别是指：new新对象、读取静态变量、设置静态变量，调用静态函数。 \n- 2.使用java.lang.reflect包的方法对类进行反射调用时，如果类没初始化，则需要初始化 \n- 3.当初始化一个类时，如果发现父类没有初始化，则需要先触发父类初始化。 \n- 4.当虚拟机启动时，用户需要制定一个执行的主类（包含main函数的类），虚拟机会先初始化这个类。 \n- 5.但是用JDK1.7启的动态语言支持时，如果一个MethodHandle实例最后解析的结果是REF_getStatic、REF_putStatic、Ref_invokeStatic的方法句柄时，并且这个方法句柄所对应的类没有进行初始化，则要先触发其初始化。\n\n另外要注意的是：通过子类来引用父类的静态字段，不会导致子类初始化：\n\n```\npublic class SuperClass{\n    public static int value=123;\n    static{\n        System.out.printLn(\"SuperClass init!\");\n    }\n}\n\npublic class SubClass extends SuperClass{\n    static{\n        System.out.println(\"SubClass init!\");\n    }\n\n\n}\n\npublic class Test{\n\n    public static void main(String[] args){\n        System.out.println(SubClass.value);\n    }\n}\n```\n最后只会打印：SuperClass init! \n对应静态变量，只有直接定义这个字段的类才会被初始化，因此通过子类类引用父类中定义的静态变量只会触发父类初始化而不会触发子类初始化。\n\n通过数组定义来引用类，不会触发此类的初始化：\n\n```\npublic class Test{\n\n    public static void main(String[] args){\n        SuperClass[] sca=new SuperClass[10];\n    }\n}\n```\n常量会在编译阶段存入调用者的常量池，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类初始化，示例代码如下：\n\n```\npublic class ConstClass{\n    public static final String HELLO_WORLD=\"hello world\";\n    static {\n        System.out.println(\"ConstClass init!\");\n    }\n\n}\n\npublic class Test{\n    public static void main(String[] args){\n\n        System.out.print(ConstClass.HELLO_WORLD);\n    }\n\n\n}\n```\n上面代码不会出现ConstClass init!\n\n### 加载\n\n加载过程主要做以下3件事 \n1.通过一个类的全限定名称来获取此类的二进制流 \n2.强这个字节流所代表的静态存储结构转化为方法区的运行时数据结构 \n3.在内存中生成一个代表这个类的java.lang.Class对象,作为方法区这个类的各种数据访问入口。\n\n### 验证\n\n这个阶段主要是为了确保Class文件字节流中包含信息符合当前虚拟机的要求，并且不会出现危害虚拟机自身的安全。\n\n### 准备\n\n准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都在方法区中分配。首先，这个时候分配内存仅仅包括类变量（被static修饰的变量），而不包括实例变量。实例变量会在对象实例化时随着对象一起分配在java堆中。其次这里所说的初始值“通常情况下”是数据类型的零值，假设一个类变量定义为\n\npublic static int value=123;\n那变量value在准备阶段后的初始值是0，而不是123，因为还没有执行任何Java方法，而把value赋值为123是在程序编译后，存放在类构造函数< clinit >()方法中。 \n解析\n\n解析阶段是把虚拟机中常量池的符号引用替换为直接引用的过程。\n\n### 初始化\n\n类初始化时类加载的最后一步，前面类加载过程中，除了加载阶段用户可以通过自定义类加载器参与以外，其余动作都是虚拟机主导和控制。到了初始化阶段，才是真正执行类中定义Java程序代码。\n\n准备阶段中，变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划初始化类变量。初始化过程其实是执行类构造器< clinit >()方法的过程。\n\n< clinit >()方法是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的。收集的顺序是按照语句在源文件中出现的顺序。静态语句块中只能访问定义在静态语句块之前的变量，定义在它之后的变量可以赋值，但不能访问。如下所示：\n\n```\npublic class Test{\n    static{\n        i=0;//給变量赋值，可以通过编译\n        System.out.print(i);//这句编译器会提示：“非法向前引用”\n    }\n    static int i=1;\n\n}\n```\n< clinit >()方法与类构造函数（或者说实例构造器< init >()）不同，他不需要显式地调用父类构造器，虚拟机会保证子类的< clinit >()方法执行之前，父类的< clinit >()已经执行完毕。","slug":"JVM_machine","published":1,"updated":"2016-12-05T13:11:49.695Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwc527330000o8l0ywv3c4w9","content":"<h2 id=\"JVM内存区域\"><a href=\"#JVM内存区域\" class=\"headerlink\" title=\"JVM内存区域\"></a>JVM内存区域</h2><p>我们在编写程序时，经常会遇到OOM（out of Memory）以及内存泄漏等问题。为了避免出现这些问题，我们首先必须对JVM的内存划分有个具体的认识。JVM将内存主要划分为：方法区、虚拟机栈、本地方法栈、堆、程序计数器。JVM运行时数据区如下： </p>\n<h3 id=\"程序计数器\"><a href=\"#程序计数器\" class=\"headerlink\" title=\"程序计数器\"></a>程序计数器</h3><p>程序计数器是线程私有的区域，很好理解嘛~，每个线程当然得有个计数器记录当前执行到那个指令。占用的内存空间小，可以把它看成是当前线程所执行的字节码的行号指示器。如果线程在执行Java方法，这个计数器记录的是正在执行的虚拟机字节码指令地址；如果执行的是Native方法，这个计数器的值为空（Undefined）。此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</p>\n<h3 id=\"Java虚拟机栈\"><a href=\"#Java虚拟机栈\" class=\"headerlink\" title=\"Java虚拟机栈\"></a>Java虚拟机栈</h3><p>与程序计数器一样，Java虚拟机栈也是线程私有的。其生命周期与线程相同。如何理解虚拟机栈呢？本质上来讲，就是个栈。里面存放的元素叫栈帧，栈帧好像很复杂的样子，其实它很简单！它里面存放的是一个函数的上下文，具体存放的是执行的函数的一些数据。执行的函数需要的数据无非就是局部变量表（保存函数内部的变量）、操作数栈（执行引擎计算时需要），方法出口等等。</p>\n<p>执行引擎每调用一个函数时，就为这个函数创建一个栈帧，并加入虚拟机栈。换个角度理解，每个函数从调用到执行结束，其实是对应一个栈帧的入栈和出栈。</p>\n<p>注意这个区域可能出现的两种异常：一种是StackOverflowError，当前线程请求的栈深度大于虚拟机所允许的深度时，会抛出这个异常。制造这种异常很简单：将一个函数反复递归自己，最终会出现栈溢出错误（StackOverflowError）。另一种异常是OutOfMemoryError异常，当虚拟机栈可以动态扩展时（当前大部分虚拟机都可以），如果无法申请足够多的内存就会抛出OutOfMemoryError，如何制作虚拟机栈OOM呢，参考一下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void stackLeakByThread()&#123;</div><div class=\"line\">    while(true)&#123;</div><div class=\"line\">        new Thread()&#123;</div><div class=\"line\">            public void run()&#123;</div><div class=\"line\">                while(true)&#123;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;.start()</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这段代码有风险，可能会导致操作系统假死，请谨慎使用~~~</p>\n<h3 id=\"本地方法栈\"><a href=\"#本地方法栈\" class=\"headerlink\" title=\"本地方法栈\"></a>本地方法栈</h3><p>本地方法栈与虚拟机栈所发挥的作用很相似，他们的区别在于虚拟机栈为执行Java代码方法服务，而本地方法栈是为Native方法服务。与虚拟机栈一样，本地方法栈也会抛出StackOverflowError和OutOfMemoryError异常。</p>\n<h3 id=\"Java堆\"><a href=\"#Java堆\" class=\"headerlink\" title=\"Java堆\"></a>Java堆</h3><p>Java堆可以说是虚拟机中最大一块内存了。它是所有线程所共享的内存区域，几乎所有的实例对象都是在这块区域中存放。当然，睡着JIT编译器的发展，所有对象在堆上分配渐渐变得不那么“绝对”了。</p>\n<p>Java堆是垃圾收集器管理的主要区域。由于现在的收集器基本上采用的都是分代收集算法，所有Java堆可以细分为：新生代和老年代。在细致分就是把新生代分为：Eden空间、From Survivor空间、To Survivor空间。当堆无法再扩展时，会抛出OutOfMemoryError异常。</p>\n<h3 id=\"方法区\"><a href=\"#方法区\" class=\"headerlink\" title=\"方法区\"></a>方法区</h3><p>方法区存放的是类信息、常量、静态变量等。方法区是各个线程共享区域，很容易理解，我们在写Java代码时，每个线程度可以访问同一个类的静态变量对象。由于使用反射机制的原因，虚拟机很难推测那个类信息不再使用，因此这块区域的回收很难。另外，对这块区域主要是针对常量池回收，值得注意的是JDK1.7已经把常量池转移到堆里面了。同样，当方法区无法满足内存分配需求时，会抛出OutOfMemoryError。<br>制造方法区内存溢出，注意，必须在JDK1.6及之前版本才会导致方法区溢出，原因后面解释,执行之前，可以把虚拟机的参数-XXpermSize和-XX：MaxPermSize限制方法区大小。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">List&lt;String&gt; list =new ArrayList&lt;String&gt;();</div><div class=\"line\">int i =0;</div><div class=\"line\">while(true)&#123;</div><div class=\"line\">    list.add(String.valueOf(i).intern());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>运行后会抛出java.lang.OutOfMemoryError:PermGen space异常。<br>解释一下，String的intern()函数作用是如果当前的字符串在常量池中不存在，则放入到常量池中。上面的代码不断将字符串添加到常量池，最终肯定会导致内存不足，抛出方法区的OOM。</p>\n<p>下面解释一下，为什么必须将上面的代码在JDK1.6之前运行。我们前面提到，JDK1.7后，把常量池放入到堆空间中，这导致intern()函数的功能不同，具体怎么个不同法，且看看下面代码：<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">String str1 =new StringBuilder(&quot;hua&quot;).append(&quot;chao&quot;).toString();</div><div class=\"line\">System.out.println(str1.intern()==str1);</div><div class=\"line\"></div><div class=\"line\">String str2=new StringBuilder(&quot;ja&quot;).append(&quot;va&quot;).toString();</div><div class=\"line\">System.out.println(str2.intern()==str2);</div></pre></td></tr></table></figure></p>\n<p>这段代码在JDK1.6和JDK1.7运行的结果不同。JDK1.6结果是：false,false ，JDK1.7结果是true, false。原因是：JDK1.6中，intern()方法会吧首次遇到的字符串实例复制到常量池中，返回的也是常量池中的字符串的引用，而StringBuilder创建的字符串实例是在堆上面，所以必然不是同一个引用，返回false。在JDK1.7中，intern不再复制实例，常量池中只保存首次出现的实例的引用，因此intern()返回的引用和由StringBuilder创建的字符串实例是同一个。为什么对str2比较返回的是false呢？这是因为，JVM中内部在加载类的时候，就已经有”java”这个字符串，不符合“首次出现”的原则，因此返回false。</p>\n<h2 id=\"垃圾回收（GC）\"><a href=\"#垃圾回收（GC）\" class=\"headerlink\" title=\"垃圾回收（GC）\"></a>垃圾回收（GC）</h2><p>JVM的垃圾回收机制中，判断一个对象是否死亡，并不是根据是否还有对象对其有引用，而是通过可达性分析。对象之间的引用可以抽象成树形结构，通过树根（GC Roots）作为起点，从这些树根往下搜索，搜索走过的链称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明这个对象是不可用的，该对象会被判定为可回收的对象。</p>\n<p>那么那些对象可作为GC Roots呢？主要有以下几种：</p>\n<ul>\n<li>1.虚拟机栈（栈帧中的本地变量表）中引用的对象。 </li>\n<li>2.方法区中类静态属性引用的对象。 </li>\n<li>3.方法区中常量引用的对象 </li>\n<li>4.本地方法栈中JNI（即一般说的Native方法）引用的对象。</li>\n</ul>\n<p>另外，Java还提供了软引用和弱引用，这两个引用是可以随时被虚拟机回收的对象，我们将一些比较占内存但是又可能后面用的对象，比如Bitmap对象，可以声明为软引用货弱引用。但是注意一点，每次使用这个对象时候，需要显示判断一下是否为null，以免出错。</p>\n<h2 id=\"三种常见的垃圾收集算法\"><a href=\"#三种常见的垃圾收集算法\" class=\"headerlink\" title=\"三种常见的垃圾收集算法\"></a>三种常见的垃圾收集算法</h2><ul>\n<li>1,标记-清除算法</li>\n</ul>\n<p>首先，通过可达性分析将可回收的对象进行标记，标记后再统一回收所有被标记的对象，标记过程其实就是可达性分析的过程。这种方法有2个不足点：效率问题，标记和清除两个过程的效率都不高；另一个是空间问题，标记清除之后会产生大量的不连续的内存碎片。</p>\n<ul>\n<li>2, 复制算法</li>\n</ul>\n<p>为了解决效率问题，复制算法是将内存分为大小相同的两块，每次只使用其中一块。当这块内存用完了，就将还存活的对象复制到另一块内存上面。然后再把已经使用过的内存一次清理掉。这使得每次只对半个区域进行垃圾回收，内存分配时也不用考虑内存碎片情况。</p>\n<p>但是，这代价实在是让人无法接受，需要牺牲一般的内存空间。研究发现，大部分对象都是“朝生夕死”，所以不需要安装1:1比例划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden空间和一块Survivor空间，默认比例为Eden：Survivor=8:1.新生代区域就是这么划分，每次实例在Eden和一块Survivor中分配，回收时，将存活的对象复制到剩下的另一块Survivor。这样只有10%的内存会被浪费，但是带来的效率却很高。当剩下的Survivor内存不足时，可以去老年代内存进行分配担保。如何理解分配担保呢，其实就是，内存不足时，去老年代内存空间分配，然后等新生代内存缓过来了之后，把内存归还给老年代，保持新生代中的Eden：Survivor=8:1.另外，两个Survivor分别有自己的名称：From Survivor、To Survivor。二者身份经常调换，即有时这块内存与Eden一起参与分配，有时是另一块。因为他们之间经常相互复制。</p>\n<ul>\n<li>3.标记-整理算法</li>\n</ul>\n<p>标记整理算法很简单，就是先标记需要回收的对象，然后把所有存活的对象移动到内存的一端。这样的好处是避免了内存碎片。</p>\n<h2 id=\"类加载机制\"><a href=\"#类加载机制\" class=\"headerlink\" title=\"类加载机制\"></a>类加载机制</h2><p>类从被加载到虚拟机内存开始，到卸载出内存为止，整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载七个阶段。</p>\n<p>其中加载、验证、准备、初始化、和卸载这5个阶段的顺序是确定的。而解析阶段不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java的运行时绑定。</p>\n<p>关于初始化：JVM规范明确规定，有且只有5中情况必须执行对类的初始化（加载、验证、准备自然再此之前要发生）： </p>\n<ul>\n<li>1.遇到new、getstatic、putstatic、invokestatic，如果类没有初始化，则必须初始化，这几条指令分别是指：new新对象、读取静态变量、设置静态变量，调用静态函数。 </li>\n<li>2.使用java.lang.reflect包的方法对类进行反射调用时，如果类没初始化，则需要初始化 </li>\n<li>3.当初始化一个类时，如果发现父类没有初始化，则需要先触发父类初始化。 </li>\n<li>4.当虚拟机启动时，用户需要制定一个执行的主类（包含main函数的类），虚拟机会先初始化这个类。 </li>\n<li>5.但是用JDK1.7启的动态语言支持时，如果一个MethodHandle实例最后解析的结果是REF_getStatic、REF_putStatic、Ref_invokeStatic的方法句柄时，并且这个方法句柄所对应的类没有进行初始化，则要先触发其初始化。</li>\n</ul>\n<p>另外要注意的是：通过子类来引用父类的静态字段，不会导致子类初始化：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class SuperClass&#123;</div><div class=\"line\">    public static int value=123;</div><div class=\"line\">    static&#123;</div><div class=\"line\">        System.out.printLn(&quot;SuperClass init!&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">public class SubClass extends SuperClass&#123;</div><div class=\"line\">    static&#123;</div><div class=\"line\">        System.out.println(&quot;SubClass init!&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">public class Test&#123;</div><div class=\"line\"></div><div class=\"line\">    public static void main(String[] args)&#123;</div><div class=\"line\">        System.out.println(SubClass.value);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>最后只会打印：SuperClass init!<br>对应静态变量，只有直接定义这个字段的类才会被初始化，因此通过子类类引用父类中定义的静态变量只会触发父类初始化而不会触发子类初始化。</p>\n<p>通过数组定义来引用类，不会触发此类的初始化：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class Test&#123;</div><div class=\"line\"></div><div class=\"line\">    public static void main(String[] args)&#123;</div><div class=\"line\">        SuperClass[] sca=new SuperClass[10];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>常量会在编译阶段存入调用者的常量池，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类初始化，示例代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class ConstClass&#123;</div><div class=\"line\">    public static final String HELLO_WORLD=&quot;hello world&quot;;</div><div class=\"line\">    static &#123;</div><div class=\"line\">        System.out.println(&quot;ConstClass init!&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">public class Test&#123;</div><div class=\"line\">    public static void main(String[] args)&#123;</div><div class=\"line\"></div><div class=\"line\">        System.out.print(ConstClass.HELLO_WORLD);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面代码不会出现ConstClass init!</p>\n<h3 id=\"加载\"><a href=\"#加载\" class=\"headerlink\" title=\"加载\"></a>加载</h3><p>加载过程主要做以下3件事<br>1.通过一个类的全限定名称来获取此类的二进制流<br>2.强这个字节流所代表的静态存储结构转化为方法区的运行时数据结构<br>3.在内存中生成一个代表这个类的java.lang.Class对象,作为方法区这个类的各种数据访问入口。</p>\n<h3 id=\"验证\"><a href=\"#验证\" class=\"headerlink\" title=\"验证\"></a>验证</h3><p>这个阶段主要是为了确保Class文件字节流中包含信息符合当前虚拟机的要求，并且不会出现危害虚拟机自身的安全。</p>\n<h3 id=\"准备\"><a href=\"#准备\" class=\"headerlink\" title=\"准备\"></a>准备</h3><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都在方法区中分配。首先，这个时候分配内存仅仅包括类变量（被static修饰的变量），而不包括实例变量。实例变量会在对象实例化时随着对象一起分配在java堆中。其次这里所说的初始值“通常情况下”是数据类型的零值，假设一个类变量定义为</p>\n<p>public static int value=123;<br>那变量value在准备阶段后的初始值是0，而不是123，因为还没有执行任何Java方法，而把value赋值为123是在程序编译后，存放在类构造函数&lt; clinit &gt;()方法中。<br>解析</p>\n<p>解析阶段是把虚拟机中常量池的符号引用替换为直接引用的过程。</p>\n<h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><p>类初始化时类加载的最后一步，前面类加载过程中，除了加载阶段用户可以通过自定义类加载器参与以外，其余动作都是虚拟机主导和控制。到了初始化阶段，才是真正执行类中定义Java程序代码。</p>\n<p>准备阶段中，变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划初始化类变量。初始化过程其实是执行类构造器&lt; clinit &gt;()方法的过程。</p>\n<p>&lt; clinit &gt;()方法是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的。收集的顺序是按照语句在源文件中出现的顺序。静态语句块中只能访问定义在静态语句块之前的变量，定义在它之后的变量可以赋值，但不能访问。如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class Test&#123;</div><div class=\"line\">    static&#123;</div><div class=\"line\">        i=0;//給变量赋值，可以通过编译</div><div class=\"line\">        System.out.print(i);//这句编译器会提示：“非法向前引用”</div><div class=\"line\">    &#125;</div><div class=\"line\">    static int i=1;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>&lt; clinit &gt;()方法与类构造函数（或者说实例构造器&lt; init &gt;()）不同，他不需要显式地调用父类构造器，虚拟机会保证子类的&lt; clinit &gt;()方法执行之前，父类的&lt; clinit &gt;()已经执行完毕。</p>\n","excerpt":"","more":"<h2 id=\"JVM内存区域\"><a href=\"#JVM内存区域\" class=\"headerlink\" title=\"JVM内存区域\"></a>JVM内存区域</h2><p>我们在编写程序时，经常会遇到OOM（out of Memory）以及内存泄漏等问题。为了避免出现这些问题，我们首先必须对JVM的内存划分有个具体的认识。JVM将内存主要划分为：方法区、虚拟机栈、本地方法栈、堆、程序计数器。JVM运行时数据区如下： </p>\n<h3 id=\"程序计数器\"><a href=\"#程序计数器\" class=\"headerlink\" title=\"程序计数器\"></a>程序计数器</h3><p>程序计数器是线程私有的区域，很好理解嘛~，每个线程当然得有个计数器记录当前执行到那个指令。占用的内存空间小，可以把它看成是当前线程所执行的字节码的行号指示器。如果线程在执行Java方法，这个计数器记录的是正在执行的虚拟机字节码指令地址；如果执行的是Native方法，这个计数器的值为空（Undefined）。此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</p>\n<h3 id=\"Java虚拟机栈\"><a href=\"#Java虚拟机栈\" class=\"headerlink\" title=\"Java虚拟机栈\"></a>Java虚拟机栈</h3><p>与程序计数器一样，Java虚拟机栈也是线程私有的。其生命周期与线程相同。如何理解虚拟机栈呢？本质上来讲，就是个栈。里面存放的元素叫栈帧，栈帧好像很复杂的样子，其实它很简单！它里面存放的是一个函数的上下文，具体存放的是执行的函数的一些数据。执行的函数需要的数据无非就是局部变量表（保存函数内部的变量）、操作数栈（执行引擎计算时需要），方法出口等等。</p>\n<p>执行引擎每调用一个函数时，就为这个函数创建一个栈帧，并加入虚拟机栈。换个角度理解，每个函数从调用到执行结束，其实是对应一个栈帧的入栈和出栈。</p>\n<p>注意这个区域可能出现的两种异常：一种是StackOverflowError，当前线程请求的栈深度大于虚拟机所允许的深度时，会抛出这个异常。制造这种异常很简单：将一个函数反复递归自己，最终会出现栈溢出错误（StackOverflowError）。另一种异常是OutOfMemoryError异常，当虚拟机栈可以动态扩展时（当前大部分虚拟机都可以），如果无法申请足够多的内存就会抛出OutOfMemoryError，如何制作虚拟机栈OOM呢，参考一下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void stackLeakByThread()&#123;</div><div class=\"line\">    while(true)&#123;</div><div class=\"line\">        new Thread()&#123;</div><div class=\"line\">            public void run()&#123;</div><div class=\"line\">                while(true)&#123;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;.start()</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这段代码有风险，可能会导致操作系统假死，请谨慎使用~~~</p>\n<h3 id=\"本地方法栈\"><a href=\"#本地方法栈\" class=\"headerlink\" title=\"本地方法栈\"></a>本地方法栈</h3><p>本地方法栈与虚拟机栈所发挥的作用很相似，他们的区别在于虚拟机栈为执行Java代码方法服务，而本地方法栈是为Native方法服务。与虚拟机栈一样，本地方法栈也会抛出StackOverflowError和OutOfMemoryError异常。</p>\n<h3 id=\"Java堆\"><a href=\"#Java堆\" class=\"headerlink\" title=\"Java堆\"></a>Java堆</h3><p>Java堆可以说是虚拟机中最大一块内存了。它是所有线程所共享的内存区域，几乎所有的实例对象都是在这块区域中存放。当然，睡着JIT编译器的发展，所有对象在堆上分配渐渐变得不那么“绝对”了。</p>\n<p>Java堆是垃圾收集器管理的主要区域。由于现在的收集器基本上采用的都是分代收集算法，所有Java堆可以细分为：新生代和老年代。在细致分就是把新生代分为：Eden空间、From Survivor空间、To Survivor空间。当堆无法再扩展时，会抛出OutOfMemoryError异常。</p>\n<h3 id=\"方法区\"><a href=\"#方法区\" class=\"headerlink\" title=\"方法区\"></a>方法区</h3><p>方法区存放的是类信息、常量、静态变量等。方法区是各个线程共享区域，很容易理解，我们在写Java代码时，每个线程度可以访问同一个类的静态变量对象。由于使用反射机制的原因，虚拟机很难推测那个类信息不再使用，因此这块区域的回收很难。另外，对这块区域主要是针对常量池回收，值得注意的是JDK1.7已经把常量池转移到堆里面了。同样，当方法区无法满足内存分配需求时，会抛出OutOfMemoryError。<br>制造方法区内存溢出，注意，必须在JDK1.6及之前版本才会导致方法区溢出，原因后面解释,执行之前，可以把虚拟机的参数-XXpermSize和-XX：MaxPermSize限制方法区大小。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">List&lt;String&gt; list =new ArrayList&lt;String&gt;();</div><div class=\"line\">int i =0;</div><div class=\"line\">while(true)&#123;</div><div class=\"line\">    list.add(String.valueOf(i).intern());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>运行后会抛出java.lang.OutOfMemoryError:PermGen space异常。<br>解释一下，String的intern()函数作用是如果当前的字符串在常量池中不存在，则放入到常量池中。上面的代码不断将字符串添加到常量池，最终肯定会导致内存不足，抛出方法区的OOM。</p>\n<p>下面解释一下，为什么必须将上面的代码在JDK1.6之前运行。我们前面提到，JDK1.7后，把常量池放入到堆空间中，这导致intern()函数的功能不同，具体怎么个不同法，且看看下面代码：<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">String str1 =new StringBuilder(&quot;hua&quot;).append(&quot;chao&quot;).toString();</div><div class=\"line\">System.out.println(str1.intern()==str1);</div><div class=\"line\"></div><div class=\"line\">String str2=new StringBuilder(&quot;ja&quot;).append(&quot;va&quot;).toString();</div><div class=\"line\">System.out.println(str2.intern()==str2);</div></pre></td></tr></table></figure></p>\n<p>这段代码在JDK1.6和JDK1.7运行的结果不同。JDK1.6结果是：false,false ，JDK1.7结果是true, false。原因是：JDK1.6中，intern()方法会吧首次遇到的字符串实例复制到常量池中，返回的也是常量池中的字符串的引用，而StringBuilder创建的字符串实例是在堆上面，所以必然不是同一个引用，返回false。在JDK1.7中，intern不再复制实例，常量池中只保存首次出现的实例的引用，因此intern()返回的引用和由StringBuilder创建的字符串实例是同一个。为什么对str2比较返回的是false呢？这是因为，JVM中内部在加载类的时候，就已经有”java”这个字符串，不符合“首次出现”的原则，因此返回false。</p>\n<h2 id=\"垃圾回收（GC）\"><a href=\"#垃圾回收（GC）\" class=\"headerlink\" title=\"垃圾回收（GC）\"></a>垃圾回收（GC）</h2><p>JVM的垃圾回收机制中，判断一个对象是否死亡，并不是根据是否还有对象对其有引用，而是通过可达性分析。对象之间的引用可以抽象成树形结构，通过树根（GC Roots）作为起点，从这些树根往下搜索，搜索走过的链称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明这个对象是不可用的，该对象会被判定为可回收的对象。</p>\n<p>那么那些对象可作为GC Roots呢？主要有以下几种：</p>\n<ul>\n<li>1.虚拟机栈（栈帧中的本地变量表）中引用的对象。 </li>\n<li>2.方法区中类静态属性引用的对象。 </li>\n<li>3.方法区中常量引用的对象 </li>\n<li>4.本地方法栈中JNI（即一般说的Native方法）引用的对象。</li>\n</ul>\n<p>另外，Java还提供了软引用和弱引用，这两个引用是可以随时被虚拟机回收的对象，我们将一些比较占内存但是又可能后面用的对象，比如Bitmap对象，可以声明为软引用货弱引用。但是注意一点，每次使用这个对象时候，需要显示判断一下是否为null，以免出错。</p>\n<h2 id=\"三种常见的垃圾收集算法\"><a href=\"#三种常见的垃圾收集算法\" class=\"headerlink\" title=\"三种常见的垃圾收集算法\"></a>三种常见的垃圾收集算法</h2><ul>\n<li>1,标记-清除算法</li>\n</ul>\n<p>首先，通过可达性分析将可回收的对象进行标记，标记后再统一回收所有被标记的对象，标记过程其实就是可达性分析的过程。这种方法有2个不足点：效率问题，标记和清除两个过程的效率都不高；另一个是空间问题，标记清除之后会产生大量的不连续的内存碎片。</p>\n<ul>\n<li>2, 复制算法</li>\n</ul>\n<p>为了解决效率问题，复制算法是将内存分为大小相同的两块，每次只使用其中一块。当这块内存用完了，就将还存活的对象复制到另一块内存上面。然后再把已经使用过的内存一次清理掉。这使得每次只对半个区域进行垃圾回收，内存分配时也不用考虑内存碎片情况。</p>\n<p>但是，这代价实在是让人无法接受，需要牺牲一般的内存空间。研究发现，大部分对象都是“朝生夕死”，所以不需要安装1:1比例划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden空间和一块Survivor空间，默认比例为Eden：Survivor=8:1.新生代区域就是这么划分，每次实例在Eden和一块Survivor中分配，回收时，将存活的对象复制到剩下的另一块Survivor。这样只有10%的内存会被浪费，但是带来的效率却很高。当剩下的Survivor内存不足时，可以去老年代内存进行分配担保。如何理解分配担保呢，其实就是，内存不足时，去老年代内存空间分配，然后等新生代内存缓过来了之后，把内存归还给老年代，保持新生代中的Eden：Survivor=8:1.另外，两个Survivor分别有自己的名称：From Survivor、To Survivor。二者身份经常调换，即有时这块内存与Eden一起参与分配，有时是另一块。因为他们之间经常相互复制。</p>\n<ul>\n<li>3.标记-整理算法</li>\n</ul>\n<p>标记整理算法很简单，就是先标记需要回收的对象，然后把所有存活的对象移动到内存的一端。这样的好处是避免了内存碎片。</p>\n<h2 id=\"类加载机制\"><a href=\"#类加载机制\" class=\"headerlink\" title=\"类加载机制\"></a>类加载机制</h2><p>类从被加载到虚拟机内存开始，到卸载出内存为止，整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载七个阶段。</p>\n<p>其中加载、验证、准备、初始化、和卸载这5个阶段的顺序是确定的。而解析阶段不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java的运行时绑定。</p>\n<p>关于初始化：JVM规范明确规定，有且只有5中情况必须执行对类的初始化（加载、验证、准备自然再此之前要发生）： </p>\n<ul>\n<li>1.遇到new、getstatic、putstatic、invokestatic，如果类没有初始化，则必须初始化，这几条指令分别是指：new新对象、读取静态变量、设置静态变量，调用静态函数。 </li>\n<li>2.使用java.lang.reflect包的方法对类进行反射调用时，如果类没初始化，则需要初始化 </li>\n<li>3.当初始化一个类时，如果发现父类没有初始化，则需要先触发父类初始化。 </li>\n<li>4.当虚拟机启动时，用户需要制定一个执行的主类（包含main函数的类），虚拟机会先初始化这个类。 </li>\n<li>5.但是用JDK1.7启的动态语言支持时，如果一个MethodHandle实例最后解析的结果是REF_getStatic、REF_putStatic、Ref_invokeStatic的方法句柄时，并且这个方法句柄所对应的类没有进行初始化，则要先触发其初始化。</li>\n</ul>\n<p>另外要注意的是：通过子类来引用父类的静态字段，不会导致子类初始化：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class SuperClass&#123;</div><div class=\"line\">    public static int value=123;</div><div class=\"line\">    static&#123;</div><div class=\"line\">        System.out.printLn(&quot;SuperClass init!&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">public class SubClass extends SuperClass&#123;</div><div class=\"line\">    static&#123;</div><div class=\"line\">        System.out.println(&quot;SubClass init!&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">public class Test&#123;</div><div class=\"line\"></div><div class=\"line\">    public static void main(String[] args)&#123;</div><div class=\"line\">        System.out.println(SubClass.value);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>最后只会打印：SuperClass init!<br>对应静态变量，只有直接定义这个字段的类才会被初始化，因此通过子类类引用父类中定义的静态变量只会触发父类初始化而不会触发子类初始化。</p>\n<p>通过数组定义来引用类，不会触发此类的初始化：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class Test&#123;</div><div class=\"line\"></div><div class=\"line\">    public static void main(String[] args)&#123;</div><div class=\"line\">        SuperClass[] sca=new SuperClass[10];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>常量会在编译阶段存入调用者的常量池，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类初始化，示例代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class ConstClass&#123;</div><div class=\"line\">    public static final String HELLO_WORLD=&quot;hello world&quot;;</div><div class=\"line\">    static &#123;</div><div class=\"line\">        System.out.println(&quot;ConstClass init!&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">public class Test&#123;</div><div class=\"line\">    public static void main(String[] args)&#123;</div><div class=\"line\"></div><div class=\"line\">        System.out.print(ConstClass.HELLO_WORLD);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面代码不会出现ConstClass init!</p>\n<h3 id=\"加载\"><a href=\"#加载\" class=\"headerlink\" title=\"加载\"></a>加载</h3><p>加载过程主要做以下3件事<br>1.通过一个类的全限定名称来获取此类的二进制流<br>2.强这个字节流所代表的静态存储结构转化为方法区的运行时数据结构<br>3.在内存中生成一个代表这个类的java.lang.Class对象,作为方法区这个类的各种数据访问入口。</p>\n<h3 id=\"验证\"><a href=\"#验证\" class=\"headerlink\" title=\"验证\"></a>验证</h3><p>这个阶段主要是为了确保Class文件字节流中包含信息符合当前虚拟机的要求，并且不会出现危害虚拟机自身的安全。</p>\n<h3 id=\"准备\"><a href=\"#准备\" class=\"headerlink\" title=\"准备\"></a>准备</h3><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都在方法区中分配。首先，这个时候分配内存仅仅包括类变量（被static修饰的变量），而不包括实例变量。实例变量会在对象实例化时随着对象一起分配在java堆中。其次这里所说的初始值“通常情况下”是数据类型的零值，假设一个类变量定义为</p>\n<p>public static int value=123;<br>那变量value在准备阶段后的初始值是0，而不是123，因为还没有执行任何Java方法，而把value赋值为123是在程序编译后，存放在类构造函数&lt; clinit &gt;()方法中。<br>解析</p>\n<p>解析阶段是把虚拟机中常量池的符号引用替换为直接引用的过程。</p>\n<h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><p>类初始化时类加载的最后一步，前面类加载过程中，除了加载阶段用户可以通过自定义类加载器参与以外，其余动作都是虚拟机主导和控制。到了初始化阶段，才是真正执行类中定义Java程序代码。</p>\n<p>准备阶段中，变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划初始化类变量。初始化过程其实是执行类构造器&lt; clinit &gt;()方法的过程。</p>\n<p>&lt; clinit &gt;()方法是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的。收集的顺序是按照语句在源文件中出现的顺序。静态语句块中只能访问定义在静态语句块之前的变量，定义在它之后的变量可以赋值，但不能访问。如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class Test&#123;</div><div class=\"line\">    static&#123;</div><div class=\"line\">        i=0;//給变量赋值，可以通过编译</div><div class=\"line\">        System.out.print(i);//这句编译器会提示：“非法向前引用”</div><div class=\"line\">    &#125;</div><div class=\"line\">    static int i=1;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>&lt; clinit &gt;()方法与类构造函数（或者说实例构造器&lt; init &gt;()）不同，他不需要显式地调用父类构造器，虚拟机会保证子类的&lt; clinit &gt;()方法执行之前，父类的&lt; clinit &gt;()已经执行完毕。</p>\n"},{"title":"深入理解Java 8 Lambda","toc":true,"date":"2016-10-17T16:00:00.000Z","_content":"\n## 关于\n\n本文介绍了Java SE 8中新引入的lambda语言特性以及这些特性背后的设计思想。这些特性包括：\n\nlambda表达式（又被成为“闭包”或“匿名方法”）\n方法引用和构造方法引用\n扩展的目标类型和类型推导\n接口中的默认方法和静态方法\n## 背景\n\nJava是一门面向对象编程语言。面向对象编程语言和函数式编程语言中的基本元素（Basic Values）都可以动态封装程序行为：面向对象编程语言使用带有方法的对象封装行为，函数式编程语言使用函数封装行为。但这个相同点并不明显，因为Java的对象往往比较“重量级”：实例化一个类型往往会涉及不同的类，并需要初始化类里的字段和方法。\n\n不过有些Java对象只是对单个函数的封装。例如下面这个典型用例：Java API中定义了一个接口（一般被称为回调接口），用户通过提供这个接口的实例来传入指定行为，例如：\n```\n\npublic interface ActionListener {\n  void actionPerformed(ActionEvent e);\n}\n这里并不需要专门定义一个类来实现ActionListener接口，因为它只会在调用处被使用一次。用户一般会使用匿名类型把行为内联（inline）：\n\nbutton.addActionListener(new ActionListener) {\n  public void actionPerformed(ActionEvent e) {\n    ui.dazzle(e.getModifiers());\n  }\n}\n```\n很多库都依赖于上面的模式。对于并行API更是如此，因为我们需要把待执行的代码提供给并行API，并行编程是一个非常值得研究的领域，因为在这里摩尔定律得到了重生：尽管我们没有更快的CPU核心（core），但是我们有更多的CPU核心。而串行API就只能使用有限的计算能力。\n\n随着回调模式和函数式编程风格的日益流行，我们需要在Java中提供一种尽可能轻量级的将代码封装为数据（Model code as data）的方法。匿名内部类并不是一个好的选择，因为：\n\n语法过于冗余\n匿名类中的this和变量名容易使人产生误解\n类型载入和实例创建语义不够灵活\n无法捕获非final的局部变量\n无法对控制流进行抽象\n上面的多数问题均在Java SE 8中得以解决：\n\n通过提供更简洁的语法和局部作用域规则，Java SE 8彻底解决了问题1和问题2\n通过提供更加灵活而且便于优化的表达式语义，Java SE 8绕开了问题3\n通过允许编译器推断变量的“常量性”（finality），Java SE 8减轻了问题4带来的困扰\n不过，Java SE 8的目标并非解决所有上述问题。因此捕获可变变量（问题4）和非局部控制流（问题5）并不在Java SE 8的范畴之内。（尽管我们可能会在未来提供对这些特性的支持）\n\n##函数式接口\n\n尽管匿名内部类有着种种限制和问题，但是它有一个良好的特性，它和Java类型系统结合的十分紧密：每一个函数对象都对应一个接口类型。之所以说这个特性是良好的，是因为：\n\n接口是Java类型系统的一部分\n接口天然就拥有其运行时表示（Runtime representation）\n接口可以通过Javadoc注释来表达一些非正式的协定（contract），例如，通过注释说明该操作应可交换（commutative）\n上面提到的ActionListener接口只有一个方法，大多数回调接口都拥有这个特征：比如Runnable接口和Comparator接口。我们把这些只拥有一个方法的接口称为函数式接口。（之前它们被称为SAM类型，即单抽象方法类型（Single Abstract Method））\n\n我们并不需要额外的工作来声明一个接口是函数式接口：编译器会根据接口的结构自行判断（判断过程并非简单的对接口方法计数：一个接口可能冗余的定义了一个Object已经提供的方法，比如toString()，或者定义了静态方法或默认方法，这些都不属于函数式接口方法的范畴）。不过API作者们可以通过@FunctionalInterface注解来显式指定一个接口是函数式接口（以避免无意声明了一个符合函数式标准的接口），加上这个注解之后，编译器就会验证该接口是否满足函数式接口的要求。\n\n实现函数式类型的另一种方式是引入一个全新的结构化函数类型，我们也称其为“箭头”类型。例如，一个接收String和Object并返回int的函数类型可以被表示为(String, Object) -> int。我们仔细考虑了这个方式，但出于下面的原因，最终将其否定：\n\n它会为Java类型系统引入额外的复杂度，并带来结构类型（Structural Type）和指名类型（Nominal Type）的混用。（Java几乎全部使用指名类型）\n它会导致类库风格的分歧——一些类库会继续使用回调接口，而另一些类库会使用结构化函数类型\n它的语法会变得十分笨拙，尤其在包含受检异常（checked exception）之后\n每个函数类型很难拥有其运行时表示，这意味着开发者会受到类型擦除（erasure）的困扰和局限。比如说，我们无法对方法m(T->U)和m(X->Y)进行重载（Overload）\n所以我们选择了“使用已知类型”这条路——因为现有的类库大量使用了函数式接口，通过沿用这种模式，我们使得现有类库能够直接使用lambda表达式。例如下面是Java SE 7中已经存在的函数式接口：\n```\n\njava.lang.Runnable\njava.util.concurrent.Callable\njava.security.PrivilegedAction\njava.util.Comparator\njava.io.FileFilter\njava.beans.PropertyChangeListener\n```\n除此之外，Java SE 8中增加了一个新的包：java.util.function，它里面包含了常用的函数式接口，例如：\n\nPredicate<T>——接收T对象并返回boolean\nConsumer<T>——接收T对象，不返回值\nFunction<T, R>——接收T对象，返回R对象\nSupplier<T>——提供T对象（例如工厂），不接收值\nUnaryOperator<T>——接收T对象，返回T对象\nBinaryOperator<T>——接收两个T对象，返回T对象\n除了上面的这些基本的函数式接口，我们还提供了一些针对原始类型（Primitive type）的特化（Specialization）函数式接口，例如IntSupplier和LongBinaryOperator。（我们只为int、long和double提供了特化函数式接口，如果需要使用其它原始类型则需要进行类型转换）同样的我们也提供了一些针对多个参数的函数式接口，例如BiFunction<T, U, R>，它接收T对象和U对象，返回R对象。\n\n##lambda表达式\n\n匿名类型最大的问题就在于其冗余的语法。有人戏称匿名类型导致了“高度问题”（height problem）：比如前面ActionListener的例子里的五行代码中仅有一行在做实际工作。\n\nlambda表达式是匿名方法，它提供了轻量级的语法，从而解决了匿名内部类带来的“高度问题”。\n\n下面是一些lambda表达式：\n```\n\n(int x, int y) -> x + y\n() -> 42\n(String s) -> { System.out.println(s); }\n```\n第一个lambda表达式接收x和y这两个整形参数并返回它们的和；第二个lambda表达式不接收参数，返回整数'42'；第三个lambda表达式接收一个字符串并把它打印到控制台，不返回值。\n\nlambda表达式的语法由参数列表、箭头符号->和函数体组成。函数体既可以是一个表达式，也可以是一个语句块：\n\n表达式：表达式会被执行然后返回执行结果。\n语句块：语句块中的语句会被依次执行，就像方法中的语句一样——\nreturn语句会把控制权交给匿名方法的调用者\nbreak和continue只能在循环中使用\n如果函数体有返回值，那么函数体内部的每一条路径都必须返回值\n表达式函数体适合小型lambda表达式，它消除了return关键字，使得语法更加简洁。\n\nlambda表达式也会经常出现在嵌套环境中，比如说作为方法的参数。为了使lambda表达式在这些场景下尽可能简洁，我们去除了不必要的分隔符。不过在某些情况下我们也可以把它分为多行，然后用括号包起来，就像其它普通表达式一样。\n\n下面是一些出现在语句中的lambda表达式：\n\n```\nFileFilter java = (File f) -> f.getName().endsWith(\"*.java\");\n\nString user = doPrivileged(() -> System.getProperty(\"user.name\"));\n\nnew Thread(() -> {\n  connectToService();\n  sendNotification();\n}).start();\n```\n## 目标类型\n\n需要注意的是，函数式接口的名称并不是lambda表达式的一部分。那么问题来了，对于给定的lambda表达式，它的类型是什么？答案是：它的类型是由其上下文推导而来。例如，下面代码中的lambda表达式类型是ActionListener：\n\nActionListener l = (ActionEvent e) -> ui.dazzle(e.getModifiers());\n这就意味着同样的lambda表达式在不同上下文里可以拥有不同的类型：\n\nCallable<String> c = () -> \"done\";\n\nPrivilegedAction<String> a = () -> \"done\";\n第一个lambda表达式() -> \"done\"是Callable的实例，而第二个lambda表达式则是PrivilegedAction的实例。\n\n编译器负责推导lambda表达式的类型。它利用lambda表达式所在上下文所期待的类型进行推导，这个被期待的类型被称为目标类型。lambda表达式只能出现在目标类型为函数式接口的上下文中。\n\n当然，lambda表达式对目标类型也是有要求的。编译器会检查lambda表达式的类型和目标类型的方法签名（method signature）是否一致。当且仅当下面所有条件均满足时，lambda表达式才可以被赋给目标类型T：\n\nT是一个函数式接口\nlambda表达式的参数和T的方法参数在数量和类型上一一对应\nlambda表达式的返回值和T的方法返回值相兼容（Compatible）\nlambda表达式内所抛出的异常和T的方法throws类型相兼容\n由于目标类型（函数式接口）已经“知道”lambda表达式的形式参数（Formal parameter）类型，所以我们没有必要把已知类型再重复一遍。也就是说，lambda表达式的参数类型可以从目标类型中得出：\n\n```\nComparator<String> c = (s1, s2) -> s1.compareToIgnoreCase(s2);\n```\n在上面的例子里，编译器可以推导出s1和s2的类型是String。此外，当lambda的参数只有一个而且它的类型可以被推导得知时，该参数列表外面的括号可以被省略：\n\n```\nFileFilter java = f -> f.getName().endsWith(\".java\");\n```\n\n```\nbutton.addActionListener(e -> ui.dazzle(e.getModifiers()));\n```\n这些改进进一步展示了我们的设计目标：“不要把高度问题转化成宽度问题。”我们希望语法元素能够尽可能的少，以便代码的读者能够直达lambda表达式的核心部分。\n\nlambda表达式并不是第一个拥有上下文相关类型的Java表达式：泛型方法调用和“菱形”构造器调用也通过目标类型来进行类型推导：\n```\n\nList<String> ls = Collections.emptyList();\nList<Integer> li = Collections.emptyList();\n\nMap<String, Integer> m1 = new HashMap<>();\nMap<Integer, String> m2 = new HashMap<>();\n```\n5. 目标类型的上下文（Contexts for target typing）\n\n之前我们提到lambda表达式智能出现在拥有目标类型的上下文中。下面给出了这些带有目标类型的上下文：\n\n变量声明\n赋值\n返回语句\n数组初始化器\n方法和构造方法的参数\nlambda表达式函数体\n条件表达式（? :）\n转型（Cast）表达式\n在前三个上下文（变量声明、赋值和返回语句）里，目标类型即是被赋值或被返回的类型：\n\n```\nComparator<String> c;\nc = (String s1, String s2) -> s1.compareToIgnoreCase(s2);\n\npublic Runnable toDoLater() {\n  return () -> {\n    System.out.println(\"later\");\n  }\n}\n```\n数组初始化器和赋值类似，只是这里的“变量”变成了数组元素，而类型是从数组类型中推导得知：\n```\n\nfilterFiles(new FileFilter[] {\n              f -> f.exists(), f -> f.canRead(), f -> f.getName().startsWith(\"q\")\n            });\n```\n方法参数的类型推导要相对复杂些：目标类型的确认会涉及到其它两个语言特性：重载解析（Overload resolution）和参数类型推导（Type argument inference）。\n\n重载解析会为一个给定的方法调用（method invocation）寻找最合适的方法声明（method declaration）。由于不同的声明具有不同的签名，当lambda表达式作为方法参数时，重载解析就会影响到lambda表达式的目标类型。编译器会通过它所得之的信息来做出决定。如果lambda表达式具有显式类型（参数类型被显式指定），编译器就可以直接 使用lambda表达式的返回类型；如果lambda表达式具有隐式类型（参数类型被推导而知），重载解析则会忽略lambda表达式函数体而只依赖lambda表达式参数的数量。\n\n如果在解析方法声明时存在二义性（ambiguous），我们就需要利用转型（cast）或显式lambda表达式来提供更多的类型信息。如果lambda表达式的返回类型依赖于其参数的类型，那么lambda表达式函数体有可能可以给编译器提供额外的信息，以便其推导参数类型。\n```\n\nList<Person> ps = ...\nStream<String> names = ps.stream().map(p -> p.getName());\n```\n在上面的代码中，ps的类型是List<Person>，所以ps.stream()的返回类型是Stream<Person>。map()方法接收一个类型为Function<T, R>的函数式接口，这里T的类型即是Stream元素的类型，也就是Person，而R的类型未知。由于在重载解析之后lambda表达式的目标类型仍然未知，我们就需要推导R的类型：通过对lambda表达式函数体进行类型检查，我们发现函数体返回String，因此R的类型是String，因而map()返回Stream<String>。绝大多数情况下编译器都能解析出正确的类型，但如果碰到无法解析的情况，我们则需要：\n\n使用显式lambda表达式（为参数p提供显式类型）以提供额外的类型信息\n把lambda表达式转型为Function<Person, String>\n为泛型参数R提供一个实际类型。（.<String>map(p -> p.getName())）\nlambda表达式本身也可以为它自己的函数体提供目标类型，也就是说lambda表达式可以通过外部目标类型推导出其内部的返回类型，这意味着我们可以方便的编写一个返回函数的函数：\n\n```\nSupplier<Runnable> c = () -> () -> { System.out.println(\"hi\"); };\n```\n类似的，条件表达式可以把目标类型“分发”给其子表达式：\n\n```\nCallable<Integer> c = flag ? (() -> 23) : (() -> 42);\n```\n最后，转型表达式（Cast expression）可以显式提供lambda表达式的类型，这个特性在无法确认目标类型时非常有用：\n\n```\n// Object o = () -> { System.out.println(\"hi\"); }; 这段代码是非法的\nObject o = (Runnable) () -> { System.out.println(\"hi\"); };\n```\n除此之外，当重载的方法都拥有函数式接口时，转型可以帮助解决重载解析时出现的二义性。\n\n目标类型这个概念不仅仅适用于lambda表达式，泛型方法调用和“菱形”构造方法调用也可以从目标类型中受益，下面的代码在Java SE 7是非法的，但在Java SE 8中是合法的：\n\n```\nList<String> ls = Collections.checkedList(new ArrayList<>(), String.class);\n\nSet<Integer> si = flag ? Collections.singleton(23) : Collections.emptySet();\n```\n## 词法作用域\n\n在内部类中使用变量名（以及this）非常容易出错。内部类中通过继承得到的成员（包括来自Object的方法）可能会把外部类的成员掩盖（shadow），此外未限定（unqualified）的this引用会指向内部类自己而非外部类。\n\n相对于内部类，lambda表达式的语义就十分简单：它不会从超类（supertype）中继承任何变量名，也不会引入一个新的作用域。lambda表达式基于词法作用域，也就是说lambda表达式函数体里面的变量和它外部环境的变量具有相同的语义（也包括lambda表达式的形式参数）。此外，'this'关键字及其引用在lambda表达式内部和外部也拥有相同的语义。\n\n为了进一步说明词法作用域的优点，请参考下面的代码，它会把\"Hello, world!\"打印两遍：\n\n```\npublic class Hello {\n  Runnable r1 = () -> { System.out.println(this); }\n  Runnable r2 = () -> { System.out.println(toString()); }\n\n  public String toString() {  return \"Hello, world\"; }\n\n  public static void main(String... args) {\n    new Hello().r1.run();\n    new Hello().r2.run();\n  }\n}\n```\n与之相类似的内部类实现则会打印出类似Hello$1@5b89a773和Hello$2@537a7706之类的字符串，这往往会使开发者大吃一惊。\n\n基于词法作用域的理念，lambda表达式不可以掩盖任何其所在上下文中的局部变量，它的行为和那些拥有参数的控制流结构（例如for循环和catch从句）一致。\n\n个人补充：这个说法很拗口，所以我在这里加一个例子以演示词法作用域：\n\n```\nint i = 0;\nint sum = 0;\nfor (int i = 1; i < 10; i += 1) { //这里会出现编译错误，因为i已经在for循环外部声明过了\n  sum += i;\n}\n```\n## 变量捕获\n\n在Java SE 7中，编译器对内部类中引用的外部变量（即捕获的变量）要求非常严格：如果捕获的变量没有被声明为final就会产生一个编译错误。我们现在放宽了这个限制——对于lambda表达式和内部类，我们允许在其中捕获那些符合有效只读（Effectively final）的局部变量。\n\n简单的说，如果一个局部变量在初始化后从未被修改过，那么它就符合有效只读的要求，换句话说，加上final后也不会导致编译错误的局部变量就是有效只读变量。\n\n```\nCallable<String> helloCallable(String name) {\n  String hello = \"Hello\";\n  return () -> (hello + \", \" + name);\n}\n```\n对this的引用，以及通过this对未限定字段的引用和未限定方法的调用在本质上都属于使用final局部变量。包含此类引用的lambda表达式相当于捕获了this实例。在其它情况下，lambda对象不会保留任何对this的引用。\n\n这个特性对内存管理是一件好事：内部类实例会一直保留一个对其外部类实例的强引用，而那些没有捕获外部类成员的lambda表达式则不会保留对外部类实例的引用。要知道内部类的这个特性往往会造成内存泄露。\n\n尽管我们放宽了对捕获变量的语法限制，但试图修改捕获变量的行为仍然会被禁止，比如下面这个例子就是非法的：\n\n```\nint sum = 0;\nlist.forEach(e -> { sum += e.size(); });\n```\n为什么要禁止这种行为呢？因为这样的lambda表达式很容易引起race condition。除非我们能够强制（最好是在编译时）这样的函数不能离开其当前线程，但如果这么做了可能会导致更多的问题。简而言之，lambda表达式对值封闭，对变量开放。\n\n个人补充：lambda表达式对值封闭，对变量开放的原文是：lambda expressions close over values, not variables，我在这里增加一个例子以说明这个特性：\n\n```\nint sum = 0;\nlist.forEach(e -> { sum += e.size(); }); // Illegal, close over values\n\nList<Integer> aList = new List<>();\nlist.forEach(e -> { aList.add(e); }); // Legal, open over variables\n```\nlambda表达式不支持修改捕获变量的另一个原因是我们可以使用更好的方式来实现同样的效果：使用规约（reduction）。java.util.stream包提供了各种通用的和专用的规约操作（例如sum、min和max），就上面的例子而言，我们可以使用规约操作（在串行和并行下都是安全的）来代替forEach：\n\n```\nint sum = list.stream()\n              .mapToInt(e -> e.size())\n              .sum();\n```\nsum()等价于下面的规约操作：\n\n```\nint sum = list.stream()\n              .mapToInt(e -> e.size())\n              .reduce(0 , (x, y) -> x + y);\n```\n规约需要一个初始值（以防输入为空）和一个操作符（在这里是加号），然后用下面的表达式计算结果：\n\n```\n0 + list[0] + list[1] + list[2] + ...\n```\n规约也可以完成其它操作，比如求最小值、最大值和乘积等等。如果操作符具有可结合性（associative），那么规约操作就可以容易的被并行化。所以，与其支持一个本质上是并行而且容易导致race condition的操作，我们选择在库中提供一个更加并行友好且不容易出错的方式来进行累积（accumulation）。\n\n##方法引用\n\nlambda表达式允许我们定义一个匿名方法，并允许我们以函数式接口的方式使用它。我们也希望能够在已有的方法上实现同样的特性。\n\n方法引用和lambda表达式拥有相同的特性（例如，它们都需要一个目标类型，并需要被转化为函数式接口的实例），不过我们并不需要为方法引用提供方法体，我们可以直接通过方法名称引用已有方法。\n\n以下面的代码为例，假设我们要按照name或age为Person数组进行排序：\n\n```\nclass Person {\n  private final String name;\n  private final int age;\n\n  public int getAge() { return age; }\n  public String getName() {return name; }\n  ...\n}\n\nPerson[] people = ...\nComparator<Person> byName = Comparator.comparing(p -> p.getName());\nArrays.sort(people, byName);\n```\n在这里我们可以用方法引用代替lambda表达式：\n\n```\nComparator<Person> byName = Comparator.comparing(Person::getName);\n```\n这里的Person::getName可以被看作为lambda表达式的简写形式。尽管方法引用不一定（比如在这个例子里）会把语法变的更紧凑，但它拥有更明确的语义——如果我们想要调用的方法拥有一个名字，我们就可以通过它的名字直接调用它。\n\n因为函数式接口的方法参数对应于隐式方法调用时的参数，所以被引用方法签名可以通过放宽类型，装箱以及组织到参数数组中的方式对其参数进行操作，就像在调用实际方法一样：\n\n```\nConsumer<Integer> b1 = System::exit;    // void exit(int status)\nConsumer<String[]> b2 = Arrays:sort;    // void sort(Object[] a)\nConsumer<String> b3 = MyProgram::main;  // void main(String... args)\nRunnable r = Myprogram::mapToInt        // void main(String... args)\n```\n## 方法引用的种类\n\n方法引用有很多种，它们的语法如下：\n\n静态方法引用：ClassName::methodName\n实例上的实例方法引用：instanceReference::methodName\n超类上的实例方法引用：super::methodName\n类型上的实例方法引用：ClassName::methodName\n构造方法引用：Class::new\n数组构造方法引用：TypeName[]::new\n对于静态方法引用，我们需要在类名和方法名之间加入::分隔符，例如Integer::sum。\n\n对于具体对象上的实例方法引用，我们则需要在对象名和方法名之间加入分隔符：\n\n```\nSet<String> knownNames = ...\nPredicate<String> isKnown = knownNames::contains;\n```\n这里的隐式lambda表达式（也就是实例方法引用）会从knownNames中捕获String对象，而它的方法体则会通过Set.contains使用该String对象。\n\n有了实例方法引用，在不同函数式接口之间进行类型转换就变的很方便：\n\n```\nCallable<Path> c = ...\nPrivileged<Path> a = c::call;\n```\n引用任意对象的实例方法则需要在实例方法名称和其所属类型名称间加上分隔符：\n\n```\nFunction<String, String> upperfier = String::toUpperCase;\n```\n这里的隐式lambda表达式（即String::toUpperCase实例方法引用）有一个String参数，这个参数会被toUpperCase方法使用。\n\n如果类型的实例方法是泛型的，那么我们就需要在::分隔符前提供类型参数，或者（多数情况下）利用目标类型推导出其类型。\n\n需要注意的是，静态方法引用和类型上的实例方法引用拥有一样的语法。编译器会根据实际情况做出决定。\n\n一般我们不需要指定方法引用中的参数类型，因为编译器往往可以推导出结果，但如果需要我们也可以显式在::分隔符之前提供参数类型信息。\n\n和静态方法引用类似，构造方法也可以通过new关键字被直接引用：\n\n```\nSocketImplFactory factory = MySocketImpl::new;\n```\n如果类型拥有多个构造方法，那么我们就会通过目标类型的方法参数来选择最佳匹配，这里的选择过程和调用构造方法时的选择过程是一样的。\n\n如果待实例化的类型是泛型的，那么我们可以在类型名称之后提供类型参数，否则编译器则会依照\"菱形\"构造方法调用时的方式进行推导。\n\n数组的构造方法引用的语法则比较特殊，为了便于理解，你可以假想存在一个接收int参数的数组构造方法。参考下面的代码：\n```\n\nIntFunction<int[]> arrayMaker = int[]::new;\nint[] array = arrayMaker.apply(10) // 创建数组 int[10]\n```\n## 默认方法和静态接口方法\n\nlambda表达式和方法引用大大提升了Java的表达能力（expressiveness），不过为了使把代码即数据（code-as-data）变的更加容易，我们需要把这些特性融入到已有的库之中，以便开发者使用。\n\nJava SE 7时代为一个已有的类库增加功能是非常困难的。具体的说，接口在发布之后就已经被定型，除非我们能够一次性更新所有该接口的实现，否则向接口添加方法就会破坏现有的接口实现。默认方法（之前被称为虚拟扩展方法或守护方法）的目标即是解决这个问题，使得接口在发布之后仍能被逐步演化。\n\n这里给出一个例子，我们需要在标准集合API中增加针对lambda的方法。例如removeAll方法应该被泛化为接收一个函数式接口Predicate，但这个新的方法应该被放在哪里呢？我们无法直接在Collection接口上新增方法——不然就会破坏现有的Collection实现。我们倒是可以在Collections工具类中增加对应的静态方法，但这样就会把这个方法置于“二等公民”的境地。\n\n默认方法利用面向对象的方式向接口增加新的行为。它是一种新的方法：接口方法可以是抽象的或是默认的。默认方法拥有其默认实现，实现接口的类型通过继承得到该默认实现（如果类型没有覆盖该默认实现）。此外，默认方法不是抽象方法，所以我们可以放心的向函数式接口里增加默认方法，而不用担心函数式接口的单抽象方法限制。\n\n下面的例子展示了如何向Iterator接口增加默认方法skip：\n\n```\ninterface Iterator<E> {\n  boolean hasNext();\n  E next();\n  void remove();\n\n  default void skip(int i) {\n    for ( ; i > 0 && hasNext(); i -= 1) next();\n  }\n}\n```\n根据上面的Iterator定义，所有实现Iterator的类型都会自动继承skip方法。在使用者的眼里，skip不过是接口新增的一个虚拟方法。在没有覆盖skip方法的Iterator子类实例上调用skip会执行skip的默认实现：调用hasNext和next若干次。子类可以通过覆盖skip来提供更好的实现——比如直接移动游标（cursor），或是提供为操作提供原子性（Atomicity）等。\n\n当接口继承其它接口时，我们既可以为它所继承而来的抽象方法提供一个默认实现，也可以为它继承而来的默认方法提供一个新的实现，还可以把它继承而来的默认方法重新抽象化。\n\n除了默认方法，Java SE 8还在允许在接口中定义静态方法。这使得我们可以从接口直接调用和它相关的辅助方法（Helper method），而不是从其它的类中调用（之前这样的类往往以对应接口的复数命名，例如Collections）。比如，我们一般需要使用静态辅助方法生成实现Comparator的比较器，在Java SE 8中我们可以直接把该静态方法定义在Comparator接口中：\n\n```\npublic static <T, U extends Comparable<? super U>>\n    Comparator<T> comparing(Function<T, U> keyExtractor) {\n  return (c1, c2) -> keyExtractor.apply(c1).compareTo(keyExtractor.apply(c2));\n}\n```\n## 继承默认方法\n\n和其它方法一样，默认方法也可以被继承，大多数情况下这种继承行为和我们所期待的一致。不过，当类型或者接口的超类拥有多个具有相同签名的方法时，我们就需要一套规则来解决这个冲突：\n\n类的方法（class method）声明优先于接口默认方法。无论该方法是具体的还是抽象的。\n被其它类型所覆盖的方法会被忽略。这条规则适用于超类型共享一个公共祖先的情况。\n为了演示第二条规则，我们假设Collection和List接口均提供了removeAll的默认实现，然后Queue继承并覆盖了Collection中的默认方法。在下面的implement从句中，List中的方法声明会优先于Queue中的方法声明：\n\n```\nclass LinkedList<E> implements List<E>, Queue<E> { ... }\n```\n当两个独立的默认方法相冲突或是默认方法和抽象方法相冲突时会产生编译错误。这时程序员需要显式覆盖超类方法。一般来说我们会定义一个默认方法，然后在其中显式选择超类方法：\n\n```\ninterface Robot implements Artist, Gun {\n  default void draw() { Artist.super.draw(); }\n}\n```\nsuper前面的类型必须是有定义或继承默认方法的类型。这种方法调用并不只限于消除命名冲突——我们也可以在其它场景中使用它。\n\n最后，接口在inherits和extends从句中的声明顺序和它们被实现的顺序无关。\n\n## 融会贯通\n\n我们在设计lambda时的一个重要目标就是新增的语言特性和库特性能够无缝结合（designed to work together）。接下来，我们通过一个实际例子（按照姓对名字列表进行排序）来演示这一点：\n\n比如说下面的代码：\n\n```\nList<Person> people = ...\nCollections.sort(people, new Comparator<Person>() {\n  public int compare(Person x, Person y) {\n    return x.getLastName().compareTo(y.getLastName());\n  }\n})\n```\n冗余代码实在太多了！\n\n有了lambda表达式，我们可以去掉冗余的匿名类：\n\n```\nCollections.sort(people,\n                 (Person x, Person y) -> x.getLastName().compareTo(y.getLastName()));\n```\n尽管代码简洁了很多，但它的抽象程度依然很差：开发者仍然需要进行实际的比较操作（而且如果比较的值是原始类型那么情况会更糟），所以我们要借助Comparator里的comparing方法实现比较操作：\n\n```\nCollections.sort(people, Comparator.comparing((Person p) -> p.getLastName()));\n```\n在类型推导和静态导入的帮助下，我们可以进一步简化上面的代码：\n\n```\nCollections.sort(people, comparing(p -> p.getLastName()));\n```\n我们注意到这里的lambda表达式实际上是getLastName的代理（forwarder），于是我们可以用方法引用代替它：\n```\n\nCollections.sort(people, comparing(Person::getLastName));\n```\n最后，使用Collections.sort这样的辅助方法并不是一个好主意：它不但使代码变的冗余，也无法为实现List接口的数据结构提供特定（specialized）的高效实现，而且由于Collections.sort方法不属于List接口，用户在阅读List接口的文档时不会察觉在另外的Collections类中还有一个针对List接口的排序（sort()）方法。\n\n默认方法可以有效的解决这个问题，我们为List增加默认方法sort()，然后就可以这样调用：\n\n```\npeople.sort(comparing(Person::getLastName));;\n```\n此外，如果我们为Comparator接口增加一个默认方法reversed()（产生一个逆序比较器），我们就可以非常容易的在前面代码的基础上实现降序排序。\n\n```\npeople.sort(comparing(Person::getLastName).reversed());;\n```\n## 小结\n\nJava SE 8提供的新语言特性并不算多——lambda表达式，方法引用，默认方法和静态接口方法，以及范围更广的类型推导。但是把它们结合在一起之后，开发者可以编写出更加清晰简洁的代码，类库编写者可以编写更加强大易用的并行类库。\n","source":"_posts/Java8_lambda.md","raw":"---\ntitle: 深入理解Java 8 Lambda\ntags: Java\ncategories: Java\ntoc: true\ndate: 2016-10-18\n\n---\n\n## 关于\n\n本文介绍了Java SE 8中新引入的lambda语言特性以及这些特性背后的设计思想。这些特性包括：\n\nlambda表达式（又被成为“闭包”或“匿名方法”）\n方法引用和构造方法引用\n扩展的目标类型和类型推导\n接口中的默认方法和静态方法\n## 背景\n\nJava是一门面向对象编程语言。面向对象编程语言和函数式编程语言中的基本元素（Basic Values）都可以动态封装程序行为：面向对象编程语言使用带有方法的对象封装行为，函数式编程语言使用函数封装行为。但这个相同点并不明显，因为Java的对象往往比较“重量级”：实例化一个类型往往会涉及不同的类，并需要初始化类里的字段和方法。\n\n不过有些Java对象只是对单个函数的封装。例如下面这个典型用例：Java API中定义了一个接口（一般被称为回调接口），用户通过提供这个接口的实例来传入指定行为，例如：\n```\n\npublic interface ActionListener {\n  void actionPerformed(ActionEvent e);\n}\n这里并不需要专门定义一个类来实现ActionListener接口，因为它只会在调用处被使用一次。用户一般会使用匿名类型把行为内联（inline）：\n\nbutton.addActionListener(new ActionListener) {\n  public void actionPerformed(ActionEvent e) {\n    ui.dazzle(e.getModifiers());\n  }\n}\n```\n很多库都依赖于上面的模式。对于并行API更是如此，因为我们需要把待执行的代码提供给并行API，并行编程是一个非常值得研究的领域，因为在这里摩尔定律得到了重生：尽管我们没有更快的CPU核心（core），但是我们有更多的CPU核心。而串行API就只能使用有限的计算能力。\n\n随着回调模式和函数式编程风格的日益流行，我们需要在Java中提供一种尽可能轻量级的将代码封装为数据（Model code as data）的方法。匿名内部类并不是一个好的选择，因为：\n\n语法过于冗余\n匿名类中的this和变量名容易使人产生误解\n类型载入和实例创建语义不够灵活\n无法捕获非final的局部变量\n无法对控制流进行抽象\n上面的多数问题均在Java SE 8中得以解决：\n\n通过提供更简洁的语法和局部作用域规则，Java SE 8彻底解决了问题1和问题2\n通过提供更加灵活而且便于优化的表达式语义，Java SE 8绕开了问题3\n通过允许编译器推断变量的“常量性”（finality），Java SE 8减轻了问题4带来的困扰\n不过，Java SE 8的目标并非解决所有上述问题。因此捕获可变变量（问题4）和非局部控制流（问题5）并不在Java SE 8的范畴之内。（尽管我们可能会在未来提供对这些特性的支持）\n\n##函数式接口\n\n尽管匿名内部类有着种种限制和问题，但是它有一个良好的特性，它和Java类型系统结合的十分紧密：每一个函数对象都对应一个接口类型。之所以说这个特性是良好的，是因为：\n\n接口是Java类型系统的一部分\n接口天然就拥有其运行时表示（Runtime representation）\n接口可以通过Javadoc注释来表达一些非正式的协定（contract），例如，通过注释说明该操作应可交换（commutative）\n上面提到的ActionListener接口只有一个方法，大多数回调接口都拥有这个特征：比如Runnable接口和Comparator接口。我们把这些只拥有一个方法的接口称为函数式接口。（之前它们被称为SAM类型，即单抽象方法类型（Single Abstract Method））\n\n我们并不需要额外的工作来声明一个接口是函数式接口：编译器会根据接口的结构自行判断（判断过程并非简单的对接口方法计数：一个接口可能冗余的定义了一个Object已经提供的方法，比如toString()，或者定义了静态方法或默认方法，这些都不属于函数式接口方法的范畴）。不过API作者们可以通过@FunctionalInterface注解来显式指定一个接口是函数式接口（以避免无意声明了一个符合函数式标准的接口），加上这个注解之后，编译器就会验证该接口是否满足函数式接口的要求。\n\n实现函数式类型的另一种方式是引入一个全新的结构化函数类型，我们也称其为“箭头”类型。例如，一个接收String和Object并返回int的函数类型可以被表示为(String, Object) -> int。我们仔细考虑了这个方式，但出于下面的原因，最终将其否定：\n\n它会为Java类型系统引入额外的复杂度，并带来结构类型（Structural Type）和指名类型（Nominal Type）的混用。（Java几乎全部使用指名类型）\n它会导致类库风格的分歧——一些类库会继续使用回调接口，而另一些类库会使用结构化函数类型\n它的语法会变得十分笨拙，尤其在包含受检异常（checked exception）之后\n每个函数类型很难拥有其运行时表示，这意味着开发者会受到类型擦除（erasure）的困扰和局限。比如说，我们无法对方法m(T->U)和m(X->Y)进行重载（Overload）\n所以我们选择了“使用已知类型”这条路——因为现有的类库大量使用了函数式接口，通过沿用这种模式，我们使得现有类库能够直接使用lambda表达式。例如下面是Java SE 7中已经存在的函数式接口：\n```\n\njava.lang.Runnable\njava.util.concurrent.Callable\njava.security.PrivilegedAction\njava.util.Comparator\njava.io.FileFilter\njava.beans.PropertyChangeListener\n```\n除此之外，Java SE 8中增加了一个新的包：java.util.function，它里面包含了常用的函数式接口，例如：\n\nPredicate<T>——接收T对象并返回boolean\nConsumer<T>——接收T对象，不返回值\nFunction<T, R>——接收T对象，返回R对象\nSupplier<T>——提供T对象（例如工厂），不接收值\nUnaryOperator<T>——接收T对象，返回T对象\nBinaryOperator<T>——接收两个T对象，返回T对象\n除了上面的这些基本的函数式接口，我们还提供了一些针对原始类型（Primitive type）的特化（Specialization）函数式接口，例如IntSupplier和LongBinaryOperator。（我们只为int、long和double提供了特化函数式接口，如果需要使用其它原始类型则需要进行类型转换）同样的我们也提供了一些针对多个参数的函数式接口，例如BiFunction<T, U, R>，它接收T对象和U对象，返回R对象。\n\n##lambda表达式\n\n匿名类型最大的问题就在于其冗余的语法。有人戏称匿名类型导致了“高度问题”（height problem）：比如前面ActionListener的例子里的五行代码中仅有一行在做实际工作。\n\nlambda表达式是匿名方法，它提供了轻量级的语法，从而解决了匿名内部类带来的“高度问题”。\n\n下面是一些lambda表达式：\n```\n\n(int x, int y) -> x + y\n() -> 42\n(String s) -> { System.out.println(s); }\n```\n第一个lambda表达式接收x和y这两个整形参数并返回它们的和；第二个lambda表达式不接收参数，返回整数'42'；第三个lambda表达式接收一个字符串并把它打印到控制台，不返回值。\n\nlambda表达式的语法由参数列表、箭头符号->和函数体组成。函数体既可以是一个表达式，也可以是一个语句块：\n\n表达式：表达式会被执行然后返回执行结果。\n语句块：语句块中的语句会被依次执行，就像方法中的语句一样——\nreturn语句会把控制权交给匿名方法的调用者\nbreak和continue只能在循环中使用\n如果函数体有返回值，那么函数体内部的每一条路径都必须返回值\n表达式函数体适合小型lambda表达式，它消除了return关键字，使得语法更加简洁。\n\nlambda表达式也会经常出现在嵌套环境中，比如说作为方法的参数。为了使lambda表达式在这些场景下尽可能简洁，我们去除了不必要的分隔符。不过在某些情况下我们也可以把它分为多行，然后用括号包起来，就像其它普通表达式一样。\n\n下面是一些出现在语句中的lambda表达式：\n\n```\nFileFilter java = (File f) -> f.getName().endsWith(\"*.java\");\n\nString user = doPrivileged(() -> System.getProperty(\"user.name\"));\n\nnew Thread(() -> {\n  connectToService();\n  sendNotification();\n}).start();\n```\n## 目标类型\n\n需要注意的是，函数式接口的名称并不是lambda表达式的一部分。那么问题来了，对于给定的lambda表达式，它的类型是什么？答案是：它的类型是由其上下文推导而来。例如，下面代码中的lambda表达式类型是ActionListener：\n\nActionListener l = (ActionEvent e) -> ui.dazzle(e.getModifiers());\n这就意味着同样的lambda表达式在不同上下文里可以拥有不同的类型：\n\nCallable<String> c = () -> \"done\";\n\nPrivilegedAction<String> a = () -> \"done\";\n第一个lambda表达式() -> \"done\"是Callable的实例，而第二个lambda表达式则是PrivilegedAction的实例。\n\n编译器负责推导lambda表达式的类型。它利用lambda表达式所在上下文所期待的类型进行推导，这个被期待的类型被称为目标类型。lambda表达式只能出现在目标类型为函数式接口的上下文中。\n\n当然，lambda表达式对目标类型也是有要求的。编译器会检查lambda表达式的类型和目标类型的方法签名（method signature）是否一致。当且仅当下面所有条件均满足时，lambda表达式才可以被赋给目标类型T：\n\nT是一个函数式接口\nlambda表达式的参数和T的方法参数在数量和类型上一一对应\nlambda表达式的返回值和T的方法返回值相兼容（Compatible）\nlambda表达式内所抛出的异常和T的方法throws类型相兼容\n由于目标类型（函数式接口）已经“知道”lambda表达式的形式参数（Formal parameter）类型，所以我们没有必要把已知类型再重复一遍。也就是说，lambda表达式的参数类型可以从目标类型中得出：\n\n```\nComparator<String> c = (s1, s2) -> s1.compareToIgnoreCase(s2);\n```\n在上面的例子里，编译器可以推导出s1和s2的类型是String。此外，当lambda的参数只有一个而且它的类型可以被推导得知时，该参数列表外面的括号可以被省略：\n\n```\nFileFilter java = f -> f.getName().endsWith(\".java\");\n```\n\n```\nbutton.addActionListener(e -> ui.dazzle(e.getModifiers()));\n```\n这些改进进一步展示了我们的设计目标：“不要把高度问题转化成宽度问题。”我们希望语法元素能够尽可能的少，以便代码的读者能够直达lambda表达式的核心部分。\n\nlambda表达式并不是第一个拥有上下文相关类型的Java表达式：泛型方法调用和“菱形”构造器调用也通过目标类型来进行类型推导：\n```\n\nList<String> ls = Collections.emptyList();\nList<Integer> li = Collections.emptyList();\n\nMap<String, Integer> m1 = new HashMap<>();\nMap<Integer, String> m2 = new HashMap<>();\n```\n5. 目标类型的上下文（Contexts for target typing）\n\n之前我们提到lambda表达式智能出现在拥有目标类型的上下文中。下面给出了这些带有目标类型的上下文：\n\n变量声明\n赋值\n返回语句\n数组初始化器\n方法和构造方法的参数\nlambda表达式函数体\n条件表达式（? :）\n转型（Cast）表达式\n在前三个上下文（变量声明、赋值和返回语句）里，目标类型即是被赋值或被返回的类型：\n\n```\nComparator<String> c;\nc = (String s1, String s2) -> s1.compareToIgnoreCase(s2);\n\npublic Runnable toDoLater() {\n  return () -> {\n    System.out.println(\"later\");\n  }\n}\n```\n数组初始化器和赋值类似，只是这里的“变量”变成了数组元素，而类型是从数组类型中推导得知：\n```\n\nfilterFiles(new FileFilter[] {\n              f -> f.exists(), f -> f.canRead(), f -> f.getName().startsWith(\"q\")\n            });\n```\n方法参数的类型推导要相对复杂些：目标类型的确认会涉及到其它两个语言特性：重载解析（Overload resolution）和参数类型推导（Type argument inference）。\n\n重载解析会为一个给定的方法调用（method invocation）寻找最合适的方法声明（method declaration）。由于不同的声明具有不同的签名，当lambda表达式作为方法参数时，重载解析就会影响到lambda表达式的目标类型。编译器会通过它所得之的信息来做出决定。如果lambda表达式具有显式类型（参数类型被显式指定），编译器就可以直接 使用lambda表达式的返回类型；如果lambda表达式具有隐式类型（参数类型被推导而知），重载解析则会忽略lambda表达式函数体而只依赖lambda表达式参数的数量。\n\n如果在解析方法声明时存在二义性（ambiguous），我们就需要利用转型（cast）或显式lambda表达式来提供更多的类型信息。如果lambda表达式的返回类型依赖于其参数的类型，那么lambda表达式函数体有可能可以给编译器提供额外的信息，以便其推导参数类型。\n```\n\nList<Person> ps = ...\nStream<String> names = ps.stream().map(p -> p.getName());\n```\n在上面的代码中，ps的类型是List<Person>，所以ps.stream()的返回类型是Stream<Person>。map()方法接收一个类型为Function<T, R>的函数式接口，这里T的类型即是Stream元素的类型，也就是Person，而R的类型未知。由于在重载解析之后lambda表达式的目标类型仍然未知，我们就需要推导R的类型：通过对lambda表达式函数体进行类型检查，我们发现函数体返回String，因此R的类型是String，因而map()返回Stream<String>。绝大多数情况下编译器都能解析出正确的类型，但如果碰到无法解析的情况，我们则需要：\n\n使用显式lambda表达式（为参数p提供显式类型）以提供额外的类型信息\n把lambda表达式转型为Function<Person, String>\n为泛型参数R提供一个实际类型。（.<String>map(p -> p.getName())）\nlambda表达式本身也可以为它自己的函数体提供目标类型，也就是说lambda表达式可以通过外部目标类型推导出其内部的返回类型，这意味着我们可以方便的编写一个返回函数的函数：\n\n```\nSupplier<Runnable> c = () -> () -> { System.out.println(\"hi\"); };\n```\n类似的，条件表达式可以把目标类型“分发”给其子表达式：\n\n```\nCallable<Integer> c = flag ? (() -> 23) : (() -> 42);\n```\n最后，转型表达式（Cast expression）可以显式提供lambda表达式的类型，这个特性在无法确认目标类型时非常有用：\n\n```\n// Object o = () -> { System.out.println(\"hi\"); }; 这段代码是非法的\nObject o = (Runnable) () -> { System.out.println(\"hi\"); };\n```\n除此之外，当重载的方法都拥有函数式接口时，转型可以帮助解决重载解析时出现的二义性。\n\n目标类型这个概念不仅仅适用于lambda表达式，泛型方法调用和“菱形”构造方法调用也可以从目标类型中受益，下面的代码在Java SE 7是非法的，但在Java SE 8中是合法的：\n\n```\nList<String> ls = Collections.checkedList(new ArrayList<>(), String.class);\n\nSet<Integer> si = flag ? Collections.singleton(23) : Collections.emptySet();\n```\n## 词法作用域\n\n在内部类中使用变量名（以及this）非常容易出错。内部类中通过继承得到的成员（包括来自Object的方法）可能会把外部类的成员掩盖（shadow），此外未限定（unqualified）的this引用会指向内部类自己而非外部类。\n\n相对于内部类，lambda表达式的语义就十分简单：它不会从超类（supertype）中继承任何变量名，也不会引入一个新的作用域。lambda表达式基于词法作用域，也就是说lambda表达式函数体里面的变量和它外部环境的变量具有相同的语义（也包括lambda表达式的形式参数）。此外，'this'关键字及其引用在lambda表达式内部和外部也拥有相同的语义。\n\n为了进一步说明词法作用域的优点，请参考下面的代码，它会把\"Hello, world!\"打印两遍：\n\n```\npublic class Hello {\n  Runnable r1 = () -> { System.out.println(this); }\n  Runnable r2 = () -> { System.out.println(toString()); }\n\n  public String toString() {  return \"Hello, world\"; }\n\n  public static void main(String... args) {\n    new Hello().r1.run();\n    new Hello().r2.run();\n  }\n}\n```\n与之相类似的内部类实现则会打印出类似Hello$1@5b89a773和Hello$2@537a7706之类的字符串，这往往会使开发者大吃一惊。\n\n基于词法作用域的理念，lambda表达式不可以掩盖任何其所在上下文中的局部变量，它的行为和那些拥有参数的控制流结构（例如for循环和catch从句）一致。\n\n个人补充：这个说法很拗口，所以我在这里加一个例子以演示词法作用域：\n\n```\nint i = 0;\nint sum = 0;\nfor (int i = 1; i < 10; i += 1) { //这里会出现编译错误，因为i已经在for循环外部声明过了\n  sum += i;\n}\n```\n## 变量捕获\n\n在Java SE 7中，编译器对内部类中引用的外部变量（即捕获的变量）要求非常严格：如果捕获的变量没有被声明为final就会产生一个编译错误。我们现在放宽了这个限制——对于lambda表达式和内部类，我们允许在其中捕获那些符合有效只读（Effectively final）的局部变量。\n\n简单的说，如果一个局部变量在初始化后从未被修改过，那么它就符合有效只读的要求，换句话说，加上final后也不会导致编译错误的局部变量就是有效只读变量。\n\n```\nCallable<String> helloCallable(String name) {\n  String hello = \"Hello\";\n  return () -> (hello + \", \" + name);\n}\n```\n对this的引用，以及通过this对未限定字段的引用和未限定方法的调用在本质上都属于使用final局部变量。包含此类引用的lambda表达式相当于捕获了this实例。在其它情况下，lambda对象不会保留任何对this的引用。\n\n这个特性对内存管理是一件好事：内部类实例会一直保留一个对其外部类实例的强引用，而那些没有捕获外部类成员的lambda表达式则不会保留对外部类实例的引用。要知道内部类的这个特性往往会造成内存泄露。\n\n尽管我们放宽了对捕获变量的语法限制，但试图修改捕获变量的行为仍然会被禁止，比如下面这个例子就是非法的：\n\n```\nint sum = 0;\nlist.forEach(e -> { sum += e.size(); });\n```\n为什么要禁止这种行为呢？因为这样的lambda表达式很容易引起race condition。除非我们能够强制（最好是在编译时）这样的函数不能离开其当前线程，但如果这么做了可能会导致更多的问题。简而言之，lambda表达式对值封闭，对变量开放。\n\n个人补充：lambda表达式对值封闭，对变量开放的原文是：lambda expressions close over values, not variables，我在这里增加一个例子以说明这个特性：\n\n```\nint sum = 0;\nlist.forEach(e -> { sum += e.size(); }); // Illegal, close over values\n\nList<Integer> aList = new List<>();\nlist.forEach(e -> { aList.add(e); }); // Legal, open over variables\n```\nlambda表达式不支持修改捕获变量的另一个原因是我们可以使用更好的方式来实现同样的效果：使用规约（reduction）。java.util.stream包提供了各种通用的和专用的规约操作（例如sum、min和max），就上面的例子而言，我们可以使用规约操作（在串行和并行下都是安全的）来代替forEach：\n\n```\nint sum = list.stream()\n              .mapToInt(e -> e.size())\n              .sum();\n```\nsum()等价于下面的规约操作：\n\n```\nint sum = list.stream()\n              .mapToInt(e -> e.size())\n              .reduce(0 , (x, y) -> x + y);\n```\n规约需要一个初始值（以防输入为空）和一个操作符（在这里是加号），然后用下面的表达式计算结果：\n\n```\n0 + list[0] + list[1] + list[2] + ...\n```\n规约也可以完成其它操作，比如求最小值、最大值和乘积等等。如果操作符具有可结合性（associative），那么规约操作就可以容易的被并行化。所以，与其支持一个本质上是并行而且容易导致race condition的操作，我们选择在库中提供一个更加并行友好且不容易出错的方式来进行累积（accumulation）。\n\n##方法引用\n\nlambda表达式允许我们定义一个匿名方法，并允许我们以函数式接口的方式使用它。我们也希望能够在已有的方法上实现同样的特性。\n\n方法引用和lambda表达式拥有相同的特性（例如，它们都需要一个目标类型，并需要被转化为函数式接口的实例），不过我们并不需要为方法引用提供方法体，我们可以直接通过方法名称引用已有方法。\n\n以下面的代码为例，假设我们要按照name或age为Person数组进行排序：\n\n```\nclass Person {\n  private final String name;\n  private final int age;\n\n  public int getAge() { return age; }\n  public String getName() {return name; }\n  ...\n}\n\nPerson[] people = ...\nComparator<Person> byName = Comparator.comparing(p -> p.getName());\nArrays.sort(people, byName);\n```\n在这里我们可以用方法引用代替lambda表达式：\n\n```\nComparator<Person> byName = Comparator.comparing(Person::getName);\n```\n这里的Person::getName可以被看作为lambda表达式的简写形式。尽管方法引用不一定（比如在这个例子里）会把语法变的更紧凑，但它拥有更明确的语义——如果我们想要调用的方法拥有一个名字，我们就可以通过它的名字直接调用它。\n\n因为函数式接口的方法参数对应于隐式方法调用时的参数，所以被引用方法签名可以通过放宽类型，装箱以及组织到参数数组中的方式对其参数进行操作，就像在调用实际方法一样：\n\n```\nConsumer<Integer> b1 = System::exit;    // void exit(int status)\nConsumer<String[]> b2 = Arrays:sort;    // void sort(Object[] a)\nConsumer<String> b3 = MyProgram::main;  // void main(String... args)\nRunnable r = Myprogram::mapToInt        // void main(String... args)\n```\n## 方法引用的种类\n\n方法引用有很多种，它们的语法如下：\n\n静态方法引用：ClassName::methodName\n实例上的实例方法引用：instanceReference::methodName\n超类上的实例方法引用：super::methodName\n类型上的实例方法引用：ClassName::methodName\n构造方法引用：Class::new\n数组构造方法引用：TypeName[]::new\n对于静态方法引用，我们需要在类名和方法名之间加入::分隔符，例如Integer::sum。\n\n对于具体对象上的实例方法引用，我们则需要在对象名和方法名之间加入分隔符：\n\n```\nSet<String> knownNames = ...\nPredicate<String> isKnown = knownNames::contains;\n```\n这里的隐式lambda表达式（也就是实例方法引用）会从knownNames中捕获String对象，而它的方法体则会通过Set.contains使用该String对象。\n\n有了实例方法引用，在不同函数式接口之间进行类型转换就变的很方便：\n\n```\nCallable<Path> c = ...\nPrivileged<Path> a = c::call;\n```\n引用任意对象的实例方法则需要在实例方法名称和其所属类型名称间加上分隔符：\n\n```\nFunction<String, String> upperfier = String::toUpperCase;\n```\n这里的隐式lambda表达式（即String::toUpperCase实例方法引用）有一个String参数，这个参数会被toUpperCase方法使用。\n\n如果类型的实例方法是泛型的，那么我们就需要在::分隔符前提供类型参数，或者（多数情况下）利用目标类型推导出其类型。\n\n需要注意的是，静态方法引用和类型上的实例方法引用拥有一样的语法。编译器会根据实际情况做出决定。\n\n一般我们不需要指定方法引用中的参数类型，因为编译器往往可以推导出结果，但如果需要我们也可以显式在::分隔符之前提供参数类型信息。\n\n和静态方法引用类似，构造方法也可以通过new关键字被直接引用：\n\n```\nSocketImplFactory factory = MySocketImpl::new;\n```\n如果类型拥有多个构造方法，那么我们就会通过目标类型的方法参数来选择最佳匹配，这里的选择过程和调用构造方法时的选择过程是一样的。\n\n如果待实例化的类型是泛型的，那么我们可以在类型名称之后提供类型参数，否则编译器则会依照\"菱形\"构造方法调用时的方式进行推导。\n\n数组的构造方法引用的语法则比较特殊，为了便于理解，你可以假想存在一个接收int参数的数组构造方法。参考下面的代码：\n```\n\nIntFunction<int[]> arrayMaker = int[]::new;\nint[] array = arrayMaker.apply(10) // 创建数组 int[10]\n```\n## 默认方法和静态接口方法\n\nlambda表达式和方法引用大大提升了Java的表达能力（expressiveness），不过为了使把代码即数据（code-as-data）变的更加容易，我们需要把这些特性融入到已有的库之中，以便开发者使用。\n\nJava SE 7时代为一个已有的类库增加功能是非常困难的。具体的说，接口在发布之后就已经被定型，除非我们能够一次性更新所有该接口的实现，否则向接口添加方法就会破坏现有的接口实现。默认方法（之前被称为虚拟扩展方法或守护方法）的目标即是解决这个问题，使得接口在发布之后仍能被逐步演化。\n\n这里给出一个例子，我们需要在标准集合API中增加针对lambda的方法。例如removeAll方法应该被泛化为接收一个函数式接口Predicate，但这个新的方法应该被放在哪里呢？我们无法直接在Collection接口上新增方法——不然就会破坏现有的Collection实现。我们倒是可以在Collections工具类中增加对应的静态方法，但这样就会把这个方法置于“二等公民”的境地。\n\n默认方法利用面向对象的方式向接口增加新的行为。它是一种新的方法：接口方法可以是抽象的或是默认的。默认方法拥有其默认实现，实现接口的类型通过继承得到该默认实现（如果类型没有覆盖该默认实现）。此外，默认方法不是抽象方法，所以我们可以放心的向函数式接口里增加默认方法，而不用担心函数式接口的单抽象方法限制。\n\n下面的例子展示了如何向Iterator接口增加默认方法skip：\n\n```\ninterface Iterator<E> {\n  boolean hasNext();\n  E next();\n  void remove();\n\n  default void skip(int i) {\n    for ( ; i > 0 && hasNext(); i -= 1) next();\n  }\n}\n```\n根据上面的Iterator定义，所有实现Iterator的类型都会自动继承skip方法。在使用者的眼里，skip不过是接口新增的一个虚拟方法。在没有覆盖skip方法的Iterator子类实例上调用skip会执行skip的默认实现：调用hasNext和next若干次。子类可以通过覆盖skip来提供更好的实现——比如直接移动游标（cursor），或是提供为操作提供原子性（Atomicity）等。\n\n当接口继承其它接口时，我们既可以为它所继承而来的抽象方法提供一个默认实现，也可以为它继承而来的默认方法提供一个新的实现，还可以把它继承而来的默认方法重新抽象化。\n\n除了默认方法，Java SE 8还在允许在接口中定义静态方法。这使得我们可以从接口直接调用和它相关的辅助方法（Helper method），而不是从其它的类中调用（之前这样的类往往以对应接口的复数命名，例如Collections）。比如，我们一般需要使用静态辅助方法生成实现Comparator的比较器，在Java SE 8中我们可以直接把该静态方法定义在Comparator接口中：\n\n```\npublic static <T, U extends Comparable<? super U>>\n    Comparator<T> comparing(Function<T, U> keyExtractor) {\n  return (c1, c2) -> keyExtractor.apply(c1).compareTo(keyExtractor.apply(c2));\n}\n```\n## 继承默认方法\n\n和其它方法一样，默认方法也可以被继承，大多数情况下这种继承行为和我们所期待的一致。不过，当类型或者接口的超类拥有多个具有相同签名的方法时，我们就需要一套规则来解决这个冲突：\n\n类的方法（class method）声明优先于接口默认方法。无论该方法是具体的还是抽象的。\n被其它类型所覆盖的方法会被忽略。这条规则适用于超类型共享一个公共祖先的情况。\n为了演示第二条规则，我们假设Collection和List接口均提供了removeAll的默认实现，然后Queue继承并覆盖了Collection中的默认方法。在下面的implement从句中，List中的方法声明会优先于Queue中的方法声明：\n\n```\nclass LinkedList<E> implements List<E>, Queue<E> { ... }\n```\n当两个独立的默认方法相冲突或是默认方法和抽象方法相冲突时会产生编译错误。这时程序员需要显式覆盖超类方法。一般来说我们会定义一个默认方法，然后在其中显式选择超类方法：\n\n```\ninterface Robot implements Artist, Gun {\n  default void draw() { Artist.super.draw(); }\n}\n```\nsuper前面的类型必须是有定义或继承默认方法的类型。这种方法调用并不只限于消除命名冲突——我们也可以在其它场景中使用它。\n\n最后，接口在inherits和extends从句中的声明顺序和它们被实现的顺序无关。\n\n## 融会贯通\n\n我们在设计lambda时的一个重要目标就是新增的语言特性和库特性能够无缝结合（designed to work together）。接下来，我们通过一个实际例子（按照姓对名字列表进行排序）来演示这一点：\n\n比如说下面的代码：\n\n```\nList<Person> people = ...\nCollections.sort(people, new Comparator<Person>() {\n  public int compare(Person x, Person y) {\n    return x.getLastName().compareTo(y.getLastName());\n  }\n})\n```\n冗余代码实在太多了！\n\n有了lambda表达式，我们可以去掉冗余的匿名类：\n\n```\nCollections.sort(people,\n                 (Person x, Person y) -> x.getLastName().compareTo(y.getLastName()));\n```\n尽管代码简洁了很多，但它的抽象程度依然很差：开发者仍然需要进行实际的比较操作（而且如果比较的值是原始类型那么情况会更糟），所以我们要借助Comparator里的comparing方法实现比较操作：\n\n```\nCollections.sort(people, Comparator.comparing((Person p) -> p.getLastName()));\n```\n在类型推导和静态导入的帮助下，我们可以进一步简化上面的代码：\n\n```\nCollections.sort(people, comparing(p -> p.getLastName()));\n```\n我们注意到这里的lambda表达式实际上是getLastName的代理（forwarder），于是我们可以用方法引用代替它：\n```\n\nCollections.sort(people, comparing(Person::getLastName));\n```\n最后，使用Collections.sort这样的辅助方法并不是一个好主意：它不但使代码变的冗余，也无法为实现List接口的数据结构提供特定（specialized）的高效实现，而且由于Collections.sort方法不属于List接口，用户在阅读List接口的文档时不会察觉在另外的Collections类中还有一个针对List接口的排序（sort()）方法。\n\n默认方法可以有效的解决这个问题，我们为List增加默认方法sort()，然后就可以这样调用：\n\n```\npeople.sort(comparing(Person::getLastName));;\n```\n此外，如果我们为Comparator接口增加一个默认方法reversed()（产生一个逆序比较器），我们就可以非常容易的在前面代码的基础上实现降序排序。\n\n```\npeople.sort(comparing(Person::getLastName).reversed());;\n```\n## 小结\n\nJava SE 8提供的新语言特性并不算多——lambda表达式，方法引用，默认方法和静态接口方法，以及范围更广的类型推导。但是把它们结合在一起之后，开发者可以编写出更加清晰简洁的代码，类库编写者可以编写更加强大易用的并行类库。\n","slug":"Java8_lambda","published":1,"updated":"2016-12-05T13:11:03.073Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwc527390001o8l04mus8v0q","content":"<h2 id=\"关于\"><a href=\"#关于\" class=\"headerlink\" title=\"关于\"></a>关于</h2><p>本文介绍了Java SE 8中新引入的lambda语言特性以及这些特性背后的设计思想。这些特性包括：</p>\n<p>lambda表达式（又被成为“闭包”或“匿名方法”）<br>方法引用和构造方法引用<br>扩展的目标类型和类型推导<br>接口中的默认方法和静态方法</p>\n<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>Java是一门面向对象编程语言。面向对象编程语言和函数式编程语言中的基本元素（Basic Values）都可以动态封装程序行为：面向对象编程语言使用带有方法的对象封装行为，函数式编程语言使用函数封装行为。但这个相同点并不明显，因为Java的对象往往比较“重量级”：实例化一个类型往往会涉及不同的类，并需要初始化类里的字段和方法。</p>\n<p>不过有些Java对象只是对单个函数的封装。例如下面这个典型用例：Java API中定义了一个接口（一般被称为回调接口），用户通过提供这个接口的实例来传入指定行为，例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">public interface ActionListener &#123;</div><div class=\"line\">  void actionPerformed(ActionEvent e);</div><div class=\"line\">&#125;</div><div class=\"line\">这里并不需要专门定义一个类来实现ActionListener接口，因为它只会在调用处被使用一次。用户一般会使用匿名类型把行为内联（inline）：</div><div class=\"line\"></div><div class=\"line\">button.addActionListener(new ActionListener) &#123;</div><div class=\"line\">  public void actionPerformed(ActionEvent e) &#123;</div><div class=\"line\">    ui.dazzle(e.getModifiers());</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>很多库都依赖于上面的模式。对于并行API更是如此，因为我们需要把待执行的代码提供给并行API，并行编程是一个非常值得研究的领域，因为在这里摩尔定律得到了重生：尽管我们没有更快的CPU核心（core），但是我们有更多的CPU核心。而串行API就只能使用有限的计算能力。</p>\n<p>随着回调模式和函数式编程风格的日益流行，我们需要在Java中提供一种尽可能轻量级的将代码封装为数据（Model code as data）的方法。匿名内部类并不是一个好的选择，因为：</p>\n<p>语法过于冗余<br>匿名类中的this和变量名容易使人产生误解<br>类型载入和实例创建语义不够灵活<br>无法捕获非final的局部变量<br>无法对控制流进行抽象<br>上面的多数问题均在Java SE 8中得以解决：</p>\n<p>通过提供更简洁的语法和局部作用域规则，Java SE 8彻底解决了问题1和问题2<br>通过提供更加灵活而且便于优化的表达式语义，Java SE 8绕开了问题3<br>通过允许编译器推断变量的“常量性”（finality），Java SE 8减轻了问题4带来的困扰<br>不过，Java SE 8的目标并非解决所有上述问题。因此捕获可变变量（问题4）和非局部控制流（问题5）并不在Java SE 8的范畴之内。（尽管我们可能会在未来提供对这些特性的支持）</p>\n<p>##函数式接口</p>\n<p>尽管匿名内部类有着种种限制和问题，但是它有一个良好的特性，它和Java类型系统结合的十分紧密：每一个函数对象都对应一个接口类型。之所以说这个特性是良好的，是因为：</p>\n<p>接口是Java类型系统的一部分<br>接口天然就拥有其运行时表示（Runtime representation）<br>接口可以通过Javadoc注释来表达一些非正式的协定（contract），例如，通过注释说明该操作应可交换（commutative）<br>上面提到的ActionListener接口只有一个方法，大多数回调接口都拥有这个特征：比如Runnable接口和Comparator接口。我们把这些只拥有一个方法的接口称为函数式接口。（之前它们被称为SAM类型，即单抽象方法类型（Single Abstract Method））</p>\n<p>我们并不需要额外的工作来声明一个接口是函数式接口：编译器会根据接口的结构自行判断（判断过程并非简单的对接口方法计数：一个接口可能冗余的定义了一个Object已经提供的方法，比如toString()，或者定义了静态方法或默认方法，这些都不属于函数式接口方法的范畴）。不过API作者们可以通过@FunctionalInterface注解来显式指定一个接口是函数式接口（以避免无意声明了一个符合函数式标准的接口），加上这个注解之后，编译器就会验证该接口是否满足函数式接口的要求。</p>\n<p>实现函数式类型的另一种方式是引入一个全新的结构化函数类型，我们也称其为“箭头”类型。例如，一个接收String和Object并返回int的函数类型可以被表示为(String, Object) -&gt; int。我们仔细考虑了这个方式，但出于下面的原因，最终将其否定：</p>\n<p>它会为Java类型系统引入额外的复杂度，并带来结构类型（Structural Type）和指名类型（Nominal Type）的混用。（Java几乎全部使用指名类型）<br>它会导致类库风格的分歧——一些类库会继续使用回调接口，而另一些类库会使用结构化函数类型<br>它的语法会变得十分笨拙，尤其在包含受检异常（checked exception）之后<br>每个函数类型很难拥有其运行时表示，这意味着开发者会受到类型擦除（erasure）的困扰和局限。比如说，我们无法对方法m(T-&gt;U)和m(X-&gt;Y)进行重载（Overload）<br>所以我们选择了“使用已知类型”这条路——因为现有的类库大量使用了函数式接口，通过沿用这种模式，我们使得现有类库能够直接使用lambda表达式。例如下面是Java SE 7中已经存在的函数式接口：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">java.lang.Runnable</div><div class=\"line\">java.util.concurrent.Callable</div><div class=\"line\">java.security.PrivilegedAction</div><div class=\"line\">java.util.Comparator</div><div class=\"line\">java.io.FileFilter</div><div class=\"line\">java.beans.PropertyChangeListener</div></pre></td></tr></table></figure></p>\n<p>除此之外，Java SE 8中增加了一个新的包：java.util.function，它里面包含了常用的函数式接口，例如：</p>\n<p>Predicate<t>——接收T对象并返回boolean<br>Consumer<t>——接收T对象，不返回值<br>Function<t, r=\"\">——接收T对象，返回R对象<br>Supplier<t>——提供T对象（例如工厂），不接收值<br>UnaryOperator<t>——接收T对象，返回T对象<br>BinaryOperator<t>——接收两个T对象，返回T对象<br>除了上面的这些基本的函数式接口，我们还提供了一些针对原始类型（Primitive type）的特化（Specialization）函数式接口，例如IntSupplier和LongBinaryOperator。（我们只为int、long和double提供了特化函数式接口，如果需要使用其它原始类型则需要进行类型转换）同样的我们也提供了一些针对多个参数的函数式接口，例如BiFunction<t, u,=\"\" r=\"\">，它接收T对象和U对象，返回R对象。</t,></t></t></t></t,></t></t></p>\n<p>##lambda表达式</p>\n<p>匿名类型最大的问题就在于其冗余的语法。有人戏称匿名类型导致了“高度问题”（height problem）：比如前面ActionListener的例子里的五行代码中仅有一行在做实际工作。</p>\n<p>lambda表达式是匿名方法，它提供了轻量级的语法，从而解决了匿名内部类带来的“高度问题”。</p>\n<p>下面是一些lambda表达式：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">(int x, int y) -&gt; x + y</div><div class=\"line\">() -&gt; 42</div><div class=\"line\">(String s) -&gt; &#123; System.out.println(s); &#125;</div></pre></td></tr></table></figure></p>\n<p>第一个lambda表达式接收x和y这两个整形参数并返回它们的和；第二个lambda表达式不接收参数，返回整数’42’；第三个lambda表达式接收一个字符串并把它打印到控制台，不返回值。</p>\n<p>lambda表达式的语法由参数列表、箭头符号-&gt;和函数体组成。函数体既可以是一个表达式，也可以是一个语句块：</p>\n<p>表达式：表达式会被执行然后返回执行结果。<br>语句块：语句块中的语句会被依次执行，就像方法中的语句一样——<br>return语句会把控制权交给匿名方法的调用者<br>break和continue只能在循环中使用<br>如果函数体有返回值，那么函数体内部的每一条路径都必须返回值<br>表达式函数体适合小型lambda表达式，它消除了return关键字，使得语法更加简洁。</p>\n<p>lambda表达式也会经常出现在嵌套环境中，比如说作为方法的参数。为了使lambda表达式在这些场景下尽可能简洁，我们去除了不必要的分隔符。不过在某些情况下我们也可以把它分为多行，然后用括号包起来，就像其它普通表达式一样。</p>\n<p>下面是一些出现在语句中的lambda表达式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">FileFilter java = (File f) -&gt; f.getName().endsWith(&quot;*.java&quot;);</div><div class=\"line\"></div><div class=\"line\">String user = doPrivileged(() -&gt; System.getProperty(&quot;user.name&quot;));</div><div class=\"line\"></div><div class=\"line\">new Thread(() -&gt; &#123;</div><div class=\"line\">  connectToService();</div><div class=\"line\">  sendNotification();</div><div class=\"line\">&#125;).start();</div></pre></td></tr></table></figure>\n<h2 id=\"目标类型\"><a href=\"#目标类型\" class=\"headerlink\" title=\"目标类型\"></a>目标类型</h2><p>需要注意的是，函数式接口的名称并不是lambda表达式的一部分。那么问题来了，对于给定的lambda表达式，它的类型是什么？答案是：它的类型是由其上下文推导而来。例如，下面代码中的lambda表达式类型是ActionListener：</p>\n<p>ActionListener l = (ActionEvent e) -&gt; ui.dazzle(e.getModifiers());<br>这就意味着同样的lambda表达式在不同上下文里可以拥有不同的类型：</p>\n<p>Callable<string> c = () -&gt; “done”;</string></p>\n<p>PrivilegedAction<string> a = () -&gt; “done”;<br>第一个lambda表达式() -&gt; “done”是Callable的实例，而第二个lambda表达式则是PrivilegedAction的实例。</string></p>\n<p>编译器负责推导lambda表达式的类型。它利用lambda表达式所在上下文所期待的类型进行推导，这个被期待的类型被称为目标类型。lambda表达式只能出现在目标类型为函数式接口的上下文中。</p>\n<p>当然，lambda表达式对目标类型也是有要求的。编译器会检查lambda表达式的类型和目标类型的方法签名（method signature）是否一致。当且仅当下面所有条件均满足时，lambda表达式才可以被赋给目标类型T：</p>\n<p>T是一个函数式接口<br>lambda表达式的参数和T的方法参数在数量和类型上一一对应<br>lambda表达式的返回值和T的方法返回值相兼容（Compatible）<br>lambda表达式内所抛出的异常和T的方法throws类型相兼容<br>由于目标类型（函数式接口）已经“知道”lambda表达式的形式参数（Formal parameter）类型，所以我们没有必要把已知类型再重复一遍。也就是说，lambda表达式的参数类型可以从目标类型中得出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Comparator&lt;String&gt; c = (s1, s2) -&gt; s1.compareToIgnoreCase(s2);</div></pre></td></tr></table></figure>\n<p>在上面的例子里，编译器可以推导出s1和s2的类型是String。此外，当lambda的参数只有一个而且它的类型可以被推导得知时，该参数列表外面的括号可以被省略：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">FileFilter java = f -&gt; f.getName().endsWith(&quot;.java&quot;);</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">button.addActionListener(e -&gt; ui.dazzle(e.getModifiers()));</div></pre></td></tr></table></figure>\n<p>这些改进进一步展示了我们的设计目标：“不要把高度问题转化成宽度问题。”我们希望语法元素能够尽可能的少，以便代码的读者能够直达lambda表达式的核心部分。</p>\n<p>lambda表达式并不是第一个拥有上下文相关类型的Java表达式：泛型方法调用和“菱形”构造器调用也通过目标类型来进行类型推导：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">List&lt;String&gt; ls = Collections.emptyList();</div><div class=\"line\">List&lt;Integer&gt; li = Collections.emptyList();</div><div class=\"line\"></div><div class=\"line\">Map&lt;String, Integer&gt; m1 = new HashMap&lt;&gt;();</div><div class=\"line\">Map&lt;Integer, String&gt; m2 = new HashMap&lt;&gt;();</div></pre></td></tr></table></figure></p>\n<ol>\n<li>目标类型的上下文（Contexts for target typing）</li>\n</ol>\n<p>之前我们提到lambda表达式智能出现在拥有目标类型的上下文中。下面给出了这些带有目标类型的上下文：</p>\n<p>变量声明<br>赋值<br>返回语句<br>数组初始化器<br>方法和构造方法的参数<br>lambda表达式函数体<br>条件表达式（? :）<br>转型（Cast）表达式<br>在前三个上下文（变量声明、赋值和返回语句）里，目标类型即是被赋值或被返回的类型：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">Comparator&lt;String&gt; c;</div><div class=\"line\">c = (String s1, String s2) -&gt; s1.compareToIgnoreCase(s2);</div><div class=\"line\"></div><div class=\"line\">public Runnable toDoLater() &#123;</div><div class=\"line\">  return () -&gt; &#123;</div><div class=\"line\">    System.out.println(&quot;later&quot;);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>数组初始化器和赋值类似，只是这里的“变量”变成了数组元素，而类型是从数组类型中推导得知：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">filterFiles(new FileFilter[] &#123;</div><div class=\"line\">              f -&gt; f.exists(), f -&gt; f.canRead(), f -&gt; f.getName().startsWith(&quot;q&quot;)</div><div class=\"line\">            &#125;);</div></pre></td></tr></table></figure></p>\n<p>方法参数的类型推导要相对复杂些：目标类型的确认会涉及到其它两个语言特性：重载解析（Overload resolution）和参数类型推导（Type argument inference）。</p>\n<p>重载解析会为一个给定的方法调用（method invocation）寻找最合适的方法声明（method declaration）。由于不同的声明具有不同的签名，当lambda表达式作为方法参数时，重载解析就会影响到lambda表达式的目标类型。编译器会通过它所得之的信息来做出决定。如果lambda表达式具有显式类型（参数类型被显式指定），编译器就可以直接 使用lambda表达式的返回类型；如果lambda表达式具有隐式类型（参数类型被推导而知），重载解析则会忽略lambda表达式函数体而只依赖lambda表达式参数的数量。</p>\n<p>如果在解析方法声明时存在二义性（ambiguous），我们就需要利用转型（cast）或显式lambda表达式来提供更多的类型信息。如果lambda表达式的返回类型依赖于其参数的类型，那么lambda表达式函数体有可能可以给编译器提供额外的信息，以便其推导参数类型。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">List&lt;Person&gt; ps = ...</div><div class=\"line\">Stream&lt;String&gt; names = ps.stream().map(p -&gt; p.getName());</div></pre></td></tr></table></figure></p>\n<p>在上面的代码中，ps的类型是List<person>，所以ps.stream()的返回类型是Stream<person>。map()方法接收一个类型为Function<t, r=\"\">的函数式接口，这里T的类型即是Stream元素的类型，也就是Person，而R的类型未知。由于在重载解析之后lambda表达式的目标类型仍然未知，我们就需要推导R的类型：通过对lambda表达式函数体进行类型检查，我们发现函数体返回String，因此R的类型是String，因而map()返回Stream<string>。绝大多数情况下编译器都能解析出正确的类型，但如果碰到无法解析的情况，我们则需要：</string></t,></person></person></p>\n<p>使用显式lambda表达式（为参数p提供显式类型）以提供额外的类型信息<br>把lambda表达式转型为Function<person, string=\"\"><br>为泛型参数R提供一个实际类型。（.<string>map(p -&gt; p.getName())）<br>lambda表达式本身也可以为它自己的函数体提供目标类型，也就是说lambda表达式可以通过外部目标类型推导出其内部的返回类型，这意味着我们可以方便的编写一个返回函数的函数：</string></person,></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Supplier&lt;Runnable&gt; c = () -&gt; () -&gt; &#123; System.out.println(&quot;hi&quot;); &#125;;</div></pre></td></tr></table></figure>\n<p>类似的，条件表达式可以把目标类型“分发”给其子表达式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Callable&lt;Integer&gt; c = flag ? (() -&gt; 23) : (() -&gt; 42);</div></pre></td></tr></table></figure>\n<p>最后，转型表达式（Cast expression）可以显式提供lambda表达式的类型，这个特性在无法确认目标类型时非常有用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">// Object o = () -&gt; &#123; System.out.println(&quot;hi&quot;); &#125;; 这段代码是非法的</div><div class=\"line\">Object o = (Runnable) () -&gt; &#123; System.out.println(&quot;hi&quot;); &#125;;</div></pre></td></tr></table></figure>\n<p>除此之外，当重载的方法都拥有函数式接口时，转型可以帮助解决重载解析时出现的二义性。</p>\n<p>目标类型这个概念不仅仅适用于lambda表达式，泛型方法调用和“菱形”构造方法调用也可以从目标类型中受益，下面的代码在Java SE 7是非法的，但在Java SE 8中是合法的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">List&lt;String&gt; ls = Collections.checkedList(new ArrayList&lt;&gt;(), String.class);</div><div class=\"line\"></div><div class=\"line\">Set&lt;Integer&gt; si = flag ? Collections.singleton(23) : Collections.emptySet();</div></pre></td></tr></table></figure>\n<h2 id=\"词法作用域\"><a href=\"#词法作用域\" class=\"headerlink\" title=\"词法作用域\"></a>词法作用域</h2><p>在内部类中使用变量名（以及this）非常容易出错。内部类中通过继承得到的成员（包括来自Object的方法）可能会把外部类的成员掩盖（shadow），此外未限定（unqualified）的this引用会指向内部类自己而非外部类。</p>\n<p>相对于内部类，lambda表达式的语义就十分简单：它不会从超类（supertype）中继承任何变量名，也不会引入一个新的作用域。lambda表达式基于词法作用域，也就是说lambda表达式函数体里面的变量和它外部环境的变量具有相同的语义（也包括lambda表达式的形式参数）。此外，’this’关键字及其引用在lambda表达式内部和外部也拥有相同的语义。</p>\n<p>为了进一步说明词法作用域的优点，请参考下面的代码，它会把”Hello, world!”打印两遍：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class Hello &#123;</div><div class=\"line\">  Runnable r1 = () -&gt; &#123; System.out.println(this); &#125;</div><div class=\"line\">  Runnable r2 = () -&gt; &#123; System.out.println(toString()); &#125;</div><div class=\"line\"></div><div class=\"line\">  public String toString() &#123;  return &quot;Hello, world&quot;; &#125;</div><div class=\"line\"></div><div class=\"line\">  public static void main(String... args) &#123;</div><div class=\"line\">    new Hello().r1.run();</div><div class=\"line\">    new Hello().r2.run();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>与之相类似的内部类实现则会打印出类似Hello$1@5b89a773和Hello$2@537a7706之类的字符串，这往往会使开发者大吃一惊。</p>\n<p>基于词法作用域的理念，lambda表达式不可以掩盖任何其所在上下文中的局部变量，它的行为和那些拥有参数的控制流结构（例如for循环和catch从句）一致。</p>\n<p>个人补充：这个说法很拗口，所以我在这里加一个例子以演示词法作用域：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">int i = 0;</div><div class=\"line\">int sum = 0;</div><div class=\"line\">for (int i = 1; i &lt; 10; i += 1) &#123; //这里会出现编译错误，因为i已经在for循环外部声明过了</div><div class=\"line\">  sum += i;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"变量捕获\"><a href=\"#变量捕获\" class=\"headerlink\" title=\"变量捕获\"></a>变量捕获</h2><p>在Java SE 7中，编译器对内部类中引用的外部变量（即捕获的变量）要求非常严格：如果捕获的变量没有被声明为final就会产生一个编译错误。我们现在放宽了这个限制——对于lambda表达式和内部类，我们允许在其中捕获那些符合有效只读（Effectively final）的局部变量。</p>\n<p>简单的说，如果一个局部变量在初始化后从未被修改过，那么它就符合有效只读的要求，换句话说，加上final后也不会导致编译错误的局部变量就是有效只读变量。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Callable&lt;String&gt; helloCallable(String name) &#123;</div><div class=\"line\">  String hello = &quot;Hello&quot;;</div><div class=\"line\">  return () -&gt; (hello + &quot;, &quot; + name);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>对this的引用，以及通过this对未限定字段的引用和未限定方法的调用在本质上都属于使用final局部变量。包含此类引用的lambda表达式相当于捕获了this实例。在其它情况下，lambda对象不会保留任何对this的引用。</p>\n<p>这个特性对内存管理是一件好事：内部类实例会一直保留一个对其外部类实例的强引用，而那些没有捕获外部类成员的lambda表达式则不会保留对外部类实例的引用。要知道内部类的这个特性往往会造成内存泄露。</p>\n<p>尽管我们放宽了对捕获变量的语法限制，但试图修改捕获变量的行为仍然会被禁止，比如下面这个例子就是非法的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">int sum = 0;</div><div class=\"line\">list.forEach(e -&gt; &#123; sum += e.size(); &#125;);</div></pre></td></tr></table></figure>\n<p>为什么要禁止这种行为呢？因为这样的lambda表达式很容易引起race condition。除非我们能够强制（最好是在编译时）这样的函数不能离开其当前线程，但如果这么做了可能会导致更多的问题。简而言之，lambda表达式对值封闭，对变量开放。</p>\n<p>个人补充：lambda表达式对值封闭，对变量开放的原文是：lambda expressions close over values, not variables，我在这里增加一个例子以说明这个特性：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">int sum = 0;</div><div class=\"line\">list.forEach(e -&gt; &#123; sum += e.size(); &#125;); // Illegal, close over values</div><div class=\"line\"></div><div class=\"line\">List&lt;Integer&gt; aList = new List&lt;&gt;();</div><div class=\"line\">list.forEach(e -&gt; &#123; aList.add(e); &#125;); // Legal, open over variables</div></pre></td></tr></table></figure>\n<p>lambda表达式不支持修改捕获变量的另一个原因是我们可以使用更好的方式来实现同样的效果：使用规约（reduction）。java.util.stream包提供了各种通用的和专用的规约操作（例如sum、min和max），就上面的例子而言，我们可以使用规约操作（在串行和并行下都是安全的）来代替forEach：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">int sum = list.stream()</div><div class=\"line\">              .mapToInt(e -&gt; e.size())</div><div class=\"line\">              .sum();</div></pre></td></tr></table></figure>\n<p>sum()等价于下面的规约操作：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">int sum = list.stream()</div><div class=\"line\">              .mapToInt(e -&gt; e.size())</div><div class=\"line\">              .reduce(0 , (x, y) -&gt; x + y);</div></pre></td></tr></table></figure>\n<p>规约需要一个初始值（以防输入为空）和一个操作符（在这里是加号），然后用下面的表达式计算结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">0 + list[0] + list[1] + list[2] + ...</div></pre></td></tr></table></figure>\n<p>规约也可以完成其它操作，比如求最小值、最大值和乘积等等。如果操作符具有可结合性（associative），那么规约操作就可以容易的被并行化。所以，与其支持一个本质上是并行而且容易导致race condition的操作，我们选择在库中提供一个更加并行友好且不容易出错的方式来进行累积（accumulation）。</p>\n<p>##方法引用</p>\n<p>lambda表达式允许我们定义一个匿名方法，并允许我们以函数式接口的方式使用它。我们也希望能够在已有的方法上实现同样的特性。</p>\n<p>方法引用和lambda表达式拥有相同的特性（例如，它们都需要一个目标类型，并需要被转化为函数式接口的实例），不过我们并不需要为方法引用提供方法体，我们可以直接通过方法名称引用已有方法。</p>\n<p>以下面的代码为例，假设我们要按照name或age为Person数组进行排序：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Person &#123;</div><div class=\"line\">  private final String name;</div><div class=\"line\">  private final int age;</div><div class=\"line\"></div><div class=\"line\">  public int getAge() &#123; return age; &#125;</div><div class=\"line\">  public String getName() &#123;return name; &#125;</div><div class=\"line\">  ...</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Person[] people = ...</div><div class=\"line\">Comparator&lt;Person&gt; byName = Comparator.comparing(p -&gt; p.getName());</div><div class=\"line\">Arrays.sort(people, byName);</div></pre></td></tr></table></figure>\n<p>在这里我们可以用方法引用代替lambda表达式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Comparator&lt;Person&gt; byName = Comparator.comparing(Person::getName);</div></pre></td></tr></table></figure>\n<p>这里的Person::getName可以被看作为lambda表达式的简写形式。尽管方法引用不一定（比如在这个例子里）会把语法变的更紧凑，但它拥有更明确的语义——如果我们想要调用的方法拥有一个名字，我们就可以通过它的名字直接调用它。</p>\n<p>因为函数式接口的方法参数对应于隐式方法调用时的参数，所以被引用方法签名可以通过放宽类型，装箱以及组织到参数数组中的方式对其参数进行操作，就像在调用实际方法一样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Consumer&lt;Integer&gt; b1 = System::exit;    // void exit(int status)</div><div class=\"line\">Consumer&lt;String[]&gt; b2 = Arrays:sort;    // void sort(Object[] a)</div><div class=\"line\">Consumer&lt;String&gt; b3 = MyProgram::main;  // void main(String... args)</div><div class=\"line\">Runnable r = Myprogram::mapToInt        // void main(String... args)</div></pre></td></tr></table></figure>\n<h2 id=\"方法引用的种类\"><a href=\"#方法引用的种类\" class=\"headerlink\" title=\"方法引用的种类\"></a>方法引用的种类</h2><p>方法引用有很多种，它们的语法如下：</p>\n<p>静态方法引用：ClassName::methodName<br>实例上的实例方法引用：instanceReference::methodName<br>超类上的实例方法引用：super::methodName<br>类型上的实例方法引用：ClassName::methodName<br>构造方法引用：Class::new<br>数组构造方法引用：TypeName[]::new<br>对于静态方法引用，我们需要在类名和方法名之间加入::分隔符，例如Integer::sum。</p>\n<p>对于具体对象上的实例方法引用，我们则需要在对象名和方法名之间加入分隔符：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Set&lt;String&gt; knownNames = ...</div><div class=\"line\">Predicate&lt;String&gt; isKnown = knownNames::contains;</div></pre></td></tr></table></figure>\n<p>这里的隐式lambda表达式（也就是实例方法引用）会从knownNames中捕获String对象，而它的方法体则会通过Set.contains使用该String对象。</p>\n<p>有了实例方法引用，在不同函数式接口之间进行类型转换就变的很方便：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Callable&lt;Path&gt; c = ...</div><div class=\"line\">Privileged&lt;Path&gt; a = c::call;</div></pre></td></tr></table></figure>\n<p>引用任意对象的实例方法则需要在实例方法名称和其所属类型名称间加上分隔符：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Function&lt;String, String&gt; upperfier = String::toUpperCase;</div></pre></td></tr></table></figure>\n<p>这里的隐式lambda表达式（即String::toUpperCase实例方法引用）有一个String参数，这个参数会被toUpperCase方法使用。</p>\n<p>如果类型的实例方法是泛型的，那么我们就需要在::分隔符前提供类型参数，或者（多数情况下）利用目标类型推导出其类型。</p>\n<p>需要注意的是，静态方法引用和类型上的实例方法引用拥有一样的语法。编译器会根据实际情况做出决定。</p>\n<p>一般我们不需要指定方法引用中的参数类型，因为编译器往往可以推导出结果，但如果需要我们也可以显式在::分隔符之前提供参数类型信息。</p>\n<p>和静态方法引用类似，构造方法也可以通过new关键字被直接引用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">SocketImplFactory factory = MySocketImpl::new;</div></pre></td></tr></table></figure>\n<p>如果类型拥有多个构造方法，那么我们就会通过目标类型的方法参数来选择最佳匹配，这里的选择过程和调用构造方法时的选择过程是一样的。</p>\n<p>如果待实例化的类型是泛型的，那么我们可以在类型名称之后提供类型参数，否则编译器则会依照”菱形”构造方法调用时的方式进行推导。</p>\n<p>数组的构造方法引用的语法则比较特殊，为了便于理解，你可以假想存在一个接收int参数的数组构造方法。参考下面的代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">IntFunction&lt;int[]&gt; arrayMaker = int[]::new;</div><div class=\"line\">int[] array = arrayMaker.apply(10) // 创建数组 int[10]</div></pre></td></tr></table></figure></p>\n<h2 id=\"默认方法和静态接口方法\"><a href=\"#默认方法和静态接口方法\" class=\"headerlink\" title=\"默认方法和静态接口方法\"></a>默认方法和静态接口方法</h2><p>lambda表达式和方法引用大大提升了Java的表达能力（expressiveness），不过为了使把代码即数据（code-as-data）变的更加容易，我们需要把这些特性融入到已有的库之中，以便开发者使用。</p>\n<p>Java SE 7时代为一个已有的类库增加功能是非常困难的。具体的说，接口在发布之后就已经被定型，除非我们能够一次性更新所有该接口的实现，否则向接口添加方法就会破坏现有的接口实现。默认方法（之前被称为虚拟扩展方法或守护方法）的目标即是解决这个问题，使得接口在发布之后仍能被逐步演化。</p>\n<p>这里给出一个例子，我们需要在标准集合API中增加针对lambda的方法。例如removeAll方法应该被泛化为接收一个函数式接口Predicate，但这个新的方法应该被放在哪里呢？我们无法直接在Collection接口上新增方法——不然就会破坏现有的Collection实现。我们倒是可以在Collections工具类中增加对应的静态方法，但这样就会把这个方法置于“二等公民”的境地。</p>\n<p>默认方法利用面向对象的方式向接口增加新的行为。它是一种新的方法：接口方法可以是抽象的或是默认的。默认方法拥有其默认实现，实现接口的类型通过继承得到该默认实现（如果类型没有覆盖该默认实现）。此外，默认方法不是抽象方法，所以我们可以放心的向函数式接口里增加默认方法，而不用担心函数式接口的单抽象方法限制。</p>\n<p>下面的例子展示了如何向Iterator接口增加默认方法skip：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">interface Iterator&lt;E&gt; &#123;</div><div class=\"line\">  boolean hasNext();</div><div class=\"line\">  E next();</div><div class=\"line\">  void remove();</div><div class=\"line\"></div><div class=\"line\">  default void skip(int i) &#123;</div><div class=\"line\">    for ( ; i &gt; 0 &amp;&amp; hasNext(); i -= 1) next();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>根据上面的Iterator定义，所有实现Iterator的类型都会自动继承skip方法。在使用者的眼里，skip不过是接口新增的一个虚拟方法。在没有覆盖skip方法的Iterator子类实例上调用skip会执行skip的默认实现：调用hasNext和next若干次。子类可以通过覆盖skip来提供更好的实现——比如直接移动游标（cursor），或是提供为操作提供原子性（Atomicity）等。</p>\n<p>当接口继承其它接口时，我们既可以为它所继承而来的抽象方法提供一个默认实现，也可以为它继承而来的默认方法提供一个新的实现，还可以把它继承而来的默认方法重新抽象化。</p>\n<p>除了默认方法，Java SE 8还在允许在接口中定义静态方法。这使得我们可以从接口直接调用和它相关的辅助方法（Helper method），而不是从其它的类中调用（之前这样的类往往以对应接口的复数命名，例如Collections）。比如，我们一般需要使用静态辅助方法生成实现Comparator的比较器，在Java SE 8中我们可以直接把该静态方法定义在Comparator接口中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static &lt;T, U extends Comparable&lt;? super U&gt;&gt;</div><div class=\"line\">    Comparator&lt;T&gt; comparing(Function&lt;T, U&gt; keyExtractor) &#123;</div><div class=\"line\">  return (c1, c2) -&gt; keyExtractor.apply(c1).compareTo(keyExtractor.apply(c2));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"继承默认方法\"><a href=\"#继承默认方法\" class=\"headerlink\" title=\"继承默认方法\"></a>继承默认方法</h2><p>和其它方法一样，默认方法也可以被继承，大多数情况下这种继承行为和我们所期待的一致。不过，当类型或者接口的超类拥有多个具有相同签名的方法时，我们就需要一套规则来解决这个冲突：</p>\n<p>类的方法（class method）声明优先于接口默认方法。无论该方法是具体的还是抽象的。<br>被其它类型所覆盖的方法会被忽略。这条规则适用于超类型共享一个公共祖先的情况。<br>为了演示第二条规则，我们假设Collection和List接口均提供了removeAll的默认实现，然后Queue继承并覆盖了Collection中的默认方法。在下面的implement从句中，List中的方法声明会优先于Queue中的方法声明：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">class LinkedList&lt;E&gt; implements List&lt;E&gt;, Queue&lt;E&gt; &#123; ... &#125;</div></pre></td></tr></table></figure>\n<p>当两个独立的默认方法相冲突或是默认方法和抽象方法相冲突时会产生编译错误。这时程序员需要显式覆盖超类方法。一般来说我们会定义一个默认方法，然后在其中显式选择超类方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">interface Robot implements Artist, Gun &#123;</div><div class=\"line\">  default void draw() &#123; Artist.super.draw(); &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>super前面的类型必须是有定义或继承默认方法的类型。这种方法调用并不只限于消除命名冲突——我们也可以在其它场景中使用它。</p>\n<p>最后，接口在inherits和extends从句中的声明顺序和它们被实现的顺序无关。</p>\n<h2 id=\"融会贯通\"><a href=\"#融会贯通\" class=\"headerlink\" title=\"融会贯通\"></a>融会贯通</h2><p>我们在设计lambda时的一个重要目标就是新增的语言特性和库特性能够无缝结合（designed to work together）。接下来，我们通过一个实际例子（按照姓对名字列表进行排序）来演示这一点：</p>\n<p>比如说下面的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">List&lt;Person&gt; people = ...</div><div class=\"line\">Collections.sort(people, new Comparator&lt;Person&gt;() &#123;</div><div class=\"line\">  public int compare(Person x, Person y) &#123;</div><div class=\"line\">    return x.getLastName().compareTo(y.getLastName());</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>冗余代码实在太多了！</p>\n<p>有了lambda表达式，我们可以去掉冗余的匿名类：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Collections.sort(people,</div><div class=\"line\">                 (Person x, Person y) -&gt; x.getLastName().compareTo(y.getLastName()));</div></pre></td></tr></table></figure>\n<p>尽管代码简洁了很多，但它的抽象程度依然很差：开发者仍然需要进行实际的比较操作（而且如果比较的值是原始类型那么情况会更糟），所以我们要借助Comparator里的comparing方法实现比较操作：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Collections.sort(people, Comparator.comparing((Person p) -&gt; p.getLastName()));</div></pre></td></tr></table></figure>\n<p>在类型推导和静态导入的帮助下，我们可以进一步简化上面的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Collections.sort(people, comparing(p -&gt; p.getLastName()));</div></pre></td></tr></table></figure>\n<p>我们注意到这里的lambda表达式实际上是getLastName的代理（forwarder），于是我们可以用方法引用代替它：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">Collections.sort(people, comparing(Person::getLastName));</div></pre></td></tr></table></figure></p>\n<p>最后，使用Collections.sort这样的辅助方法并不是一个好主意：它不但使代码变的冗余，也无法为实现List接口的数据结构提供特定（specialized）的高效实现，而且由于Collections.sort方法不属于List接口，用户在阅读List接口的文档时不会察觉在另外的Collections类中还有一个针对List接口的排序（sort()）方法。</p>\n<p>默认方法可以有效的解决这个问题，我们为List增加默认方法sort()，然后就可以这样调用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">people.sort(comparing(Person::getLastName));;</div></pre></td></tr></table></figure>\n<p>此外，如果我们为Comparator接口增加一个默认方法reversed()（产生一个逆序比较器），我们就可以非常容易的在前面代码的基础上实现降序排序。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">people.sort(comparing(Person::getLastName).reversed());;</div></pre></td></tr></table></figure>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>Java SE 8提供的新语言特性并不算多——lambda表达式，方法引用，默认方法和静态接口方法，以及范围更广的类型推导。但是把它们结合在一起之后，开发者可以编写出更加清晰简洁的代码，类库编写者可以编写更加强大易用的并行类库。</p>\n","excerpt":"","more":"<h2 id=\"关于\"><a href=\"#关于\" class=\"headerlink\" title=\"关于\"></a>关于</h2><p>本文介绍了Java SE 8中新引入的lambda语言特性以及这些特性背后的设计思想。这些特性包括：</p>\n<p>lambda表达式（又被成为“闭包”或“匿名方法”）<br>方法引用和构造方法引用<br>扩展的目标类型和类型推导<br>接口中的默认方法和静态方法</p>\n<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>Java是一门面向对象编程语言。面向对象编程语言和函数式编程语言中的基本元素（Basic Values）都可以动态封装程序行为：面向对象编程语言使用带有方法的对象封装行为，函数式编程语言使用函数封装行为。但这个相同点并不明显，因为Java的对象往往比较“重量级”：实例化一个类型往往会涉及不同的类，并需要初始化类里的字段和方法。</p>\n<p>不过有些Java对象只是对单个函数的封装。例如下面这个典型用例：Java API中定义了一个接口（一般被称为回调接口），用户通过提供这个接口的实例来传入指定行为，例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">public interface ActionListener &#123;</div><div class=\"line\">  void actionPerformed(ActionEvent e);</div><div class=\"line\">&#125;</div><div class=\"line\">这里并不需要专门定义一个类来实现ActionListener接口，因为它只会在调用处被使用一次。用户一般会使用匿名类型把行为内联（inline）：</div><div class=\"line\"></div><div class=\"line\">button.addActionListener(new ActionListener) &#123;</div><div class=\"line\">  public void actionPerformed(ActionEvent e) &#123;</div><div class=\"line\">    ui.dazzle(e.getModifiers());</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>很多库都依赖于上面的模式。对于并行API更是如此，因为我们需要把待执行的代码提供给并行API，并行编程是一个非常值得研究的领域，因为在这里摩尔定律得到了重生：尽管我们没有更快的CPU核心（core），但是我们有更多的CPU核心。而串行API就只能使用有限的计算能力。</p>\n<p>随着回调模式和函数式编程风格的日益流行，我们需要在Java中提供一种尽可能轻量级的将代码封装为数据（Model code as data）的方法。匿名内部类并不是一个好的选择，因为：</p>\n<p>语法过于冗余<br>匿名类中的this和变量名容易使人产生误解<br>类型载入和实例创建语义不够灵活<br>无法捕获非final的局部变量<br>无法对控制流进行抽象<br>上面的多数问题均在Java SE 8中得以解决：</p>\n<p>通过提供更简洁的语法和局部作用域规则，Java SE 8彻底解决了问题1和问题2<br>通过提供更加灵活而且便于优化的表达式语义，Java SE 8绕开了问题3<br>通过允许编译器推断变量的“常量性”（finality），Java SE 8减轻了问题4带来的困扰<br>不过，Java SE 8的目标并非解决所有上述问题。因此捕获可变变量（问题4）和非局部控制流（问题5）并不在Java SE 8的范畴之内。（尽管我们可能会在未来提供对这些特性的支持）</p>\n<p>##函数式接口</p>\n<p>尽管匿名内部类有着种种限制和问题，但是它有一个良好的特性，它和Java类型系统结合的十分紧密：每一个函数对象都对应一个接口类型。之所以说这个特性是良好的，是因为：</p>\n<p>接口是Java类型系统的一部分<br>接口天然就拥有其运行时表示（Runtime representation）<br>接口可以通过Javadoc注释来表达一些非正式的协定（contract），例如，通过注释说明该操作应可交换（commutative）<br>上面提到的ActionListener接口只有一个方法，大多数回调接口都拥有这个特征：比如Runnable接口和Comparator接口。我们把这些只拥有一个方法的接口称为函数式接口。（之前它们被称为SAM类型，即单抽象方法类型（Single Abstract Method））</p>\n<p>我们并不需要额外的工作来声明一个接口是函数式接口：编译器会根据接口的结构自行判断（判断过程并非简单的对接口方法计数：一个接口可能冗余的定义了一个Object已经提供的方法，比如toString()，或者定义了静态方法或默认方法，这些都不属于函数式接口方法的范畴）。不过API作者们可以通过@FunctionalInterface注解来显式指定一个接口是函数式接口（以避免无意声明了一个符合函数式标准的接口），加上这个注解之后，编译器就会验证该接口是否满足函数式接口的要求。</p>\n<p>实现函数式类型的另一种方式是引入一个全新的结构化函数类型，我们也称其为“箭头”类型。例如，一个接收String和Object并返回int的函数类型可以被表示为(String, Object) -&gt; int。我们仔细考虑了这个方式，但出于下面的原因，最终将其否定：</p>\n<p>它会为Java类型系统引入额外的复杂度，并带来结构类型（Structural Type）和指名类型（Nominal Type）的混用。（Java几乎全部使用指名类型）<br>它会导致类库风格的分歧——一些类库会继续使用回调接口，而另一些类库会使用结构化函数类型<br>它的语法会变得十分笨拙，尤其在包含受检异常（checked exception）之后<br>每个函数类型很难拥有其运行时表示，这意味着开发者会受到类型擦除（erasure）的困扰和局限。比如说，我们无法对方法m(T-&gt;U)和m(X-&gt;Y)进行重载（Overload）<br>所以我们选择了“使用已知类型”这条路——因为现有的类库大量使用了函数式接口，通过沿用这种模式，我们使得现有类库能够直接使用lambda表达式。例如下面是Java SE 7中已经存在的函数式接口：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">java.lang.Runnable</div><div class=\"line\">java.util.concurrent.Callable</div><div class=\"line\">java.security.PrivilegedAction</div><div class=\"line\">java.util.Comparator</div><div class=\"line\">java.io.FileFilter</div><div class=\"line\">java.beans.PropertyChangeListener</div></pre></td></tr></table></figure></p>\n<p>除此之外，Java SE 8中增加了一个新的包：java.util.function，它里面包含了常用的函数式接口，例如：</p>\n<p>Predicate<T>——接收T对象并返回boolean<br>Consumer<T>——接收T对象，不返回值<br>Function<T, R>——接收T对象，返回R对象<br>Supplier<T>——提供T对象（例如工厂），不接收值<br>UnaryOperator<T>——接收T对象，返回T对象<br>BinaryOperator<T>——接收两个T对象，返回T对象<br>除了上面的这些基本的函数式接口，我们还提供了一些针对原始类型（Primitive type）的特化（Specialization）函数式接口，例如IntSupplier和LongBinaryOperator。（我们只为int、long和double提供了特化函数式接口，如果需要使用其它原始类型则需要进行类型转换）同样的我们也提供了一些针对多个参数的函数式接口，例如BiFunction<T, U, R>，它接收T对象和U对象，返回R对象。</p>\n<p>##lambda表达式</p>\n<p>匿名类型最大的问题就在于其冗余的语法。有人戏称匿名类型导致了“高度问题”（height problem）：比如前面ActionListener的例子里的五行代码中仅有一行在做实际工作。</p>\n<p>lambda表达式是匿名方法，它提供了轻量级的语法，从而解决了匿名内部类带来的“高度问题”。</p>\n<p>下面是一些lambda表达式：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">(int x, int y) -&gt; x + y</div><div class=\"line\">() -&gt; 42</div><div class=\"line\">(String s) -&gt; &#123; System.out.println(s); &#125;</div></pre></td></tr></table></figure></p>\n<p>第一个lambda表达式接收x和y这两个整形参数并返回它们的和；第二个lambda表达式不接收参数，返回整数’42’；第三个lambda表达式接收一个字符串并把它打印到控制台，不返回值。</p>\n<p>lambda表达式的语法由参数列表、箭头符号-&gt;和函数体组成。函数体既可以是一个表达式，也可以是一个语句块：</p>\n<p>表达式：表达式会被执行然后返回执行结果。<br>语句块：语句块中的语句会被依次执行，就像方法中的语句一样——<br>return语句会把控制权交给匿名方法的调用者<br>break和continue只能在循环中使用<br>如果函数体有返回值，那么函数体内部的每一条路径都必须返回值<br>表达式函数体适合小型lambda表达式，它消除了return关键字，使得语法更加简洁。</p>\n<p>lambda表达式也会经常出现在嵌套环境中，比如说作为方法的参数。为了使lambda表达式在这些场景下尽可能简洁，我们去除了不必要的分隔符。不过在某些情况下我们也可以把它分为多行，然后用括号包起来，就像其它普通表达式一样。</p>\n<p>下面是一些出现在语句中的lambda表达式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">FileFilter java = (File f) -&gt; f.getName().endsWith(&quot;*.java&quot;);</div><div class=\"line\"></div><div class=\"line\">String user = doPrivileged(() -&gt; System.getProperty(&quot;user.name&quot;));</div><div class=\"line\"></div><div class=\"line\">new Thread(() -&gt; &#123;</div><div class=\"line\">  connectToService();</div><div class=\"line\">  sendNotification();</div><div class=\"line\">&#125;).start();</div></pre></td></tr></table></figure>\n<h2 id=\"目标类型\"><a href=\"#目标类型\" class=\"headerlink\" title=\"目标类型\"></a>目标类型</h2><p>需要注意的是，函数式接口的名称并不是lambda表达式的一部分。那么问题来了，对于给定的lambda表达式，它的类型是什么？答案是：它的类型是由其上下文推导而来。例如，下面代码中的lambda表达式类型是ActionListener：</p>\n<p>ActionListener l = (ActionEvent e) -&gt; ui.dazzle(e.getModifiers());<br>这就意味着同样的lambda表达式在不同上下文里可以拥有不同的类型：</p>\n<p>Callable<String> c = () -&gt; “done”;</p>\n<p>PrivilegedAction<String> a = () -&gt; “done”;<br>第一个lambda表达式() -&gt; “done”是Callable的实例，而第二个lambda表达式则是PrivilegedAction的实例。</p>\n<p>编译器负责推导lambda表达式的类型。它利用lambda表达式所在上下文所期待的类型进行推导，这个被期待的类型被称为目标类型。lambda表达式只能出现在目标类型为函数式接口的上下文中。</p>\n<p>当然，lambda表达式对目标类型也是有要求的。编译器会检查lambda表达式的类型和目标类型的方法签名（method signature）是否一致。当且仅当下面所有条件均满足时，lambda表达式才可以被赋给目标类型T：</p>\n<p>T是一个函数式接口<br>lambda表达式的参数和T的方法参数在数量和类型上一一对应<br>lambda表达式的返回值和T的方法返回值相兼容（Compatible）<br>lambda表达式内所抛出的异常和T的方法throws类型相兼容<br>由于目标类型（函数式接口）已经“知道”lambda表达式的形式参数（Formal parameter）类型，所以我们没有必要把已知类型再重复一遍。也就是说，lambda表达式的参数类型可以从目标类型中得出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Comparator&lt;String&gt; c = (s1, s2) -&gt; s1.compareToIgnoreCase(s2);</div></pre></td></tr></table></figure>\n<p>在上面的例子里，编译器可以推导出s1和s2的类型是String。此外，当lambda的参数只有一个而且它的类型可以被推导得知时，该参数列表外面的括号可以被省略：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">FileFilter java = f -&gt; f.getName().endsWith(&quot;.java&quot;);</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">button.addActionListener(e -&gt; ui.dazzle(e.getModifiers()));</div></pre></td></tr></table></figure>\n<p>这些改进进一步展示了我们的设计目标：“不要把高度问题转化成宽度问题。”我们希望语法元素能够尽可能的少，以便代码的读者能够直达lambda表达式的核心部分。</p>\n<p>lambda表达式并不是第一个拥有上下文相关类型的Java表达式：泛型方法调用和“菱形”构造器调用也通过目标类型来进行类型推导：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">List&lt;String&gt; ls = Collections.emptyList();</div><div class=\"line\">List&lt;Integer&gt; li = Collections.emptyList();</div><div class=\"line\"></div><div class=\"line\">Map&lt;String, Integer&gt; m1 = new HashMap&lt;&gt;();</div><div class=\"line\">Map&lt;Integer, String&gt; m2 = new HashMap&lt;&gt;();</div></pre></td></tr></table></figure></p>\n<ol>\n<li>目标类型的上下文（Contexts for target typing）</li>\n</ol>\n<p>之前我们提到lambda表达式智能出现在拥有目标类型的上下文中。下面给出了这些带有目标类型的上下文：</p>\n<p>变量声明<br>赋值<br>返回语句<br>数组初始化器<br>方法和构造方法的参数<br>lambda表达式函数体<br>条件表达式（? :）<br>转型（Cast）表达式<br>在前三个上下文（变量声明、赋值和返回语句）里，目标类型即是被赋值或被返回的类型：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">Comparator&lt;String&gt; c;</div><div class=\"line\">c = (String s1, String s2) -&gt; s1.compareToIgnoreCase(s2);</div><div class=\"line\"></div><div class=\"line\">public Runnable toDoLater() &#123;</div><div class=\"line\">  return () -&gt; &#123;</div><div class=\"line\">    System.out.println(&quot;later&quot;);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>数组初始化器和赋值类似，只是这里的“变量”变成了数组元素，而类型是从数组类型中推导得知：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">filterFiles(new FileFilter[] &#123;</div><div class=\"line\">              f -&gt; f.exists(), f -&gt; f.canRead(), f -&gt; f.getName().startsWith(&quot;q&quot;)</div><div class=\"line\">            &#125;);</div></pre></td></tr></table></figure></p>\n<p>方法参数的类型推导要相对复杂些：目标类型的确认会涉及到其它两个语言特性：重载解析（Overload resolution）和参数类型推导（Type argument inference）。</p>\n<p>重载解析会为一个给定的方法调用（method invocation）寻找最合适的方法声明（method declaration）。由于不同的声明具有不同的签名，当lambda表达式作为方法参数时，重载解析就会影响到lambda表达式的目标类型。编译器会通过它所得之的信息来做出决定。如果lambda表达式具有显式类型（参数类型被显式指定），编译器就可以直接 使用lambda表达式的返回类型；如果lambda表达式具有隐式类型（参数类型被推导而知），重载解析则会忽略lambda表达式函数体而只依赖lambda表达式参数的数量。</p>\n<p>如果在解析方法声明时存在二义性（ambiguous），我们就需要利用转型（cast）或显式lambda表达式来提供更多的类型信息。如果lambda表达式的返回类型依赖于其参数的类型，那么lambda表达式函数体有可能可以给编译器提供额外的信息，以便其推导参数类型。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">List&lt;Person&gt; ps = ...</div><div class=\"line\">Stream&lt;String&gt; names = ps.stream().map(p -&gt; p.getName());</div></pre></td></tr></table></figure></p>\n<p>在上面的代码中，ps的类型是List<Person>，所以ps.stream()的返回类型是Stream<Person>。map()方法接收一个类型为Function<T, R>的函数式接口，这里T的类型即是Stream元素的类型，也就是Person，而R的类型未知。由于在重载解析之后lambda表达式的目标类型仍然未知，我们就需要推导R的类型：通过对lambda表达式函数体进行类型检查，我们发现函数体返回String，因此R的类型是String，因而map()返回Stream<String>。绝大多数情况下编译器都能解析出正确的类型，但如果碰到无法解析的情况，我们则需要：</p>\n<p>使用显式lambda表达式（为参数p提供显式类型）以提供额外的类型信息<br>把lambda表达式转型为Function<Person, String><br>为泛型参数R提供一个实际类型。（.<String>map(p -&gt; p.getName())）<br>lambda表达式本身也可以为它自己的函数体提供目标类型，也就是说lambda表达式可以通过外部目标类型推导出其内部的返回类型，这意味着我们可以方便的编写一个返回函数的函数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Supplier&lt;Runnable&gt; c = () -&gt; () -&gt; &#123; System.out.println(&quot;hi&quot;); &#125;;</div></pre></td></tr></table></figure>\n<p>类似的，条件表达式可以把目标类型“分发”给其子表达式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Callable&lt;Integer&gt; c = flag ? (() -&gt; 23) : (() -&gt; 42);</div></pre></td></tr></table></figure>\n<p>最后，转型表达式（Cast expression）可以显式提供lambda表达式的类型，这个特性在无法确认目标类型时非常有用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">// Object o = () -&gt; &#123; System.out.println(&quot;hi&quot;); &#125;; 这段代码是非法的</div><div class=\"line\">Object o = (Runnable) () -&gt; &#123; System.out.println(&quot;hi&quot;); &#125;;</div></pre></td></tr></table></figure>\n<p>除此之外，当重载的方法都拥有函数式接口时，转型可以帮助解决重载解析时出现的二义性。</p>\n<p>目标类型这个概念不仅仅适用于lambda表达式，泛型方法调用和“菱形”构造方法调用也可以从目标类型中受益，下面的代码在Java SE 7是非法的，但在Java SE 8中是合法的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">List&lt;String&gt; ls = Collections.checkedList(new ArrayList&lt;&gt;(), String.class);</div><div class=\"line\"></div><div class=\"line\">Set&lt;Integer&gt; si = flag ? Collections.singleton(23) : Collections.emptySet();</div></pre></td></tr></table></figure>\n<h2 id=\"词法作用域\"><a href=\"#词法作用域\" class=\"headerlink\" title=\"词法作用域\"></a>词法作用域</h2><p>在内部类中使用变量名（以及this）非常容易出错。内部类中通过继承得到的成员（包括来自Object的方法）可能会把外部类的成员掩盖（shadow），此外未限定（unqualified）的this引用会指向内部类自己而非外部类。</p>\n<p>相对于内部类，lambda表达式的语义就十分简单：它不会从超类（supertype）中继承任何变量名，也不会引入一个新的作用域。lambda表达式基于词法作用域，也就是说lambda表达式函数体里面的变量和它外部环境的变量具有相同的语义（也包括lambda表达式的形式参数）。此外，’this’关键字及其引用在lambda表达式内部和外部也拥有相同的语义。</p>\n<p>为了进一步说明词法作用域的优点，请参考下面的代码，它会把”Hello, world!”打印两遍：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class Hello &#123;</div><div class=\"line\">  Runnable r1 = () -&gt; &#123; System.out.println(this); &#125;</div><div class=\"line\">  Runnable r2 = () -&gt; &#123; System.out.println(toString()); &#125;</div><div class=\"line\"></div><div class=\"line\">  public String toString() &#123;  return &quot;Hello, world&quot;; &#125;</div><div class=\"line\"></div><div class=\"line\">  public static void main(String... args) &#123;</div><div class=\"line\">    new Hello().r1.run();</div><div class=\"line\">    new Hello().r2.run();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>与之相类似的内部类实现则会打印出类似Hello$1@5b89a773和Hello$2@537a7706之类的字符串，这往往会使开发者大吃一惊。</p>\n<p>基于词法作用域的理念，lambda表达式不可以掩盖任何其所在上下文中的局部变量，它的行为和那些拥有参数的控制流结构（例如for循环和catch从句）一致。</p>\n<p>个人补充：这个说法很拗口，所以我在这里加一个例子以演示词法作用域：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">int i = 0;</div><div class=\"line\">int sum = 0;</div><div class=\"line\">for (int i = 1; i &lt; 10; i += 1) &#123; //这里会出现编译错误，因为i已经在for循环外部声明过了</div><div class=\"line\">  sum += i;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"变量捕获\"><a href=\"#变量捕获\" class=\"headerlink\" title=\"变量捕获\"></a>变量捕获</h2><p>在Java SE 7中，编译器对内部类中引用的外部变量（即捕获的变量）要求非常严格：如果捕获的变量没有被声明为final就会产生一个编译错误。我们现在放宽了这个限制——对于lambda表达式和内部类，我们允许在其中捕获那些符合有效只读（Effectively final）的局部变量。</p>\n<p>简单的说，如果一个局部变量在初始化后从未被修改过，那么它就符合有效只读的要求，换句话说，加上final后也不会导致编译错误的局部变量就是有效只读变量。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Callable&lt;String&gt; helloCallable(String name) &#123;</div><div class=\"line\">  String hello = &quot;Hello&quot;;</div><div class=\"line\">  return () -&gt; (hello + &quot;, &quot; + name);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>对this的引用，以及通过this对未限定字段的引用和未限定方法的调用在本质上都属于使用final局部变量。包含此类引用的lambda表达式相当于捕获了this实例。在其它情况下，lambda对象不会保留任何对this的引用。</p>\n<p>这个特性对内存管理是一件好事：内部类实例会一直保留一个对其外部类实例的强引用，而那些没有捕获外部类成员的lambda表达式则不会保留对外部类实例的引用。要知道内部类的这个特性往往会造成内存泄露。</p>\n<p>尽管我们放宽了对捕获变量的语法限制，但试图修改捕获变量的行为仍然会被禁止，比如下面这个例子就是非法的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">int sum = 0;</div><div class=\"line\">list.forEach(e -&gt; &#123; sum += e.size(); &#125;);</div></pre></td></tr></table></figure>\n<p>为什么要禁止这种行为呢？因为这样的lambda表达式很容易引起race condition。除非我们能够强制（最好是在编译时）这样的函数不能离开其当前线程，但如果这么做了可能会导致更多的问题。简而言之，lambda表达式对值封闭，对变量开放。</p>\n<p>个人补充：lambda表达式对值封闭，对变量开放的原文是：lambda expressions close over values, not variables，我在这里增加一个例子以说明这个特性：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">int sum = 0;</div><div class=\"line\">list.forEach(e -&gt; &#123; sum += e.size(); &#125;); // Illegal, close over values</div><div class=\"line\"></div><div class=\"line\">List&lt;Integer&gt; aList = new List&lt;&gt;();</div><div class=\"line\">list.forEach(e -&gt; &#123; aList.add(e); &#125;); // Legal, open over variables</div></pre></td></tr></table></figure>\n<p>lambda表达式不支持修改捕获变量的另一个原因是我们可以使用更好的方式来实现同样的效果：使用规约（reduction）。java.util.stream包提供了各种通用的和专用的规约操作（例如sum、min和max），就上面的例子而言，我们可以使用规约操作（在串行和并行下都是安全的）来代替forEach：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">int sum = list.stream()</div><div class=\"line\">              .mapToInt(e -&gt; e.size())</div><div class=\"line\">              .sum();</div></pre></td></tr></table></figure>\n<p>sum()等价于下面的规约操作：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">int sum = list.stream()</div><div class=\"line\">              .mapToInt(e -&gt; e.size())</div><div class=\"line\">              .reduce(0 , (x, y) -&gt; x + y);</div></pre></td></tr></table></figure>\n<p>规约需要一个初始值（以防输入为空）和一个操作符（在这里是加号），然后用下面的表达式计算结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">0 + list[0] + list[1] + list[2] + ...</div></pre></td></tr></table></figure>\n<p>规约也可以完成其它操作，比如求最小值、最大值和乘积等等。如果操作符具有可结合性（associative），那么规约操作就可以容易的被并行化。所以，与其支持一个本质上是并行而且容易导致race condition的操作，我们选择在库中提供一个更加并行友好且不容易出错的方式来进行累积（accumulation）。</p>\n<p>##方法引用</p>\n<p>lambda表达式允许我们定义一个匿名方法，并允许我们以函数式接口的方式使用它。我们也希望能够在已有的方法上实现同样的特性。</p>\n<p>方法引用和lambda表达式拥有相同的特性（例如，它们都需要一个目标类型，并需要被转化为函数式接口的实例），不过我们并不需要为方法引用提供方法体，我们可以直接通过方法名称引用已有方法。</p>\n<p>以下面的代码为例，假设我们要按照name或age为Person数组进行排序：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Person &#123;</div><div class=\"line\">  private final String name;</div><div class=\"line\">  private final int age;</div><div class=\"line\"></div><div class=\"line\">  public int getAge() &#123; return age; &#125;</div><div class=\"line\">  public String getName() &#123;return name; &#125;</div><div class=\"line\">  ...</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Person[] people = ...</div><div class=\"line\">Comparator&lt;Person&gt; byName = Comparator.comparing(p -&gt; p.getName());</div><div class=\"line\">Arrays.sort(people, byName);</div></pre></td></tr></table></figure>\n<p>在这里我们可以用方法引用代替lambda表达式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Comparator&lt;Person&gt; byName = Comparator.comparing(Person::getName);</div></pre></td></tr></table></figure>\n<p>这里的Person::getName可以被看作为lambda表达式的简写形式。尽管方法引用不一定（比如在这个例子里）会把语法变的更紧凑，但它拥有更明确的语义——如果我们想要调用的方法拥有一个名字，我们就可以通过它的名字直接调用它。</p>\n<p>因为函数式接口的方法参数对应于隐式方法调用时的参数，所以被引用方法签名可以通过放宽类型，装箱以及组织到参数数组中的方式对其参数进行操作，就像在调用实际方法一样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Consumer&lt;Integer&gt; b1 = System::exit;    // void exit(int status)</div><div class=\"line\">Consumer&lt;String[]&gt; b2 = Arrays:sort;    // void sort(Object[] a)</div><div class=\"line\">Consumer&lt;String&gt; b3 = MyProgram::main;  // void main(String... args)</div><div class=\"line\">Runnable r = Myprogram::mapToInt        // void main(String... args)</div></pre></td></tr></table></figure>\n<h2 id=\"方法引用的种类\"><a href=\"#方法引用的种类\" class=\"headerlink\" title=\"方法引用的种类\"></a>方法引用的种类</h2><p>方法引用有很多种，它们的语法如下：</p>\n<p>静态方法引用：ClassName::methodName<br>实例上的实例方法引用：instanceReference::methodName<br>超类上的实例方法引用：super::methodName<br>类型上的实例方法引用：ClassName::methodName<br>构造方法引用：Class::new<br>数组构造方法引用：TypeName[]::new<br>对于静态方法引用，我们需要在类名和方法名之间加入::分隔符，例如Integer::sum。</p>\n<p>对于具体对象上的实例方法引用，我们则需要在对象名和方法名之间加入分隔符：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Set&lt;String&gt; knownNames = ...</div><div class=\"line\">Predicate&lt;String&gt; isKnown = knownNames::contains;</div></pre></td></tr></table></figure>\n<p>这里的隐式lambda表达式（也就是实例方法引用）会从knownNames中捕获String对象，而它的方法体则会通过Set.contains使用该String对象。</p>\n<p>有了实例方法引用，在不同函数式接口之间进行类型转换就变的很方便：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Callable&lt;Path&gt; c = ...</div><div class=\"line\">Privileged&lt;Path&gt; a = c::call;</div></pre></td></tr></table></figure>\n<p>引用任意对象的实例方法则需要在实例方法名称和其所属类型名称间加上分隔符：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Function&lt;String, String&gt; upperfier = String::toUpperCase;</div></pre></td></tr></table></figure>\n<p>这里的隐式lambda表达式（即String::toUpperCase实例方法引用）有一个String参数，这个参数会被toUpperCase方法使用。</p>\n<p>如果类型的实例方法是泛型的，那么我们就需要在::分隔符前提供类型参数，或者（多数情况下）利用目标类型推导出其类型。</p>\n<p>需要注意的是，静态方法引用和类型上的实例方法引用拥有一样的语法。编译器会根据实际情况做出决定。</p>\n<p>一般我们不需要指定方法引用中的参数类型，因为编译器往往可以推导出结果，但如果需要我们也可以显式在::分隔符之前提供参数类型信息。</p>\n<p>和静态方法引用类似，构造方法也可以通过new关键字被直接引用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">SocketImplFactory factory = MySocketImpl::new;</div></pre></td></tr></table></figure>\n<p>如果类型拥有多个构造方法，那么我们就会通过目标类型的方法参数来选择最佳匹配，这里的选择过程和调用构造方法时的选择过程是一样的。</p>\n<p>如果待实例化的类型是泛型的，那么我们可以在类型名称之后提供类型参数，否则编译器则会依照”菱形”构造方法调用时的方式进行推导。</p>\n<p>数组的构造方法引用的语法则比较特殊，为了便于理解，你可以假想存在一个接收int参数的数组构造方法。参考下面的代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">IntFunction&lt;int[]&gt; arrayMaker = int[]::new;</div><div class=\"line\">int[] array = arrayMaker.apply(10) // 创建数组 int[10]</div></pre></td></tr></table></figure></p>\n<h2 id=\"默认方法和静态接口方法\"><a href=\"#默认方法和静态接口方法\" class=\"headerlink\" title=\"默认方法和静态接口方法\"></a>默认方法和静态接口方法</h2><p>lambda表达式和方法引用大大提升了Java的表达能力（expressiveness），不过为了使把代码即数据（code-as-data）变的更加容易，我们需要把这些特性融入到已有的库之中，以便开发者使用。</p>\n<p>Java SE 7时代为一个已有的类库增加功能是非常困难的。具体的说，接口在发布之后就已经被定型，除非我们能够一次性更新所有该接口的实现，否则向接口添加方法就会破坏现有的接口实现。默认方法（之前被称为虚拟扩展方法或守护方法）的目标即是解决这个问题，使得接口在发布之后仍能被逐步演化。</p>\n<p>这里给出一个例子，我们需要在标准集合API中增加针对lambda的方法。例如removeAll方法应该被泛化为接收一个函数式接口Predicate，但这个新的方法应该被放在哪里呢？我们无法直接在Collection接口上新增方法——不然就会破坏现有的Collection实现。我们倒是可以在Collections工具类中增加对应的静态方法，但这样就会把这个方法置于“二等公民”的境地。</p>\n<p>默认方法利用面向对象的方式向接口增加新的行为。它是一种新的方法：接口方法可以是抽象的或是默认的。默认方法拥有其默认实现，实现接口的类型通过继承得到该默认实现（如果类型没有覆盖该默认实现）。此外，默认方法不是抽象方法，所以我们可以放心的向函数式接口里增加默认方法，而不用担心函数式接口的单抽象方法限制。</p>\n<p>下面的例子展示了如何向Iterator接口增加默认方法skip：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">interface Iterator&lt;E&gt; &#123;</div><div class=\"line\">  boolean hasNext();</div><div class=\"line\">  E next();</div><div class=\"line\">  void remove();</div><div class=\"line\"></div><div class=\"line\">  default void skip(int i) &#123;</div><div class=\"line\">    for ( ; i &gt; 0 &amp;&amp; hasNext(); i -= 1) next();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>根据上面的Iterator定义，所有实现Iterator的类型都会自动继承skip方法。在使用者的眼里，skip不过是接口新增的一个虚拟方法。在没有覆盖skip方法的Iterator子类实例上调用skip会执行skip的默认实现：调用hasNext和next若干次。子类可以通过覆盖skip来提供更好的实现——比如直接移动游标（cursor），或是提供为操作提供原子性（Atomicity）等。</p>\n<p>当接口继承其它接口时，我们既可以为它所继承而来的抽象方法提供一个默认实现，也可以为它继承而来的默认方法提供一个新的实现，还可以把它继承而来的默认方法重新抽象化。</p>\n<p>除了默认方法，Java SE 8还在允许在接口中定义静态方法。这使得我们可以从接口直接调用和它相关的辅助方法（Helper method），而不是从其它的类中调用（之前这样的类往往以对应接口的复数命名，例如Collections）。比如，我们一般需要使用静态辅助方法生成实现Comparator的比较器，在Java SE 8中我们可以直接把该静态方法定义在Comparator接口中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static &lt;T, U extends Comparable&lt;? super U&gt;&gt;</div><div class=\"line\">    Comparator&lt;T&gt; comparing(Function&lt;T, U&gt; keyExtractor) &#123;</div><div class=\"line\">  return (c1, c2) -&gt; keyExtractor.apply(c1).compareTo(keyExtractor.apply(c2));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"继承默认方法\"><a href=\"#继承默认方法\" class=\"headerlink\" title=\"继承默认方法\"></a>继承默认方法</h2><p>和其它方法一样，默认方法也可以被继承，大多数情况下这种继承行为和我们所期待的一致。不过，当类型或者接口的超类拥有多个具有相同签名的方法时，我们就需要一套规则来解决这个冲突：</p>\n<p>类的方法（class method）声明优先于接口默认方法。无论该方法是具体的还是抽象的。<br>被其它类型所覆盖的方法会被忽略。这条规则适用于超类型共享一个公共祖先的情况。<br>为了演示第二条规则，我们假设Collection和List接口均提供了removeAll的默认实现，然后Queue继承并覆盖了Collection中的默认方法。在下面的implement从句中，List中的方法声明会优先于Queue中的方法声明：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">class LinkedList&lt;E&gt; implements List&lt;E&gt;, Queue&lt;E&gt; &#123; ... &#125;</div></pre></td></tr></table></figure>\n<p>当两个独立的默认方法相冲突或是默认方法和抽象方法相冲突时会产生编译错误。这时程序员需要显式覆盖超类方法。一般来说我们会定义一个默认方法，然后在其中显式选择超类方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">interface Robot implements Artist, Gun &#123;</div><div class=\"line\">  default void draw() &#123; Artist.super.draw(); &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>super前面的类型必须是有定义或继承默认方法的类型。这种方法调用并不只限于消除命名冲突——我们也可以在其它场景中使用它。</p>\n<p>最后，接口在inherits和extends从句中的声明顺序和它们被实现的顺序无关。</p>\n<h2 id=\"融会贯通\"><a href=\"#融会贯通\" class=\"headerlink\" title=\"融会贯通\"></a>融会贯通</h2><p>我们在设计lambda时的一个重要目标就是新增的语言特性和库特性能够无缝结合（designed to work together）。接下来，我们通过一个实际例子（按照姓对名字列表进行排序）来演示这一点：</p>\n<p>比如说下面的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">List&lt;Person&gt; people = ...</div><div class=\"line\">Collections.sort(people, new Comparator&lt;Person&gt;() &#123;</div><div class=\"line\">  public int compare(Person x, Person y) &#123;</div><div class=\"line\">    return x.getLastName().compareTo(y.getLastName());</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>冗余代码实在太多了！</p>\n<p>有了lambda表达式，我们可以去掉冗余的匿名类：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Collections.sort(people,</div><div class=\"line\">                 (Person x, Person y) -&gt; x.getLastName().compareTo(y.getLastName()));</div></pre></td></tr></table></figure>\n<p>尽管代码简洁了很多，但它的抽象程度依然很差：开发者仍然需要进行实际的比较操作（而且如果比较的值是原始类型那么情况会更糟），所以我们要借助Comparator里的comparing方法实现比较操作：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Collections.sort(people, Comparator.comparing((Person p) -&gt; p.getLastName()));</div></pre></td></tr></table></figure>\n<p>在类型推导和静态导入的帮助下，我们可以进一步简化上面的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Collections.sort(people, comparing(p -&gt; p.getLastName()));</div></pre></td></tr></table></figure>\n<p>我们注意到这里的lambda表达式实际上是getLastName的代理（forwarder），于是我们可以用方法引用代替它：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">Collections.sort(people, comparing(Person::getLastName));</div></pre></td></tr></table></figure></p>\n<p>最后，使用Collections.sort这样的辅助方法并不是一个好主意：它不但使代码变的冗余，也无法为实现List接口的数据结构提供特定（specialized）的高效实现，而且由于Collections.sort方法不属于List接口，用户在阅读List接口的文档时不会察觉在另外的Collections类中还有一个针对List接口的排序（sort()）方法。</p>\n<p>默认方法可以有效的解决这个问题，我们为List增加默认方法sort()，然后就可以这样调用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">people.sort(comparing(Person::getLastName));;</div></pre></td></tr></table></figure>\n<p>此外，如果我们为Comparator接口增加一个默认方法reversed()（产生一个逆序比较器），我们就可以非常容易的在前面代码的基础上实现降序排序。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">people.sort(comparing(Person::getLastName).reversed());;</div></pre></td></tr></table></figure>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>Java SE 8提供的新语言特性并不算多——lambda表达式，方法引用，默认方法和静态接口方法，以及范围更广的类型推导。但是把它们结合在一起之后，开发者可以编写出更加清晰简洁的代码，类库编写者可以编写更加强大易用的并行类库。</p>\n"},{"title":"Tomcat性能调优","toc":true,"date":"2016-12-04T16:00:00.000Z","_content":"\n### 一、总结前一天的学习\n我们得知了决定性能测试的几个重要指标，它们是：\n-    吞吐量\n-    Responsetime\n-    Cpuload\n-    MemoryUsage\n我们也在第三天的学习中对Apache做过了一定的优化，使其最优化上述4大核心指标的读数，那么我们的Apache调优了，我们的Tomcat也作些相应的调整，当完成今的课程后，到时你的“小猫”到时真的会“飞”起来的，所以请用心看完，这篇文章向那位曾写过“Tomcat如何承受1000个用户”的作都的敬，一方面又是这篇原文的一个扩展，因为在把原文的知识用到相关的两个大工程中去后解决了：\n1. 承受更大并发用户数\n1. 取得了良好的性能与改善（系统平均性能提升达20倍，极端一个交易达80倍）。\n另外值的一提的是，我们当时工程里用的“小猫”是跑在32位机下的， 也就是我们的JVM最大受到2GB内存的限制，都已经跑成“飞”了。。。。。。如果在64位机下跑这头“小猫”。。。。。。大家可想而知，会得到什么样的效果呢？下面就请请详细的设置吧！\n\n### 二、一切基于JVM（内存）的优化\n#### 32位操作系统与64位操作系统中JVM的对比\n我们一般的开发人员，基本用的是都是32位的Windows系统，这就导致了一个严重的问题即：32位windows系统对内存限制，下面先来看一个比较的表格：\n\n操作系统\n操作系统位数\n内存限制\n解决办法\nWinxp\n32\n4GB\n超级兔子\nWin7\n32\n4GB\n可以通过设置/PAE\nWin2003\n32\n可以突破4GB达16GB\n必需要装win2003 advanced server且要打上sp2补丁\nWin7\n64\n无限制\n机器能插多少内存，系统内存就能支持到多大\nWin2003\n64\n无限制\n机器能插多少内存，系统内存就能支持到多大\nLinux\n64\n无限制\n机器能插多少内存，系统内存就能支持到多大\nUnix\n64\n无限制\n机器能插多少内存，系统内存就能支持到多大\n上述问题解决后，我们又碰到一个新的问题，32位系统下JVM对内存的限制：不能突破2GB内存，即使你在Win2003 Advanced Server下你的机器装有8GB-16GB的内存，而你的Java，只能用到2GB的内存。\n其实我一直很想推荐大家使用Linux或者是Mac操作系统的，而且要装64位，因为必竟我们是开发用的不是打游戏用的，而Java源自Unix归于Unix（Linux只是运行在PC上的Unix而己）。\n所以很多开发人员运行在win32位系统上更有甚者在生产环境下都会布署win32位的系统，那么这时你的Tomcat要优化，就要讲究点技巧了。而在64位操作系统上无论是系统内存还是JVM都没有受到2GB这样的限制。\nTomcat的优化分成两块：\nü   Tomcat启动命令行中的优化参数即JVM优化\nü   Tomcat容器自身参数的优化（这块很像ApacheHttp Server）\n这一节先要讲的是Tomcat启动命令行中的优化参数。\nTomcat首先跑在JVM之上的，因为它的启动其实也只是一个java命令行，首先我们需要对这个JAVA的启动命令行进行调优。\n需要注意的是：\n这边讨论的JVM优化是基于Oracle Sun的jdk1.6版有以上，其它JDK或者低版本JDK不适用。\n#### Tomcat启动行参数的优化\nTomcat 的启动参数位于tomcat的安装目录\\bin目录下，如果你是Linux操作系统就是catalina.sh文件，如果你是Windows操作系统那么你需要改动的就是catalina.bat文件。打开该文件，一般该文件头部是一堆的由##包裹着的注释文字，找到注释文字的最后一段如：\n\n敲入一个回车，加入如下的参数\n**Linux系统中tomcat的启动参数**\n\n```\nexport JAVA_OPTS=\"-server -Xms1400M -Xmx1400M -Xss512k -XX:+AggressiveOpts -XX:+UseBiasedLocking -XX:PermSize=128M -XX:MaxPermSize=256M -XX:+DisableExplicitGC -XX:MaxTenuringThreshold=31 -XX:+UseConcMarkSweepGC -XX:+UseParNewGC  -XX:+CMSParallelRemarkEnabled -XX:+UseCMSCompactAtFullCollection -XX:LargePageSizeInBytes=128m  -XX:+UseFastAccessorMethods -XX:+UseCMSInitiatingOccupancyOnly -Djava.awt.headless=true \"\n```\n**Windows系统中tomcat的启动参数**\n```\nset JAVA_OPTS=-server -Xms1400M -Xmx1400M -Xss512k -XX:+AggressiveOpts -XX:+UseBiasedLocking -XX:PermSize=128M -XX:MaxPermSize=256M -XX:+DisableExplicitGC -XX:MaxTenuringThreshold=31 -XX:+UseConcMarkSweepGC -XX:+UseParNewGC  -XX:+CMSParallelRemarkEnabled -XX:+UseCMSCompactAtFullCollection -XX:LargePageSizeInBytes=128m  -XX:+UseFastAccessorMethods -XX:+UseCMSInitiatingOccupancyOnly -Djava.awt.headless=true\n```\n\n上面参数好多啊，可能有人写到现在都没见一个tomcat的启动命令里加了这么多参数，当然，这些参数只是我机器上的，不一定适合你，尤其是参数后的value（值）是需要根据你自己的实际情况来设置的。\n参数解释：\n**ü   -server**\n我不管你什么理由，只要你的tomcat是运行在生产环境中的，这个参数必须给我加上\n因为tomcat默认是以一种叫java –client的模式来运行的，server即意味着你的tomcat是以真实的production的模式在运行的，这也就意味着你的tomcat以server模式运行时将拥有：更大、更高的并发处理能力，更快更强捷的JVM垃圾回收机制，可以获得更多的负载与吞吐量。。。更。。。还有更。。。\nY给我记住啊，要不然这个-server都不加，那是要打屁股了。\n**ü   -Xms–Xmx**\n即JVM内存设置了，把Xms与Xmx两个值设成一样是最优的做法，有人说Xms为最小值，Xmx为最大值不是挺好的，这样设置还比较人性化，科学化。人性？科学？你个头啊。\n大家想一下这样的场景：\n一个系统随着并发数越来越高，它的内存使用情况逐步上升，上升到最高点不能上升了，开始回落，你们不要认为这个回落就是好事情，由其是大起大落，在内存回落时它付出的代价是CPU高速开始运转进行垃圾回收，此时严重的甚至会造成你的系统出现“卡壳”就是你在好好的操作，突然网页像死在那边一样几秒甚至十几秒时间，因为JVM正在进行垃圾回收。\n因此一开始我们就把这两个设成一样，使得Tomcat在启动时就为最大化参数充分利用系统的效率，这个道理和jdbcconnection pool里的minpool size与maxpool size的需要设成一个数量是一样的原理。\n如何知道我的JVM能够使用最大值啊？拍脑袋？不行！\n在设这个最大内存即Xmx值时请先打开一个命令行，键入如下的命令：\n\n看，能够正常显示JDK的版本信息，说明，这个值你能够用。不是说32位系统下最高能够使用2GB内存吗？即：2048m，我们不防来试试\n\n可以吗？不可以！不要说2048m呢，我们小一点，试试1700m如何\n\n嘿嘿，连1700m都不可以，更不要说2048m了呢，2048m只是一个理论数值，这样说吧我这边有几台机器，有的机器-Xmx1800都没问题，有的机器最高只能到-Xmx1500m。\n因此在设这个-Xms与-Xmx值时一定一定记得先这样测试一下，要不然直接加在tomcat启动命令行中你的tomcat就再也起不来了，要飞是飞不了，直接成了一只瘟猫了。\n**ü   –Xmn**\n设置年轻代大小为512m。整个堆大小=年轻代大小 + 年老代大小 + 持久代大小。持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。\n**ü   -Xss**\n是指设定每个线程的堆栈大小。这个就要依据你的程序，看一个线程 大约需要占用多少内存，可能会有多少线程同时运行等。一般不易设置超过1M，要不然容易出现out ofmemory。\n**ü   -XX:+AggressiveOpts**\n作用如其名（aggressive），启用这个参数，则每当JDK版本升级时，你的JVM都会使用最新加入的优化技术（如果有的话）\n**ü   -XX:+UseBiasedLocking**\n启用一个优化了的线程锁，我们知道在我们的appserver，每个http请求就是一个线程，有的请求短有的请求长，就会有请求排队的现象，甚至还会出现线程阻塞，这个优化了的线程锁使得你的appserver内对线程处理自动进行最优调配。\n**ü   -XX:PermSize=128M-XX:MaxPermSize=256M**\nJVM使用-XX:PermSize设置非堆内存初始值，默认是物理内存的1/64；\n在数据量的很大的文件导出时，一定要把这两个值设置上，否则会出现内存溢出的错误。\n由XX:MaxPermSize设置最大非堆内存的大小，默认是物理内存的1/4。\n那么，如果是物理内存4GB，那么64分之一就是64MB，这就是PermSize默认值，也就是永生代内存初始大小；\n四分之一是1024MB，这就是MaxPermSize默认大小。\n**ü   -XX:+DisableExplicitGC**\n在程序代码中不允许有显示的调用”System.gc()”。看到过有两个极品工程中每次在DAO操作结束时手动调用System.gc()一下，觉得这样做好像能够解决它们的out ofmemory问题一样，付出的代价就是系统响应时间严重降低，就和我在关于Xms,Xmx里的解释的原理一样，这样去调用GC导致系统的JVM大起大落，性能不到什么地方去哟！\n**ü   -XX:+UseParNewGC**\n对年轻代采用多线程并行回收，这样收得快。\n**ü   -XX:+UseConcMarkSweepGC**\n即CMS gc，这一特性只有jdk1.5即后续版本才具有的功能，它使用的是gc估算触发和heap占用触发。\n我们知道频频繁的GC会造面JVM的大起大落从而影响到系统的效率，因此使用了CMS GC后可以在GC次数增多的情况下，每次GC的响应时间却很短，比如说使用了CMS GC后经过jprofiler的观察，GC被触发次数非常多，而每次GC耗时仅为几毫秒。\n**ü   -XX:MaxTenuringThreshold**\n设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概率。\n这个值的设置是根据本地的jprofiler监控后得到的一个理想的值，不能一概而论原搬照抄。\n**ü   -XX:+CMSParallelRemarkEnabled**\n在使用UseParNewGC 的情况下, 尽量减少 mark 的时间\nü   -XX:+UseCMSCompactAtFullCollection\n在使用concurrent gc 的情况下, 防止 memoryfragmention, 对live object 进行整理, 使 memory 碎片减少。\nü   -XX:LargePageSizeInBytes\n指定 Java heap的分页页面大小\nü   -XX:+UseFastAccessorMethods\nget,set 方法转成本地代码\nü   -XX:+UseCMSInitiatingOccupancyOnly\n指示只有在 oldgeneration 在使用了初始化的比例后concurrent collector 启动收集\nü   -XX:CMSInitiatingOccupancyFraction=70\nCMSInitiatingOccupancyFraction，这个参数设置有很大技巧，基本上满足(Xmx-Xmn)*(100- CMSInitiatingOccupancyFraction)/100>=Xmn就不会出现promotion failed。在我的应用中Xmx是6000，Xmn是512，那么Xmx-Xmn是5488兆，也就是年老代有5488 兆，CMSInitiatingOccupancyFraction=90说明年老代到90%满的时候开始执行对年老代的并发垃圾回收（CMS），这时还 剩10%的空间是5488*10%=548兆，所以即使Xmn（也就是年轻代共512兆）里所有对象都搬到年老代里，548兆的空间也足够了，所以只要满 足上面的公式，就不会出现垃圾回收时的promotion failed；\n因此这个参数的设置必须与Xmn关联在一起。\nü   -Djava.awt.headless=true\n这个参数一般我们都是放在最后使用的，这全参数的作用是这样的，有时我们会在我们的J2EE工程中使用一些图表工具如：jfreechart，用于在web网页输出GIF/JPG等流，在winodws环境下，一般我们的app server在输出图形时不会碰到什么问题，但是在linux/unix环境下经常会碰到一个exception导致你在winodws开发环境下图片显示的好好可是在linux/unix下却显示不出来，因此加上这个参数以免避这样的情况出现。\n上述这样的配置，基本上可以达到：\n- ü   系统响应时间增快\n- ü   JVM回收速度增快同时又不影响系统的响应率\n- ü   JVM内存最大化利用\n- ü   线程阻塞情况最小化\n- 2.3 Tomcat容器内的优化\n前面我们对Tomcat启动时的命令进行了优化，增加了系统的JVM可使用数、垃圾回收效率与线程阻塞情况、增加了系统响应效率等还有一个很重要的指标，我们没有去做优化，就是吞吐量。\n还记得我们在第三天的学习中说的，这个系统本身可以处理1000，你没有优化和配置导致它默认只能处理25。因此下面我们来看Tomcat容器内的优化。\n打开tomcat安装目录\\conf\\server.xml文件，定位到这一行：\n\n```\n< Connector port=\"8080\" protocol=\"HTTP/1.1\"\n```\n这一行就是我们的tomcat容器性能参数设置的地方，它一般都会有一个默认值，这些默认值是远远不够我们的使用的，我们来看经过更改后的这一段的配置：\n```\n< Connector port=\"8080\" protocol=\"HTTP/1.1\"\n          URIEncoding=\"UTF-8\"  minSpareThreads=\"25\" maxSpareThreads=\"75\"\n          enableLookups=\"false\" disableUploadTimeout=\"true\" connectionTimeout=\"20000\"\n          acceptCount=\"300\"  maxThreads=\"300\" maxProcessors=\"1000\" minProcessors=\"5\"\n          useURIValidationHack=\"false\"\n                                               compression=\"on\" compressionMinSize=\"2048\"\n                                               compressableMimeType=\"text/html,text/xml,text/JavaScript,text/css,text/plain\"\n               redirectPort=\"8443\"\n/>\n```\n\n好大一陀唉。。。。。。\n没关系，一个个来解释\nü   URIEncoding=”UTF-8”\n使得tomcat可以解析含有中文名的文件的url，真方便，不像apache里还有搞个mod_encoding，还要手工编译\nü   maxSpareThreads\nmaxSpareThreads 的意思就是如果空闲状态的线程数多于设置的数目，则将这些线程中止，减少这个池中的线程总数。\nü   minSpareThreads\n最小备用线程数，tomcat启动时的初始化的线程数。\nü   enableLookups\n这个功效和Apache中的HostnameLookups一样，设为关闭。\nü   connectionTimeout\nconnectionTimeout为网络连接超时时间毫秒数。\nü   maxThreads\nmaxThreads Tomcat使用线程来处理接收的每个请求。这个值表示Tomcat可创建的最大的线程数，即最大并发数。\n\nü   acceptCount\nacceptCount是当线程数达到maxThreads后，后续请求会被放入一个等待队列，这个acceptCount是这个队列的大小，如果这个队列也满了，就直接refuse connection\n\nü   maxProcessors与minProcessors\n在 Java中线程是程序运行时的路径，是在一个程序中与其它控制线程无关的、能够独立运行的代码段。它们共享相同的地址空间。多线程帮助程序员写出CPU最 大利用率的高效程序，使空闲时间保持最低，从而接受更多的请求。\n通常Windows是1000个左右，Linux是2000个左右。\nü   useURIValidationHack\n我们来看一下tomcat中的一段源码：\n```\nsecurity\n        if (connector.getUseURIValidationHack()) {\n            String uri = validate(request.getRequestURI());\n            if (uri == null) {\n                res.setStatus(400);\n                res.setMessage(\"Invalid URI\");\n                throw new IOException(\"Invalid URI\");\n            } else {\n                req.requestURI().setString(uri);\n                // Redoing the URI decoding\n                req.decodedURI().duplicate(req.requestURI());\n                req.getURLDecoder().convert(req.decodedURI(), true);\n            }\n        }\n```\n可以看到如果把useURIValidationHack设成\"false\"，可以减少它对一些url的不必要的检查从而减省开销。\nü   enableLookups=\"false\"\n为了消除DNS查询对性能的影响我们可以关闭DNS查询，方式是修改server.xml文件中的enableLookups参数值。\nü   disableUploadTimeout\n类似于Apache中的keeyalive一样\nü   给Tomcat配置gzip压缩(HTTP压缩)功能\ncompression=\"on\" compressionMinSize=\"2048\"             \ncompressableMimeType=\"text/html,text/xml,text/javascript,text/css,text/plain\"\nHTTP 压缩可以大大提高浏览网站的速度，它的原理是，在客户端请求网页后，从服务器端将网页文件压缩，再下载到客户端，由客户端的浏览器负责解压缩并浏览。相对于普通的浏览过程HTML,CSS,Javascript , Text ，它可以节省40%左右的流量。更为重要的是，它可以对动态生成的，包括CGI、PHP , JSP , ASP , Servlet,SHTML等输出的网页也能进行压缩，压缩效率惊人。\n1. compression=\"on\" 打开压缩功能\n1. compressionMinSize=\"2048\" 启用压缩的输出内容大小，这里面默认为2KB\n1. noCompressionUserAgents=\"gozilla, traviata\" 对于以下的浏览器，不启用压缩\n1. compressableMimeType=\"text/html,text/xml\"　压缩类型\n\n最后不要忘了把8443端口的地方也加上同样的配置，因为如果我们走https协议的话，我们将会用到8443端口这个段的配置，对吧？\n```\n<!--enable tomcat ssl-->\n    <Connector port=\"8443\" protocol=\"HTTP/1.1\"\n               URIEncoding=\"UTF-8\"  minSpareThreads=\"25\" maxSpareThreads=\"75\"\n          enableLookups=\"false\" disableUploadTimeout=\"true\" connectionTimeout=\"20000\"\n          acceptCount=\"300\"  maxThreads=\"300\" maxProcessors=\"1000\" minProcessors=\"5\"\n          useURIValidationHack=\"false\"\n                    compression=\"on\" compressionMinSize=\"2048\"\n                    compressableMimeType=\"text/html,text/xml,text/javascript,text/css,text/plain\"\n                SSLEnabled=\"true\"\n           scheme=\"https\" secure=\"true\"\n           clientAuth=\"false\" sslProtocol=\"TLS\"\n           keystoreFile=\"d:/tomcat2/conf/shnlap93.jks\" keystorePass=\"aaaaaa\"\n      />\n```\n好了，所有的Tomcat优化的地方都加上了。结合第三天中的Apache的性能优化，我们这个架构可以“飞奔”起来了，当然这边把有提及任何关于数据库优化的步骤，但仅凭这两步，我们的系统已经有了很大的提升。\n举个真实的例子：上一个项目，经过4轮performance testing，第一轮进行了问题的定位，第二轮就是进行了apache+tomcat/weblogic的优化，第三轮是做集群优化，第四轮是sql与codes的优化。\n在到达第二轮时，我们的性能已经提升了多少倍呢？我们来看一个loaderrunner的截图吧：\n\n左边第一列是第一轮没有经过任何调优的压力测试报告。\n右边这一列是经过了apache优化，tomcat优化后得到的压力测试报告。\n大家看看，这就提高了多少倍？这还只是在没有改动代码的情况下得到的改善，现在明白了好好的调优一\n个apache和tomcat其实是多么的重要了？如果加上后面的代码、SQL的调优、数据库的调优。。。。。。所以我在上一个工程中有单笔交易性能（无论是吞吐量、响应时间）提高了80倍这样的极端例子的存在。","source":"_posts/Tomcat_performance_optimization.md","raw":"\n---\ntitle: Tomcat性能调优\ntags: Tomcat\ncategories: Java\ntoc: true\ndate: 2016-12-05\n\n---\n\n### 一、总结前一天的学习\n我们得知了决定性能测试的几个重要指标，它们是：\n-    吞吐量\n-    Responsetime\n-    Cpuload\n-    MemoryUsage\n我们也在第三天的学习中对Apache做过了一定的优化，使其最优化上述4大核心指标的读数，那么我们的Apache调优了，我们的Tomcat也作些相应的调整，当完成今的课程后，到时你的“小猫”到时真的会“飞”起来的，所以请用心看完，这篇文章向那位曾写过“Tomcat如何承受1000个用户”的作都的敬，一方面又是这篇原文的一个扩展，因为在把原文的知识用到相关的两个大工程中去后解决了：\n1. 承受更大并发用户数\n1. 取得了良好的性能与改善（系统平均性能提升达20倍，极端一个交易达80倍）。\n另外值的一提的是，我们当时工程里用的“小猫”是跑在32位机下的， 也就是我们的JVM最大受到2GB内存的限制，都已经跑成“飞”了。。。。。。如果在64位机下跑这头“小猫”。。。。。。大家可想而知，会得到什么样的效果呢？下面就请请详细的设置吧！\n\n### 二、一切基于JVM（内存）的优化\n#### 32位操作系统与64位操作系统中JVM的对比\n我们一般的开发人员，基本用的是都是32位的Windows系统，这就导致了一个严重的问题即：32位windows系统对内存限制，下面先来看一个比较的表格：\n\n操作系统\n操作系统位数\n内存限制\n解决办法\nWinxp\n32\n4GB\n超级兔子\nWin7\n32\n4GB\n可以通过设置/PAE\nWin2003\n32\n可以突破4GB达16GB\n必需要装win2003 advanced server且要打上sp2补丁\nWin7\n64\n无限制\n机器能插多少内存，系统内存就能支持到多大\nWin2003\n64\n无限制\n机器能插多少内存，系统内存就能支持到多大\nLinux\n64\n无限制\n机器能插多少内存，系统内存就能支持到多大\nUnix\n64\n无限制\n机器能插多少内存，系统内存就能支持到多大\n上述问题解决后，我们又碰到一个新的问题，32位系统下JVM对内存的限制：不能突破2GB内存，即使你在Win2003 Advanced Server下你的机器装有8GB-16GB的内存，而你的Java，只能用到2GB的内存。\n其实我一直很想推荐大家使用Linux或者是Mac操作系统的，而且要装64位，因为必竟我们是开发用的不是打游戏用的，而Java源自Unix归于Unix（Linux只是运行在PC上的Unix而己）。\n所以很多开发人员运行在win32位系统上更有甚者在生产环境下都会布署win32位的系统，那么这时你的Tomcat要优化，就要讲究点技巧了。而在64位操作系统上无论是系统内存还是JVM都没有受到2GB这样的限制。\nTomcat的优化分成两块：\nü   Tomcat启动命令行中的优化参数即JVM优化\nü   Tomcat容器自身参数的优化（这块很像ApacheHttp Server）\n这一节先要讲的是Tomcat启动命令行中的优化参数。\nTomcat首先跑在JVM之上的，因为它的启动其实也只是一个java命令行，首先我们需要对这个JAVA的启动命令行进行调优。\n需要注意的是：\n这边讨论的JVM优化是基于Oracle Sun的jdk1.6版有以上，其它JDK或者低版本JDK不适用。\n#### Tomcat启动行参数的优化\nTomcat 的启动参数位于tomcat的安装目录\\bin目录下，如果你是Linux操作系统就是catalina.sh文件，如果你是Windows操作系统那么你需要改动的就是catalina.bat文件。打开该文件，一般该文件头部是一堆的由##包裹着的注释文字，找到注释文字的最后一段如：\n\n敲入一个回车，加入如下的参数\n**Linux系统中tomcat的启动参数**\n\n```\nexport JAVA_OPTS=\"-server -Xms1400M -Xmx1400M -Xss512k -XX:+AggressiveOpts -XX:+UseBiasedLocking -XX:PermSize=128M -XX:MaxPermSize=256M -XX:+DisableExplicitGC -XX:MaxTenuringThreshold=31 -XX:+UseConcMarkSweepGC -XX:+UseParNewGC  -XX:+CMSParallelRemarkEnabled -XX:+UseCMSCompactAtFullCollection -XX:LargePageSizeInBytes=128m  -XX:+UseFastAccessorMethods -XX:+UseCMSInitiatingOccupancyOnly -Djava.awt.headless=true \"\n```\n**Windows系统中tomcat的启动参数**\n```\nset JAVA_OPTS=-server -Xms1400M -Xmx1400M -Xss512k -XX:+AggressiveOpts -XX:+UseBiasedLocking -XX:PermSize=128M -XX:MaxPermSize=256M -XX:+DisableExplicitGC -XX:MaxTenuringThreshold=31 -XX:+UseConcMarkSweepGC -XX:+UseParNewGC  -XX:+CMSParallelRemarkEnabled -XX:+UseCMSCompactAtFullCollection -XX:LargePageSizeInBytes=128m  -XX:+UseFastAccessorMethods -XX:+UseCMSInitiatingOccupancyOnly -Djava.awt.headless=true\n```\n\n上面参数好多啊，可能有人写到现在都没见一个tomcat的启动命令里加了这么多参数，当然，这些参数只是我机器上的，不一定适合你，尤其是参数后的value（值）是需要根据你自己的实际情况来设置的。\n参数解释：\n**ü   -server**\n我不管你什么理由，只要你的tomcat是运行在生产环境中的，这个参数必须给我加上\n因为tomcat默认是以一种叫java –client的模式来运行的，server即意味着你的tomcat是以真实的production的模式在运行的，这也就意味着你的tomcat以server模式运行时将拥有：更大、更高的并发处理能力，更快更强捷的JVM垃圾回收机制，可以获得更多的负载与吞吐量。。。更。。。还有更。。。\nY给我记住啊，要不然这个-server都不加，那是要打屁股了。\n**ü   -Xms–Xmx**\n即JVM内存设置了，把Xms与Xmx两个值设成一样是最优的做法，有人说Xms为最小值，Xmx为最大值不是挺好的，这样设置还比较人性化，科学化。人性？科学？你个头啊。\n大家想一下这样的场景：\n一个系统随着并发数越来越高，它的内存使用情况逐步上升，上升到最高点不能上升了，开始回落，你们不要认为这个回落就是好事情，由其是大起大落，在内存回落时它付出的代价是CPU高速开始运转进行垃圾回收，此时严重的甚至会造成你的系统出现“卡壳”就是你在好好的操作，突然网页像死在那边一样几秒甚至十几秒时间，因为JVM正在进行垃圾回收。\n因此一开始我们就把这两个设成一样，使得Tomcat在启动时就为最大化参数充分利用系统的效率，这个道理和jdbcconnection pool里的minpool size与maxpool size的需要设成一个数量是一样的原理。\n如何知道我的JVM能够使用最大值啊？拍脑袋？不行！\n在设这个最大内存即Xmx值时请先打开一个命令行，键入如下的命令：\n\n看，能够正常显示JDK的版本信息，说明，这个值你能够用。不是说32位系统下最高能够使用2GB内存吗？即：2048m，我们不防来试试\n\n可以吗？不可以！不要说2048m呢，我们小一点，试试1700m如何\n\n嘿嘿，连1700m都不可以，更不要说2048m了呢，2048m只是一个理论数值，这样说吧我这边有几台机器，有的机器-Xmx1800都没问题，有的机器最高只能到-Xmx1500m。\n因此在设这个-Xms与-Xmx值时一定一定记得先这样测试一下，要不然直接加在tomcat启动命令行中你的tomcat就再也起不来了，要飞是飞不了，直接成了一只瘟猫了。\n**ü   –Xmn**\n设置年轻代大小为512m。整个堆大小=年轻代大小 + 年老代大小 + 持久代大小。持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。\n**ü   -Xss**\n是指设定每个线程的堆栈大小。这个就要依据你的程序，看一个线程 大约需要占用多少内存，可能会有多少线程同时运行等。一般不易设置超过1M，要不然容易出现out ofmemory。\n**ü   -XX:+AggressiveOpts**\n作用如其名（aggressive），启用这个参数，则每当JDK版本升级时，你的JVM都会使用最新加入的优化技术（如果有的话）\n**ü   -XX:+UseBiasedLocking**\n启用一个优化了的线程锁，我们知道在我们的appserver，每个http请求就是一个线程，有的请求短有的请求长，就会有请求排队的现象，甚至还会出现线程阻塞，这个优化了的线程锁使得你的appserver内对线程处理自动进行最优调配。\n**ü   -XX:PermSize=128M-XX:MaxPermSize=256M**\nJVM使用-XX:PermSize设置非堆内存初始值，默认是物理内存的1/64；\n在数据量的很大的文件导出时，一定要把这两个值设置上，否则会出现内存溢出的错误。\n由XX:MaxPermSize设置最大非堆内存的大小，默认是物理内存的1/4。\n那么，如果是物理内存4GB，那么64分之一就是64MB，这就是PermSize默认值，也就是永生代内存初始大小；\n四分之一是1024MB，这就是MaxPermSize默认大小。\n**ü   -XX:+DisableExplicitGC**\n在程序代码中不允许有显示的调用”System.gc()”。看到过有两个极品工程中每次在DAO操作结束时手动调用System.gc()一下，觉得这样做好像能够解决它们的out ofmemory问题一样，付出的代价就是系统响应时间严重降低，就和我在关于Xms,Xmx里的解释的原理一样，这样去调用GC导致系统的JVM大起大落，性能不到什么地方去哟！\n**ü   -XX:+UseParNewGC**\n对年轻代采用多线程并行回收，这样收得快。\n**ü   -XX:+UseConcMarkSweepGC**\n即CMS gc，这一特性只有jdk1.5即后续版本才具有的功能，它使用的是gc估算触发和heap占用触发。\n我们知道频频繁的GC会造面JVM的大起大落从而影响到系统的效率，因此使用了CMS GC后可以在GC次数增多的情况下，每次GC的响应时间却很短，比如说使用了CMS GC后经过jprofiler的观察，GC被触发次数非常多，而每次GC耗时仅为几毫秒。\n**ü   -XX:MaxTenuringThreshold**\n设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概率。\n这个值的设置是根据本地的jprofiler监控后得到的一个理想的值，不能一概而论原搬照抄。\n**ü   -XX:+CMSParallelRemarkEnabled**\n在使用UseParNewGC 的情况下, 尽量减少 mark 的时间\nü   -XX:+UseCMSCompactAtFullCollection\n在使用concurrent gc 的情况下, 防止 memoryfragmention, 对live object 进行整理, 使 memory 碎片减少。\nü   -XX:LargePageSizeInBytes\n指定 Java heap的分页页面大小\nü   -XX:+UseFastAccessorMethods\nget,set 方法转成本地代码\nü   -XX:+UseCMSInitiatingOccupancyOnly\n指示只有在 oldgeneration 在使用了初始化的比例后concurrent collector 启动收集\nü   -XX:CMSInitiatingOccupancyFraction=70\nCMSInitiatingOccupancyFraction，这个参数设置有很大技巧，基本上满足(Xmx-Xmn)*(100- CMSInitiatingOccupancyFraction)/100>=Xmn就不会出现promotion failed。在我的应用中Xmx是6000，Xmn是512，那么Xmx-Xmn是5488兆，也就是年老代有5488 兆，CMSInitiatingOccupancyFraction=90说明年老代到90%满的时候开始执行对年老代的并发垃圾回收（CMS），这时还 剩10%的空间是5488*10%=548兆，所以即使Xmn（也就是年轻代共512兆）里所有对象都搬到年老代里，548兆的空间也足够了，所以只要满 足上面的公式，就不会出现垃圾回收时的promotion failed；\n因此这个参数的设置必须与Xmn关联在一起。\nü   -Djava.awt.headless=true\n这个参数一般我们都是放在最后使用的，这全参数的作用是这样的，有时我们会在我们的J2EE工程中使用一些图表工具如：jfreechart，用于在web网页输出GIF/JPG等流，在winodws环境下，一般我们的app server在输出图形时不会碰到什么问题，但是在linux/unix环境下经常会碰到一个exception导致你在winodws开发环境下图片显示的好好可是在linux/unix下却显示不出来，因此加上这个参数以免避这样的情况出现。\n上述这样的配置，基本上可以达到：\n- ü   系统响应时间增快\n- ü   JVM回收速度增快同时又不影响系统的响应率\n- ü   JVM内存最大化利用\n- ü   线程阻塞情况最小化\n- 2.3 Tomcat容器内的优化\n前面我们对Tomcat启动时的命令进行了优化，增加了系统的JVM可使用数、垃圾回收效率与线程阻塞情况、增加了系统响应效率等还有一个很重要的指标，我们没有去做优化，就是吞吐量。\n还记得我们在第三天的学习中说的，这个系统本身可以处理1000，你没有优化和配置导致它默认只能处理25。因此下面我们来看Tomcat容器内的优化。\n打开tomcat安装目录\\conf\\server.xml文件，定位到这一行：\n\n```\n< Connector port=\"8080\" protocol=\"HTTP/1.1\"\n```\n这一行就是我们的tomcat容器性能参数设置的地方，它一般都会有一个默认值，这些默认值是远远不够我们的使用的，我们来看经过更改后的这一段的配置：\n```\n< Connector port=\"8080\" protocol=\"HTTP/1.1\"\n          URIEncoding=\"UTF-8\"  minSpareThreads=\"25\" maxSpareThreads=\"75\"\n          enableLookups=\"false\" disableUploadTimeout=\"true\" connectionTimeout=\"20000\"\n          acceptCount=\"300\"  maxThreads=\"300\" maxProcessors=\"1000\" minProcessors=\"5\"\n          useURIValidationHack=\"false\"\n                                               compression=\"on\" compressionMinSize=\"2048\"\n                                               compressableMimeType=\"text/html,text/xml,text/JavaScript,text/css,text/plain\"\n               redirectPort=\"8443\"\n/>\n```\n\n好大一陀唉。。。。。。\n没关系，一个个来解释\nü   URIEncoding=”UTF-8”\n使得tomcat可以解析含有中文名的文件的url，真方便，不像apache里还有搞个mod_encoding，还要手工编译\nü   maxSpareThreads\nmaxSpareThreads 的意思就是如果空闲状态的线程数多于设置的数目，则将这些线程中止，减少这个池中的线程总数。\nü   minSpareThreads\n最小备用线程数，tomcat启动时的初始化的线程数。\nü   enableLookups\n这个功效和Apache中的HostnameLookups一样，设为关闭。\nü   connectionTimeout\nconnectionTimeout为网络连接超时时间毫秒数。\nü   maxThreads\nmaxThreads Tomcat使用线程来处理接收的每个请求。这个值表示Tomcat可创建的最大的线程数，即最大并发数。\n\nü   acceptCount\nacceptCount是当线程数达到maxThreads后，后续请求会被放入一个等待队列，这个acceptCount是这个队列的大小，如果这个队列也满了，就直接refuse connection\n\nü   maxProcessors与minProcessors\n在 Java中线程是程序运行时的路径，是在一个程序中与其它控制线程无关的、能够独立运行的代码段。它们共享相同的地址空间。多线程帮助程序员写出CPU最 大利用率的高效程序，使空闲时间保持最低，从而接受更多的请求。\n通常Windows是1000个左右，Linux是2000个左右。\nü   useURIValidationHack\n我们来看一下tomcat中的一段源码：\n```\nsecurity\n        if (connector.getUseURIValidationHack()) {\n            String uri = validate(request.getRequestURI());\n            if (uri == null) {\n                res.setStatus(400);\n                res.setMessage(\"Invalid URI\");\n                throw new IOException(\"Invalid URI\");\n            } else {\n                req.requestURI().setString(uri);\n                // Redoing the URI decoding\n                req.decodedURI().duplicate(req.requestURI());\n                req.getURLDecoder().convert(req.decodedURI(), true);\n            }\n        }\n```\n可以看到如果把useURIValidationHack设成\"false\"，可以减少它对一些url的不必要的检查从而减省开销。\nü   enableLookups=\"false\"\n为了消除DNS查询对性能的影响我们可以关闭DNS查询，方式是修改server.xml文件中的enableLookups参数值。\nü   disableUploadTimeout\n类似于Apache中的keeyalive一样\nü   给Tomcat配置gzip压缩(HTTP压缩)功能\ncompression=\"on\" compressionMinSize=\"2048\"             \ncompressableMimeType=\"text/html,text/xml,text/javascript,text/css,text/plain\"\nHTTP 压缩可以大大提高浏览网站的速度，它的原理是，在客户端请求网页后，从服务器端将网页文件压缩，再下载到客户端，由客户端的浏览器负责解压缩并浏览。相对于普通的浏览过程HTML,CSS,Javascript , Text ，它可以节省40%左右的流量。更为重要的是，它可以对动态生成的，包括CGI、PHP , JSP , ASP , Servlet,SHTML等输出的网页也能进行压缩，压缩效率惊人。\n1. compression=\"on\" 打开压缩功能\n1. compressionMinSize=\"2048\" 启用压缩的输出内容大小，这里面默认为2KB\n1. noCompressionUserAgents=\"gozilla, traviata\" 对于以下的浏览器，不启用压缩\n1. compressableMimeType=\"text/html,text/xml\"　压缩类型\n\n最后不要忘了把8443端口的地方也加上同样的配置，因为如果我们走https协议的话，我们将会用到8443端口这个段的配置，对吧？\n```\n<!--enable tomcat ssl-->\n    <Connector port=\"8443\" protocol=\"HTTP/1.1\"\n               URIEncoding=\"UTF-8\"  minSpareThreads=\"25\" maxSpareThreads=\"75\"\n          enableLookups=\"false\" disableUploadTimeout=\"true\" connectionTimeout=\"20000\"\n          acceptCount=\"300\"  maxThreads=\"300\" maxProcessors=\"1000\" minProcessors=\"5\"\n          useURIValidationHack=\"false\"\n                    compression=\"on\" compressionMinSize=\"2048\"\n                    compressableMimeType=\"text/html,text/xml,text/javascript,text/css,text/plain\"\n                SSLEnabled=\"true\"\n           scheme=\"https\" secure=\"true\"\n           clientAuth=\"false\" sslProtocol=\"TLS\"\n           keystoreFile=\"d:/tomcat2/conf/shnlap93.jks\" keystorePass=\"aaaaaa\"\n      />\n```\n好了，所有的Tomcat优化的地方都加上了。结合第三天中的Apache的性能优化，我们这个架构可以“飞奔”起来了，当然这边把有提及任何关于数据库优化的步骤，但仅凭这两步，我们的系统已经有了很大的提升。\n举个真实的例子：上一个项目，经过4轮performance testing，第一轮进行了问题的定位，第二轮就是进行了apache+tomcat/weblogic的优化，第三轮是做集群优化，第四轮是sql与codes的优化。\n在到达第二轮时，我们的性能已经提升了多少倍呢？我们来看一个loaderrunner的截图吧：\n\n左边第一列是第一轮没有经过任何调优的压力测试报告。\n右边这一列是经过了apache优化，tomcat优化后得到的压力测试报告。\n大家看看，这就提高了多少倍？这还只是在没有改动代码的情况下得到的改善，现在明白了好好的调优一\n个apache和tomcat其实是多么的重要了？如果加上后面的代码、SQL的调优、数据库的调优。。。。。。所以我在上一个工程中有单笔交易性能（无论是吞吐量、响应时间）提高了80倍这样的极端例子的存在。","slug":"Tomcat_performance_optimization","published":1,"updated":"2016-12-05T13:12:14.569Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwc5273j0004o8l0qbdy1nrn","content":"<h3 id=\"一、总结前一天的学习\"><a href=\"#一、总结前一天的学习\" class=\"headerlink\" title=\"一、总结前一天的学习\"></a>一、总结前一天的学习</h3><p>我们得知了决定性能测试的几个重要指标，它们是：</p>\n<ul>\n<li>吞吐量</li>\n<li>Responsetime</li>\n<li>Cpuload</li>\n<li>MemoryUsage<br>我们也在第三天的学习中对Apache做过了一定的优化，使其最优化上述4大核心指标的读数，那么我们的Apache调优了，我们的Tomcat也作些相应的调整，当完成今的课程后，到时你的“小猫”到时真的会“飞”起来的，所以请用心看完，这篇文章向那位曾写过“Tomcat如何承受1000个用户”的作都的敬，一方面又是这篇原文的一个扩展，因为在把原文的知识用到相关的两个大工程中去后解决了：</li>\n</ul>\n<ol>\n<li>承受更大并发用户数</li>\n<li>取得了良好的性能与改善（系统平均性能提升达20倍，极端一个交易达80倍）。<br>另外值的一提的是，我们当时工程里用的“小猫”是跑在32位机下的， 也就是我们的JVM最大受到2GB内存的限制，都已经跑成“飞”了。。。。。。如果在64位机下跑这头“小猫”。。。。。。大家可想而知，会得到什么样的效果呢？下面就请请详细的设置吧！</li>\n</ol>\n<h3 id=\"二、一切基于JVM（内存）的优化\"><a href=\"#二、一切基于JVM（内存）的优化\" class=\"headerlink\" title=\"二、一切基于JVM（内存）的优化\"></a>二、一切基于JVM（内存）的优化</h3><h4 id=\"32位操作系统与64位操作系统中JVM的对比\"><a href=\"#32位操作系统与64位操作系统中JVM的对比\" class=\"headerlink\" title=\"32位操作系统与64位操作系统中JVM的对比\"></a>32位操作系统与64位操作系统中JVM的对比</h4><p>我们一般的开发人员，基本用的是都是32位的Windows系统，这就导致了一个严重的问题即：32位windows系统对内存限制，下面先来看一个比较的表格：</p>\n<p>操作系统<br>操作系统位数<br>内存限制<br>解决办法<br>Winxp<br>32<br>4GB<br>超级兔子<br>Win7<br>32<br>4GB<br>可以通过设置/PAE<br>Win2003<br>32<br>可以突破4GB达16GB<br>必需要装win2003 advanced server且要打上sp2补丁<br>Win7<br>64<br>无限制<br>机器能插多少内存，系统内存就能支持到多大<br>Win2003<br>64<br>无限制<br>机器能插多少内存，系统内存就能支持到多大<br>Linux<br>64<br>无限制<br>机器能插多少内存，系统内存就能支持到多大<br>Unix<br>64<br>无限制<br>机器能插多少内存，系统内存就能支持到多大<br>上述问题解决后，我们又碰到一个新的问题，32位系统下JVM对内存的限制：不能突破2GB内存，即使你在Win2003 Advanced Server下你的机器装有8GB-16GB的内存，而你的Java，只能用到2GB的内存。<br>其实我一直很想推荐大家使用Linux或者是Mac操作系统的，而且要装64位，因为必竟我们是开发用的不是打游戏用的，而Java源自Unix归于Unix（Linux只是运行在PC上的Unix而己）。<br>所以很多开发人员运行在win32位系统上更有甚者在生产环境下都会布署win32位的系统，那么这时你的Tomcat要优化，就要讲究点技巧了。而在64位操作系统上无论是系统内存还是JVM都没有受到2GB这样的限制。<br>Tomcat的优化分成两块：<br>ü   Tomcat启动命令行中的优化参数即JVM优化<br>ü   Tomcat容器自身参数的优化（这块很像ApacheHttp Server）<br>这一节先要讲的是Tomcat启动命令行中的优化参数。<br>Tomcat首先跑在JVM之上的，因为它的启动其实也只是一个java命令行，首先我们需要对这个JAVA的启动命令行进行调优。<br>需要注意的是：<br>这边讨论的JVM优化是基于Oracle Sun的jdk1.6版有以上，其它JDK或者低版本JDK不适用。</p>\n<h4 id=\"Tomcat启动行参数的优化\"><a href=\"#Tomcat启动行参数的优化\" class=\"headerlink\" title=\"Tomcat启动行参数的优化\"></a>Tomcat启动行参数的优化</h4><p>Tomcat 的启动参数位于tomcat的安装目录\\bin目录下，如果你是Linux操作系统就是catalina.sh文件，如果你是Windows操作系统那么你需要改动的就是catalina.bat文件。打开该文件，一般该文件头部是一堆的由##包裹着的注释文字，找到注释文字的最后一段如：</p>\n<p>敲入一个回车，加入如下的参数<br><strong>Linux系统中tomcat的启动参数</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">export JAVA_OPTS=&quot;-server -Xms1400M -Xmx1400M -Xss512k -XX:+AggressiveOpts -XX:+UseBiasedLocking -XX:PermSize=128M -XX:MaxPermSize=256M -XX:+DisableExplicitGC -XX:MaxTenuringThreshold=31 -XX:+UseConcMarkSweepGC -XX:+UseParNewGC  -XX:+CMSParallelRemarkEnabled -XX:+UseCMSCompactAtFullCollection -XX:LargePageSizeInBytes=128m  -XX:+UseFastAccessorMethods -XX:+UseCMSInitiatingOccupancyOnly -Djava.awt.headless=true &quot;</div></pre></td></tr></table></figure>\n<p><strong>Windows系统中tomcat的启动参数</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">set JAVA_OPTS=-server -Xms1400M -Xmx1400M -Xss512k -XX:+AggressiveOpts -XX:+UseBiasedLocking -XX:PermSize=128M -XX:MaxPermSize=256M -XX:+DisableExplicitGC -XX:MaxTenuringThreshold=31 -XX:+UseConcMarkSweepGC -XX:+UseParNewGC  -XX:+CMSParallelRemarkEnabled -XX:+UseCMSCompactAtFullCollection -XX:LargePageSizeInBytes=128m  -XX:+UseFastAccessorMethods -XX:+UseCMSInitiatingOccupancyOnly -Djava.awt.headless=true</div></pre></td></tr></table></figure></p>\n<p>上面参数好多啊，可能有人写到现在都没见一个tomcat的启动命令里加了这么多参数，当然，这些参数只是我机器上的，不一定适合你，尤其是参数后的value（值）是需要根据你自己的实际情况来设置的。<br>参数解释：<br><strong>ü   -server</strong><br>我不管你什么理由，只要你的tomcat是运行在生产环境中的，这个参数必须给我加上<br>因为tomcat默认是以一种叫java –client的模式来运行的，server即意味着你的tomcat是以真实的production的模式在运行的，这也就意味着你的tomcat以server模式运行时将拥有：更大、更高的并发处理能力，更快更强捷的JVM垃圾回收机制，可以获得更多的负载与吞吐量。。。更。。。还有更。。。<br>Y给我记住啊，要不然这个-server都不加，那是要打屁股了。<br><strong>ü   -Xms–Xmx</strong><br>即JVM内存设置了，把Xms与Xmx两个值设成一样是最优的做法，有人说Xms为最小值，Xmx为最大值不是挺好的，这样设置还比较人性化，科学化。人性？科学？你个头啊。<br>大家想一下这样的场景：<br>一个系统随着并发数越来越高，它的内存使用情况逐步上升，上升到最高点不能上升了，开始回落，你们不要认为这个回落就是好事情，由其是大起大落，在内存回落时它付出的代价是CPU高速开始运转进行垃圾回收，此时严重的甚至会造成你的系统出现“卡壳”就是你在好好的操作，突然网页像死在那边一样几秒甚至十几秒时间，因为JVM正在进行垃圾回收。<br>因此一开始我们就把这两个设成一样，使得Tomcat在启动时就为最大化参数充分利用系统的效率，这个道理和jdbcconnection pool里的minpool size与maxpool size的需要设成一个数量是一样的原理。<br>如何知道我的JVM能够使用最大值啊？拍脑袋？不行！<br>在设这个最大内存即Xmx值时请先打开一个命令行，键入如下的命令：</p>\n<p>看，能够正常显示JDK的版本信息，说明，这个值你能够用。不是说32位系统下最高能够使用2GB内存吗？即：2048m，我们不防来试试</p>\n<p>可以吗？不可以！不要说2048m呢，我们小一点，试试1700m如何</p>\n<p>嘿嘿，连1700m都不可以，更不要说2048m了呢，2048m只是一个理论数值，这样说吧我这边有几台机器，有的机器-Xmx1800都没问题，有的机器最高只能到-Xmx1500m。<br>因此在设这个-Xms与-Xmx值时一定一定记得先这样测试一下，要不然直接加在tomcat启动命令行中你的tomcat就再也起不来了，要飞是飞不了，直接成了一只瘟猫了。<br><strong>ü   –Xmn</strong><br>设置年轻代大小为512m。整个堆大小=年轻代大小 + 年老代大小 + 持久代大小。持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。<br><strong>ü   -Xss</strong><br>是指设定每个线程的堆栈大小。这个就要依据你的程序，看一个线程 大约需要占用多少内存，可能会有多少线程同时运行等。一般不易设置超过1M，要不然容易出现out ofmemory。<br><strong>ü   -XX:+AggressiveOpts</strong><br>作用如其名（aggressive），启用这个参数，则每当JDK版本升级时，你的JVM都会使用最新加入的优化技术（如果有的话）<br><strong>ü   -XX:+UseBiasedLocking</strong><br>启用一个优化了的线程锁，我们知道在我们的appserver，每个http请求就是一个线程，有的请求短有的请求长，就会有请求排队的现象，甚至还会出现线程阻塞，这个优化了的线程锁使得你的appserver内对线程处理自动进行最优调配。<br><strong>ü   -XX:PermSize=128M-XX:MaxPermSize=256M</strong><br>JVM使用-XX:PermSize设置非堆内存初始值，默认是物理内存的1/64；<br>在数据量的很大的文件导出时，一定要把这两个值设置上，否则会出现内存溢出的错误。<br>由XX:MaxPermSize设置最大非堆内存的大小，默认是物理内存的1/4。<br>那么，如果是物理内存4GB，那么64分之一就是64MB，这就是PermSize默认值，也就是永生代内存初始大小；<br>四分之一是1024MB，这就是MaxPermSize默认大小。<br><strong>ü   -XX:+DisableExplicitGC</strong><br>在程序代码中不允许有显示的调用”System.gc()”。看到过有两个极品工程中每次在DAO操作结束时手动调用System.gc()一下，觉得这样做好像能够解决它们的out ofmemory问题一样，付出的代价就是系统响应时间严重降低，就和我在关于Xms,Xmx里的解释的原理一样，这样去调用GC导致系统的JVM大起大落，性能不到什么地方去哟！<br><strong>ü   -XX:+UseParNewGC</strong><br>对年轻代采用多线程并行回收，这样收得快。<br><strong>ü   -XX:+UseConcMarkSweepGC</strong><br>即CMS gc，这一特性只有jdk1.5即后续版本才具有的功能，它使用的是gc估算触发和heap占用触发。<br>我们知道频频繁的GC会造面JVM的大起大落从而影响到系统的效率，因此使用了CMS GC后可以在GC次数增多的情况下，每次GC的响应时间却很短，比如说使用了CMS GC后经过jprofiler的观察，GC被触发次数非常多，而每次GC耗时仅为几毫秒。<br><strong>ü   -XX:MaxTenuringThreshold</strong><br>设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概率。<br>这个值的设置是根据本地的jprofiler监控后得到的一个理想的值，不能一概而论原搬照抄。<br><strong>ü   -XX:+CMSParallelRemarkEnabled</strong><br>在使用UseParNewGC 的情况下, 尽量减少 mark 的时间<br>ü   -XX:+UseCMSCompactAtFullCollection<br>在使用concurrent gc 的情况下, 防止 memoryfragmention, 对live object 进行整理, 使 memory 碎片减少。<br>ü   -XX:LargePageSizeInBytes<br>指定 Java heap的分页页面大小<br>ü   -XX:+UseFastAccessorMethods<br>get,set 方法转成本地代码<br>ü   -XX:+UseCMSInitiatingOccupancyOnly<br>指示只有在 oldgeneration 在使用了初始化的比例后concurrent collector 启动收集<br>ü   -XX:CMSInitiatingOccupancyFraction=70<br>CMSInitiatingOccupancyFraction，这个参数设置有很大技巧，基本上满足(Xmx-Xmn)<em>(100- CMSInitiatingOccupancyFraction)/100&gt;=Xmn就不会出现promotion failed。在我的应用中Xmx是6000，Xmn是512，那么Xmx-Xmn是5488兆，也就是年老代有5488 兆，CMSInitiatingOccupancyFraction=90说明年老代到90%满的时候开始执行对年老代的并发垃圾回收（CMS），这时还 剩10%的空间是5488</em>10%=548兆，所以即使Xmn（也就是年轻代共512兆）里所有对象都搬到年老代里，548兆的空间也足够了，所以只要满 足上面的公式，就不会出现垃圾回收时的promotion failed；<br>因此这个参数的设置必须与Xmn关联在一起。<br>ü   -Djava.awt.headless=true<br>这个参数一般我们都是放在最后使用的，这全参数的作用是这样的，有时我们会在我们的J2EE工程中使用一些图表工具如：jfreechart，用于在web网页输出GIF/JPG等流，在winodws环境下，一般我们的app server在输出图形时不会碰到什么问题，但是在linux/unix环境下经常会碰到一个exception导致你在winodws开发环境下图片显示的好好可是在linux/unix下却显示不出来，因此加上这个参数以免避这样的情况出现。<br>上述这样的配置，基本上可以达到：</p>\n<ul>\n<li>ü   系统响应时间增快</li>\n<li>ü   JVM回收速度增快同时又不影响系统的响应率</li>\n<li>ü   JVM内存最大化利用</li>\n<li>ü   线程阻塞情况最小化</li>\n<li>2.3 Tomcat容器内的优化<br>前面我们对Tomcat启动时的命令进行了优化，增加了系统的JVM可使用数、垃圾回收效率与线程阻塞情况、增加了系统响应效率等还有一个很重要的指标，我们没有去做优化，就是吞吐量。<br>还记得我们在第三天的学习中说的，这个系统本身可以处理1000，你没有优化和配置导致它默认只能处理25。因此下面我们来看Tomcat容器内的优化。<br>打开tomcat安装目录\\conf\\server.xml文件，定位到这一行：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt; Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;</div></pre></td></tr></table></figure>\n<p>这一行就是我们的tomcat容器性能参数设置的地方，它一般都会有一个默认值，这些默认值是远远不够我们的使用的，我们来看经过更改后的这一段的配置：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt; Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;</div><div class=\"line\">          URIEncoding=&quot;UTF-8&quot;  minSpareThreads=&quot;25&quot; maxSpareThreads=&quot;75&quot;</div><div class=\"line\">          enableLookups=&quot;false&quot; disableUploadTimeout=&quot;true&quot; connectionTimeout=&quot;20000&quot;</div><div class=\"line\">          acceptCount=&quot;300&quot;  maxThreads=&quot;300&quot; maxProcessors=&quot;1000&quot; minProcessors=&quot;5&quot;</div><div class=\"line\">          useURIValidationHack=&quot;false&quot;</div><div class=\"line\">                                               compression=&quot;on&quot; compressionMinSize=&quot;2048&quot;</div><div class=\"line\">                                               compressableMimeType=&quot;text/html,text/xml,text/JavaScript,text/css,text/plain&quot;</div><div class=\"line\">               redirectPort=&quot;8443&quot;</div><div class=\"line\">/&gt;</div></pre></td></tr></table></figure></p>\n<p>好大一陀唉。。。。。。<br>没关系，一个个来解释<br>ü   URIEncoding=”UTF-8”<br>使得tomcat可以解析含有中文名的文件的url，真方便，不像apache里还有搞个mod_encoding，还要手工编译<br>ü   maxSpareThreads<br>maxSpareThreads 的意思就是如果空闲状态的线程数多于设置的数目，则将这些线程中止，减少这个池中的线程总数。<br>ü   minSpareThreads<br>最小备用线程数，tomcat启动时的初始化的线程数。<br>ü   enableLookups<br>这个功效和Apache中的HostnameLookups一样，设为关闭。<br>ü   connectionTimeout<br>connectionTimeout为网络连接超时时间毫秒数。<br>ü   maxThreads<br>maxThreads Tomcat使用线程来处理接收的每个请求。这个值表示Tomcat可创建的最大的线程数，即最大并发数。</p>\n<p>ü   acceptCount<br>acceptCount是当线程数达到maxThreads后，后续请求会被放入一个等待队列，这个acceptCount是这个队列的大小，如果这个队列也满了，就直接refuse connection</p>\n<p>ü   maxProcessors与minProcessors<br>在 Java中线程是程序运行时的路径，是在一个程序中与其它控制线程无关的、能够独立运行的代码段。它们共享相同的地址空间。多线程帮助程序员写出CPU最 大利用率的高效程序，使空闲时间保持最低，从而接受更多的请求。<br>通常Windows是1000个左右，Linux是2000个左右。<br>ü   useURIValidationHack<br>我们来看一下tomcat中的一段源码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">security</div><div class=\"line\">        if (connector.getUseURIValidationHack()) &#123;</div><div class=\"line\">            String uri = validate(request.getRequestURI());</div><div class=\"line\">            if (uri == null) &#123;</div><div class=\"line\">                res.setStatus(400);</div><div class=\"line\">                res.setMessage(&quot;Invalid URI&quot;);</div><div class=\"line\">                throw new IOException(&quot;Invalid URI&quot;);</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                req.requestURI().setString(uri);</div><div class=\"line\">                // Redoing the URI decoding</div><div class=\"line\">                req.decodedURI().duplicate(req.requestURI());</div><div class=\"line\">                req.getURLDecoder().convert(req.decodedURI(), true);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div></pre></td></tr></table></figure></p>\n<p>可以看到如果把useURIValidationHack设成”false”，可以减少它对一些url的不必要的检查从而减省开销。<br>ü   enableLookups=”false”<br>为了消除DNS查询对性能的影响我们可以关闭DNS查询，方式是修改server.xml文件中的enableLookups参数值。<br>ü   disableUploadTimeout<br>类似于Apache中的keeyalive一样<br>ü   给Tomcat配置gzip压缩(HTTP压缩)功能<br>compression=”on” compressionMinSize=”2048”<br>compressableMimeType=”text/html,text/xml,text/javascript,text/css,text/plain”<br>HTTP 压缩可以大大提高浏览网站的速度，它的原理是，在客户端请求网页后，从服务器端将网页文件压缩，再下载到客户端，由客户端的浏览器负责解压缩并浏览。相对于普通的浏览过程HTML,CSS,Javascript , Text ，它可以节省40%左右的流量。更为重要的是，它可以对动态生成的，包括CGI、PHP , JSP , ASP , Servlet,SHTML等输出的网页也能进行压缩，压缩效率惊人。</p>\n<ol>\n<li>compression=”on” 打开压缩功能</li>\n<li>compressionMinSize=”2048” 启用压缩的输出内容大小，这里面默认为2KB</li>\n<li>noCompressionUserAgents=”gozilla, traviata” 对于以下的浏览器，不启用压缩</li>\n<li>compressableMimeType=”text/html,text/xml”　压缩类型</li>\n</ol>\n<p>最后不要忘了把8443端口的地方也加上同样的配置，因为如果我们走https协议的话，我们将会用到8443端口这个段的配置，对吧？<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;!--enable tomcat ssl--&gt;</div><div class=\"line\">    &lt;Connector port=&quot;8443&quot; protocol=&quot;HTTP/1.1&quot;</div><div class=\"line\">               URIEncoding=&quot;UTF-8&quot;  minSpareThreads=&quot;25&quot; maxSpareThreads=&quot;75&quot;</div><div class=\"line\">          enableLookups=&quot;false&quot; disableUploadTimeout=&quot;true&quot; connectionTimeout=&quot;20000&quot;</div><div class=\"line\">          acceptCount=&quot;300&quot;  maxThreads=&quot;300&quot; maxProcessors=&quot;1000&quot; minProcessors=&quot;5&quot;</div><div class=\"line\">          useURIValidationHack=&quot;false&quot;</div><div class=\"line\">                    compression=&quot;on&quot; compressionMinSize=&quot;2048&quot;</div><div class=\"line\">                    compressableMimeType=&quot;text/html,text/xml,text/javascript,text/css,text/plain&quot;</div><div class=\"line\">                SSLEnabled=&quot;true&quot;</div><div class=\"line\">           scheme=&quot;https&quot; secure=&quot;true&quot;</div><div class=\"line\">           clientAuth=&quot;false&quot; sslProtocol=&quot;TLS&quot;</div><div class=\"line\">           keystoreFile=&quot;d:/tomcat2/conf/shnlap93.jks&quot; keystorePass=&quot;aaaaaa&quot;</div><div class=\"line\">      /&gt;</div></pre></td></tr></table></figure></p>\n<p>好了，所有的Tomcat优化的地方都加上了。结合第三天中的Apache的性能优化，我们这个架构可以“飞奔”起来了，当然这边把有提及任何关于数据库优化的步骤，但仅凭这两步，我们的系统已经有了很大的提升。<br>举个真实的例子：上一个项目，经过4轮performance testing，第一轮进行了问题的定位，第二轮就是进行了apache+tomcat/weblogic的优化，第三轮是做集群优化，第四轮是sql与codes的优化。<br>在到达第二轮时，我们的性能已经提升了多少倍呢？我们来看一个loaderrunner的截图吧：</p>\n<p>左边第一列是第一轮没有经过任何调优的压力测试报告。<br>右边这一列是经过了apache优化，tomcat优化后得到的压力测试报告。<br>大家看看，这就提高了多少倍？这还只是在没有改动代码的情况下得到的改善，现在明白了好好的调优一<br>个apache和tomcat其实是多么的重要了？如果加上后面的代码、SQL的调优、数据库的调优。。。。。。所以我在上一个工程中有单笔交易性能（无论是吞吐量、响应时间）提高了80倍这样的极端例子的存在。</p>\n","excerpt":"","more":"<h3 id=\"一、总结前一天的学习\"><a href=\"#一、总结前一天的学习\" class=\"headerlink\" title=\"一、总结前一天的学习\"></a>一、总结前一天的学习</h3><p>我们得知了决定性能测试的几个重要指标，它们是：</p>\n<ul>\n<li>吞吐量</li>\n<li>Responsetime</li>\n<li>Cpuload</li>\n<li>MemoryUsage<br>我们也在第三天的学习中对Apache做过了一定的优化，使其最优化上述4大核心指标的读数，那么我们的Apache调优了，我们的Tomcat也作些相应的调整，当完成今的课程后，到时你的“小猫”到时真的会“飞”起来的，所以请用心看完，这篇文章向那位曾写过“Tomcat如何承受1000个用户”的作都的敬，一方面又是这篇原文的一个扩展，因为在把原文的知识用到相关的两个大工程中去后解决了：</li>\n</ul>\n<ol>\n<li>承受更大并发用户数</li>\n<li>取得了良好的性能与改善（系统平均性能提升达20倍，极端一个交易达80倍）。<br>另外值的一提的是，我们当时工程里用的“小猫”是跑在32位机下的， 也就是我们的JVM最大受到2GB内存的限制，都已经跑成“飞”了。。。。。。如果在64位机下跑这头“小猫”。。。。。。大家可想而知，会得到什么样的效果呢？下面就请请详细的设置吧！</li>\n</ol>\n<h3 id=\"二、一切基于JVM（内存）的优化\"><a href=\"#二、一切基于JVM（内存）的优化\" class=\"headerlink\" title=\"二、一切基于JVM（内存）的优化\"></a>二、一切基于JVM（内存）的优化</h3><h4 id=\"32位操作系统与64位操作系统中JVM的对比\"><a href=\"#32位操作系统与64位操作系统中JVM的对比\" class=\"headerlink\" title=\"32位操作系统与64位操作系统中JVM的对比\"></a>32位操作系统与64位操作系统中JVM的对比</h4><p>我们一般的开发人员，基本用的是都是32位的Windows系统，这就导致了一个严重的问题即：32位windows系统对内存限制，下面先来看一个比较的表格：</p>\n<p>操作系统<br>操作系统位数<br>内存限制<br>解决办法<br>Winxp<br>32<br>4GB<br>超级兔子<br>Win7<br>32<br>4GB<br>可以通过设置/PAE<br>Win2003<br>32<br>可以突破4GB达16GB<br>必需要装win2003 advanced server且要打上sp2补丁<br>Win7<br>64<br>无限制<br>机器能插多少内存，系统内存就能支持到多大<br>Win2003<br>64<br>无限制<br>机器能插多少内存，系统内存就能支持到多大<br>Linux<br>64<br>无限制<br>机器能插多少内存，系统内存就能支持到多大<br>Unix<br>64<br>无限制<br>机器能插多少内存，系统内存就能支持到多大<br>上述问题解决后，我们又碰到一个新的问题，32位系统下JVM对内存的限制：不能突破2GB内存，即使你在Win2003 Advanced Server下你的机器装有8GB-16GB的内存，而你的Java，只能用到2GB的内存。<br>其实我一直很想推荐大家使用Linux或者是Mac操作系统的，而且要装64位，因为必竟我们是开发用的不是打游戏用的，而Java源自Unix归于Unix（Linux只是运行在PC上的Unix而己）。<br>所以很多开发人员运行在win32位系统上更有甚者在生产环境下都会布署win32位的系统，那么这时你的Tomcat要优化，就要讲究点技巧了。而在64位操作系统上无论是系统内存还是JVM都没有受到2GB这样的限制。<br>Tomcat的优化分成两块：<br>ü   Tomcat启动命令行中的优化参数即JVM优化<br>ü   Tomcat容器自身参数的优化（这块很像ApacheHttp Server）<br>这一节先要讲的是Tomcat启动命令行中的优化参数。<br>Tomcat首先跑在JVM之上的，因为它的启动其实也只是一个java命令行，首先我们需要对这个JAVA的启动命令行进行调优。<br>需要注意的是：<br>这边讨论的JVM优化是基于Oracle Sun的jdk1.6版有以上，其它JDK或者低版本JDK不适用。</p>\n<h4 id=\"Tomcat启动行参数的优化\"><a href=\"#Tomcat启动行参数的优化\" class=\"headerlink\" title=\"Tomcat启动行参数的优化\"></a>Tomcat启动行参数的优化</h4><p>Tomcat 的启动参数位于tomcat的安装目录\\bin目录下，如果你是Linux操作系统就是catalina.sh文件，如果你是Windows操作系统那么你需要改动的就是catalina.bat文件。打开该文件，一般该文件头部是一堆的由##包裹着的注释文字，找到注释文字的最后一段如：</p>\n<p>敲入一个回车，加入如下的参数<br><strong>Linux系统中tomcat的启动参数</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">export JAVA_OPTS=&quot;-server -Xms1400M -Xmx1400M -Xss512k -XX:+AggressiveOpts -XX:+UseBiasedLocking -XX:PermSize=128M -XX:MaxPermSize=256M -XX:+DisableExplicitGC -XX:MaxTenuringThreshold=31 -XX:+UseConcMarkSweepGC -XX:+UseParNewGC  -XX:+CMSParallelRemarkEnabled -XX:+UseCMSCompactAtFullCollection -XX:LargePageSizeInBytes=128m  -XX:+UseFastAccessorMethods -XX:+UseCMSInitiatingOccupancyOnly -Djava.awt.headless=true &quot;</div></pre></td></tr></table></figure>\n<p><strong>Windows系统中tomcat的启动参数</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">set JAVA_OPTS=-server -Xms1400M -Xmx1400M -Xss512k -XX:+AggressiveOpts -XX:+UseBiasedLocking -XX:PermSize=128M -XX:MaxPermSize=256M -XX:+DisableExplicitGC -XX:MaxTenuringThreshold=31 -XX:+UseConcMarkSweepGC -XX:+UseParNewGC  -XX:+CMSParallelRemarkEnabled -XX:+UseCMSCompactAtFullCollection -XX:LargePageSizeInBytes=128m  -XX:+UseFastAccessorMethods -XX:+UseCMSInitiatingOccupancyOnly -Djava.awt.headless=true</div></pre></td></tr></table></figure></p>\n<p>上面参数好多啊，可能有人写到现在都没见一个tomcat的启动命令里加了这么多参数，当然，这些参数只是我机器上的，不一定适合你，尤其是参数后的value（值）是需要根据你自己的实际情况来设置的。<br>参数解释：<br><strong>ü   -server</strong><br>我不管你什么理由，只要你的tomcat是运行在生产环境中的，这个参数必须给我加上<br>因为tomcat默认是以一种叫java –client的模式来运行的，server即意味着你的tomcat是以真实的production的模式在运行的，这也就意味着你的tomcat以server模式运行时将拥有：更大、更高的并发处理能力，更快更强捷的JVM垃圾回收机制，可以获得更多的负载与吞吐量。。。更。。。还有更。。。<br>Y给我记住啊，要不然这个-server都不加，那是要打屁股了。<br><strong>ü   -Xms–Xmx</strong><br>即JVM内存设置了，把Xms与Xmx两个值设成一样是最优的做法，有人说Xms为最小值，Xmx为最大值不是挺好的，这样设置还比较人性化，科学化。人性？科学？你个头啊。<br>大家想一下这样的场景：<br>一个系统随着并发数越来越高，它的内存使用情况逐步上升，上升到最高点不能上升了，开始回落，你们不要认为这个回落就是好事情，由其是大起大落，在内存回落时它付出的代价是CPU高速开始运转进行垃圾回收，此时严重的甚至会造成你的系统出现“卡壳”就是你在好好的操作，突然网页像死在那边一样几秒甚至十几秒时间，因为JVM正在进行垃圾回收。<br>因此一开始我们就把这两个设成一样，使得Tomcat在启动时就为最大化参数充分利用系统的效率，这个道理和jdbcconnection pool里的minpool size与maxpool size的需要设成一个数量是一样的原理。<br>如何知道我的JVM能够使用最大值啊？拍脑袋？不行！<br>在设这个最大内存即Xmx值时请先打开一个命令行，键入如下的命令：</p>\n<p>看，能够正常显示JDK的版本信息，说明，这个值你能够用。不是说32位系统下最高能够使用2GB内存吗？即：2048m，我们不防来试试</p>\n<p>可以吗？不可以！不要说2048m呢，我们小一点，试试1700m如何</p>\n<p>嘿嘿，连1700m都不可以，更不要说2048m了呢，2048m只是一个理论数值，这样说吧我这边有几台机器，有的机器-Xmx1800都没问题，有的机器最高只能到-Xmx1500m。<br>因此在设这个-Xms与-Xmx值时一定一定记得先这样测试一下，要不然直接加在tomcat启动命令行中你的tomcat就再也起不来了，要飞是飞不了，直接成了一只瘟猫了。<br><strong>ü   –Xmn</strong><br>设置年轻代大小为512m。整个堆大小=年轻代大小 + 年老代大小 + 持久代大小。持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。<br><strong>ü   -Xss</strong><br>是指设定每个线程的堆栈大小。这个就要依据你的程序，看一个线程 大约需要占用多少内存，可能会有多少线程同时运行等。一般不易设置超过1M，要不然容易出现out ofmemory。<br><strong>ü   -XX:+AggressiveOpts</strong><br>作用如其名（aggressive），启用这个参数，则每当JDK版本升级时，你的JVM都会使用最新加入的优化技术（如果有的话）<br><strong>ü   -XX:+UseBiasedLocking</strong><br>启用一个优化了的线程锁，我们知道在我们的appserver，每个http请求就是一个线程，有的请求短有的请求长，就会有请求排队的现象，甚至还会出现线程阻塞，这个优化了的线程锁使得你的appserver内对线程处理自动进行最优调配。<br><strong>ü   -XX:PermSize=128M-XX:MaxPermSize=256M</strong><br>JVM使用-XX:PermSize设置非堆内存初始值，默认是物理内存的1/64；<br>在数据量的很大的文件导出时，一定要把这两个值设置上，否则会出现内存溢出的错误。<br>由XX:MaxPermSize设置最大非堆内存的大小，默认是物理内存的1/4。<br>那么，如果是物理内存4GB，那么64分之一就是64MB，这就是PermSize默认值，也就是永生代内存初始大小；<br>四分之一是1024MB，这就是MaxPermSize默认大小。<br><strong>ü   -XX:+DisableExplicitGC</strong><br>在程序代码中不允许有显示的调用”System.gc()”。看到过有两个极品工程中每次在DAO操作结束时手动调用System.gc()一下，觉得这样做好像能够解决它们的out ofmemory问题一样，付出的代价就是系统响应时间严重降低，就和我在关于Xms,Xmx里的解释的原理一样，这样去调用GC导致系统的JVM大起大落，性能不到什么地方去哟！<br><strong>ü   -XX:+UseParNewGC</strong><br>对年轻代采用多线程并行回收，这样收得快。<br><strong>ü   -XX:+UseConcMarkSweepGC</strong><br>即CMS gc，这一特性只有jdk1.5即后续版本才具有的功能，它使用的是gc估算触发和heap占用触发。<br>我们知道频频繁的GC会造面JVM的大起大落从而影响到系统的效率，因此使用了CMS GC后可以在GC次数增多的情况下，每次GC的响应时间却很短，比如说使用了CMS GC后经过jprofiler的观察，GC被触发次数非常多，而每次GC耗时仅为几毫秒。<br><strong>ü   -XX:MaxTenuringThreshold</strong><br>设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概率。<br>这个值的设置是根据本地的jprofiler监控后得到的一个理想的值，不能一概而论原搬照抄。<br><strong>ü   -XX:+CMSParallelRemarkEnabled</strong><br>在使用UseParNewGC 的情况下, 尽量减少 mark 的时间<br>ü   -XX:+UseCMSCompactAtFullCollection<br>在使用concurrent gc 的情况下, 防止 memoryfragmention, 对live object 进行整理, 使 memory 碎片减少。<br>ü   -XX:LargePageSizeInBytes<br>指定 Java heap的分页页面大小<br>ü   -XX:+UseFastAccessorMethods<br>get,set 方法转成本地代码<br>ü   -XX:+UseCMSInitiatingOccupancyOnly<br>指示只有在 oldgeneration 在使用了初始化的比例后concurrent collector 启动收集<br>ü   -XX:CMSInitiatingOccupancyFraction=70<br>CMSInitiatingOccupancyFraction，这个参数设置有很大技巧，基本上满足(Xmx-Xmn)<em>(100- CMSInitiatingOccupancyFraction)/100&gt;=Xmn就不会出现promotion failed。在我的应用中Xmx是6000，Xmn是512，那么Xmx-Xmn是5488兆，也就是年老代有5488 兆，CMSInitiatingOccupancyFraction=90说明年老代到90%满的时候开始执行对年老代的并发垃圾回收（CMS），这时还 剩10%的空间是5488</em>10%=548兆，所以即使Xmn（也就是年轻代共512兆）里所有对象都搬到年老代里，548兆的空间也足够了，所以只要满 足上面的公式，就不会出现垃圾回收时的promotion failed；<br>因此这个参数的设置必须与Xmn关联在一起。<br>ü   -Djava.awt.headless=true<br>这个参数一般我们都是放在最后使用的，这全参数的作用是这样的，有时我们会在我们的J2EE工程中使用一些图表工具如：jfreechart，用于在web网页输出GIF/JPG等流，在winodws环境下，一般我们的app server在输出图形时不会碰到什么问题，但是在linux/unix环境下经常会碰到一个exception导致你在winodws开发环境下图片显示的好好可是在linux/unix下却显示不出来，因此加上这个参数以免避这样的情况出现。<br>上述这样的配置，基本上可以达到：</p>\n<ul>\n<li>ü   系统响应时间增快</li>\n<li>ü   JVM回收速度增快同时又不影响系统的响应率</li>\n<li>ü   JVM内存最大化利用</li>\n<li>ü   线程阻塞情况最小化</li>\n<li>2.3 Tomcat容器内的优化<br>前面我们对Tomcat启动时的命令进行了优化，增加了系统的JVM可使用数、垃圾回收效率与线程阻塞情况、增加了系统响应效率等还有一个很重要的指标，我们没有去做优化，就是吞吐量。<br>还记得我们在第三天的学习中说的，这个系统本身可以处理1000，你没有优化和配置导致它默认只能处理25。因此下面我们来看Tomcat容器内的优化。<br>打开tomcat安装目录\\conf\\server.xml文件，定位到这一行：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt; Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;</div></pre></td></tr></table></figure>\n<p>这一行就是我们的tomcat容器性能参数设置的地方，它一般都会有一个默认值，这些默认值是远远不够我们的使用的，我们来看经过更改后的这一段的配置：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt; Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;</div><div class=\"line\">          URIEncoding=&quot;UTF-8&quot;  minSpareThreads=&quot;25&quot; maxSpareThreads=&quot;75&quot;</div><div class=\"line\">          enableLookups=&quot;false&quot; disableUploadTimeout=&quot;true&quot; connectionTimeout=&quot;20000&quot;</div><div class=\"line\">          acceptCount=&quot;300&quot;  maxThreads=&quot;300&quot; maxProcessors=&quot;1000&quot; minProcessors=&quot;5&quot;</div><div class=\"line\">          useURIValidationHack=&quot;false&quot;</div><div class=\"line\">                                               compression=&quot;on&quot; compressionMinSize=&quot;2048&quot;</div><div class=\"line\">                                               compressableMimeType=&quot;text/html,text/xml,text/JavaScript,text/css,text/plain&quot;</div><div class=\"line\">               redirectPort=&quot;8443&quot;</div><div class=\"line\">/&gt;</div></pre></td></tr></table></figure></p>\n<p>好大一陀唉。。。。。。<br>没关系，一个个来解释<br>ü   URIEncoding=”UTF-8”<br>使得tomcat可以解析含有中文名的文件的url，真方便，不像apache里还有搞个mod_encoding，还要手工编译<br>ü   maxSpareThreads<br>maxSpareThreads 的意思就是如果空闲状态的线程数多于设置的数目，则将这些线程中止，减少这个池中的线程总数。<br>ü   minSpareThreads<br>最小备用线程数，tomcat启动时的初始化的线程数。<br>ü   enableLookups<br>这个功效和Apache中的HostnameLookups一样，设为关闭。<br>ü   connectionTimeout<br>connectionTimeout为网络连接超时时间毫秒数。<br>ü   maxThreads<br>maxThreads Tomcat使用线程来处理接收的每个请求。这个值表示Tomcat可创建的最大的线程数，即最大并发数。</p>\n<p>ü   acceptCount<br>acceptCount是当线程数达到maxThreads后，后续请求会被放入一个等待队列，这个acceptCount是这个队列的大小，如果这个队列也满了，就直接refuse connection</p>\n<p>ü   maxProcessors与minProcessors<br>在 Java中线程是程序运行时的路径，是在一个程序中与其它控制线程无关的、能够独立运行的代码段。它们共享相同的地址空间。多线程帮助程序员写出CPU最 大利用率的高效程序，使空闲时间保持最低，从而接受更多的请求。<br>通常Windows是1000个左右，Linux是2000个左右。<br>ü   useURIValidationHack<br>我们来看一下tomcat中的一段源码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">security</div><div class=\"line\">        if (connector.getUseURIValidationHack()) &#123;</div><div class=\"line\">            String uri = validate(request.getRequestURI());</div><div class=\"line\">            if (uri == null) &#123;</div><div class=\"line\">                res.setStatus(400);</div><div class=\"line\">                res.setMessage(&quot;Invalid URI&quot;);</div><div class=\"line\">                throw new IOException(&quot;Invalid URI&quot;);</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                req.requestURI().setString(uri);</div><div class=\"line\">                // Redoing the URI decoding</div><div class=\"line\">                req.decodedURI().duplicate(req.requestURI());</div><div class=\"line\">                req.getURLDecoder().convert(req.decodedURI(), true);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div></pre></td></tr></table></figure></p>\n<p>可以看到如果把useURIValidationHack设成”false”，可以减少它对一些url的不必要的检查从而减省开销。<br>ü   enableLookups=”false”<br>为了消除DNS查询对性能的影响我们可以关闭DNS查询，方式是修改server.xml文件中的enableLookups参数值。<br>ü   disableUploadTimeout<br>类似于Apache中的keeyalive一样<br>ü   给Tomcat配置gzip压缩(HTTP压缩)功能<br>compression=”on” compressionMinSize=”2048”<br>compressableMimeType=”text/html,text/xml,text/javascript,text/css,text/plain”<br>HTTP 压缩可以大大提高浏览网站的速度，它的原理是，在客户端请求网页后，从服务器端将网页文件压缩，再下载到客户端，由客户端的浏览器负责解压缩并浏览。相对于普通的浏览过程HTML,CSS,Javascript , Text ，它可以节省40%左右的流量。更为重要的是，它可以对动态生成的，包括CGI、PHP , JSP , ASP , Servlet,SHTML等输出的网页也能进行压缩，压缩效率惊人。</p>\n<ol>\n<li>compression=”on” 打开压缩功能</li>\n<li>compressionMinSize=”2048” 启用压缩的输出内容大小，这里面默认为2KB</li>\n<li>noCompressionUserAgents=”gozilla, traviata” 对于以下的浏览器，不启用压缩</li>\n<li>compressableMimeType=”text/html,text/xml”　压缩类型</li>\n</ol>\n<p>最后不要忘了把8443端口的地方也加上同样的配置，因为如果我们走https协议的话，我们将会用到8443端口这个段的配置，对吧？<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;!--enable tomcat ssl--&gt;</div><div class=\"line\">    &lt;Connector port=&quot;8443&quot; protocol=&quot;HTTP/1.1&quot;</div><div class=\"line\">               URIEncoding=&quot;UTF-8&quot;  minSpareThreads=&quot;25&quot; maxSpareThreads=&quot;75&quot;</div><div class=\"line\">          enableLookups=&quot;false&quot; disableUploadTimeout=&quot;true&quot; connectionTimeout=&quot;20000&quot;</div><div class=\"line\">          acceptCount=&quot;300&quot;  maxThreads=&quot;300&quot; maxProcessors=&quot;1000&quot; minProcessors=&quot;5&quot;</div><div class=\"line\">          useURIValidationHack=&quot;false&quot;</div><div class=\"line\">                    compression=&quot;on&quot; compressionMinSize=&quot;2048&quot;</div><div class=\"line\">                    compressableMimeType=&quot;text/html,text/xml,text/javascript,text/css,text/plain&quot;</div><div class=\"line\">                SSLEnabled=&quot;true&quot;</div><div class=\"line\">           scheme=&quot;https&quot; secure=&quot;true&quot;</div><div class=\"line\">           clientAuth=&quot;false&quot; sslProtocol=&quot;TLS&quot;</div><div class=\"line\">           keystoreFile=&quot;d:/tomcat2/conf/shnlap93.jks&quot; keystorePass=&quot;aaaaaa&quot;</div><div class=\"line\">      /&gt;</div></pre></td></tr></table></figure></p>\n<p>好了，所有的Tomcat优化的地方都加上了。结合第三天中的Apache的性能优化，我们这个架构可以“飞奔”起来了，当然这边把有提及任何关于数据库优化的步骤，但仅凭这两步，我们的系统已经有了很大的提升。<br>举个真实的例子：上一个项目，经过4轮performance testing，第一轮进行了问题的定位，第二轮就是进行了apache+tomcat/weblogic的优化，第三轮是做集群优化，第四轮是sql与codes的优化。<br>在到达第二轮时，我们的性能已经提升了多少倍呢？我们来看一个loaderrunner的截图吧：</p>\n<p>左边第一列是第一轮没有经过任何调优的压力测试报告。<br>右边这一列是经过了apache优化，tomcat优化后得到的压力测试报告。<br>大家看看，这就提高了多少倍？这还只是在没有改动代码的情况下得到的改善，现在明白了好好的调优一<br>个apache和tomcat其实是多么的重要了？如果加上后面的代码、SQL的调优、数据库的调优。。。。。。所以我在上一个工程中有单笔交易性能（无论是吞吐量、响应时间）提高了80倍这样的极端例子的存在。</p>\n"},{"title":"MySQL最佳实践","toc":true,"date":"2016-12-05T16:00:00.000Z","_content":"\n## 优化查询的查询缓存\n大部分MySQL服务器都有查询缓存功能。这是提高性能的最有效的方法之一，这是由数据库引擎私下处理的。当同一个查询被多次执行，结果会直接从缓存里提取，这样速度就很快。\n\n主要的问题是，这对程序员来说太简单了，不容易看到，我们很多人都容易忽略。我们实际上是可以组织查询缓存执行任务的。\n```\n// query cache does NOT work\n$r = mysql_query(\"SELECT username FROM user WHERE signup_date >= CURDATE()\");\n  \n// query cache works!\n$today = date(\"Y-m-d\");\n$r = mysql_query(\"SELECT username FROM user WHERE signup_date >= '$today'\");\n```\n查询缓存在第一行不执行的原因在于CURDTE()功能的使用。这适用于所有的非确定性功能，就像NOW()和RAND()等等。。。因为功能返回的结果是可变的。MySQL决定禁用查询器的查询缓存。我们所需要做的是通过添加一额外一行PHP，在查询前阻止它发生。\n\n##EXPLAIN你的选择查询\n使用EXPLAIN关键词可以帮助了解MySQL是怎样运行你的查询的。这有助于发现瓶颈和查询或表结构的其它问题。\n\nEXPLAIN的查询结果会展示哪一个索引被使用过，表示怎样扫描和储存的，等等。。。\n\n选择一个SELECT查询（一个有连接的复杂查询会更好），在它的前面添加关键词EXPLAIN，这样就可以直接使用数据库了。结果会以一个漂亮的表来展示。例如，就好比我执行连接时忘了添加一栏的索引：\n\n\n\n现在它只会从表2里面扫描9和16行，而非扫描7883行。经验法则是乘以所有“行”那一栏的数字，你的查询性能会跟结果数字成比例的。\n\n##获取唯一行时使用LIMIT 1\n有时当你查表时，你已经知道你正在查找的结果只有一行。你可能正在获取唯一记录，或者你可能只是查询是否存在满足你的WHERE子句条件的记录。\n\n在这种情况下，将LIMIT 1添加到查询条件中可以提高性能。这样，数据库引擎将在找到刚刚第一个记录之后停止扫描记录，而不是遍历整个表或索引。\n```\n// do I have any users from Alabama?\n  \n// what NOT to do:\n$r = mysql_query(\"SELECT * FROM user WHERE state = 'Alabama'\");\nif (mysql_num_rows($r) > 0) {\n    // ...\n}\n  \n// much better:\n$r = mysql_query(\"SELECT 1 FROM user WHERE state = 'Alabama' LIMIT 1\");\nif (mysql_num_rows($r) > 0) {\n    // ...\n}\n```\n\n##索引搜索字段\n索引不仅仅是为了主键或唯一键。如果你会在你的表中按照任何列搜索，你就都应该索引它们。\n\n\n正如你所看到的，这个规则也适用于如 \"last_name LIKE 'a%'\"的部分字符串搜索。当从字符串的开头搜索时，MySQL就可以使用那一列的索引。\n\n你也应该明白什么样搜索可以不使用有规律的索引。例如，当搜索一个单词时（例如，\"WHERE post_content LIKE '%apple%'\"），你将不会看到普通索引的好处。你最好使用 mysql 全文搜索或者构建你自己的索引解决方案。\n\n## 索引并对连接使用同样的字段类型\n如果你的应用程序包含许多连接查询, 你需要确保连接的字段在两张表上都建立了索引。 这会影响MySQL如何内部优化连接操作。\n\n此外,被连接的字段,需要使用同样类型。例如, 如果你使用一个DECIMAL字段, 连接另一张表的INT字段, MySQL将无法使用至少一个索引。 即使字符编码也需要使用相同的字符类型。\n```\n// looking for companies in my state\n$r = mysql_query(\"SELECT company_name FROM users\n    LEFT JOIN companies ON (users.state = companies.state)\n    WHERE users.id = $user_id\");\n  \n// both state columns should be indexed\n// and they both should be the same type and character encoding\n// or MySQL might do full table scans\n```\n\n## 不要ORDER BY RAND()\n起初这是一个听起来挺酷的技巧, 让许多菜鸟程序员陷入了这个陷阱。但你可能不知道，一旦你开始在查询中使用它，你创建了非常可怕的查询瓶颈。\n\n如果你真的需要对结果随机排序, 这有一个更好的方法。补充一些额外代码,你将可以防止当数据成指数级增长时造成的瓶颈。关键问题是，MySQL必须在排序之前对表中的每一行执行RAND()操作（这需要处理能力），并且仅仅给出一行。\n```\n// what NOT to do:\n$r = mysql_query(\"SELECT username FROM user ORDER BY RAND() LIMIT 1\");\n  \n// much better:\n  \n$r = mysql_query(\"SELECT count(*) FROM user\");\n$d = mysql_fetch_row($r);\n$rand = mt_rand(0,$d[0] - 1);\n  \n$r = mysql_query(\"SELECT username FROM user LIMIT $rand, 1\");\n```\n所以挑选一个小于结果数的随机数，并将其用作LIMIT子句中的偏移量。\n\n## 避免使用SELECT *\n从数据表中读取的数据越多，查询操作速度就越慢。它增加了磁盘操作所需的时间。此外，当数据库服务器与Web服务器分开时，由于必须在服务器之间传输数据，将会有更长的网络延迟。\n\n这是一个好习惯：当你使用SELECT语句时总是指定你需要的列。\n```\n// not preferred\n$r = mysql_query(\"SELECT * FROM user WHERE user_id = 1\");\n$d = mysql_fetch_assoc($r);\necho \"Welcome {$d['username']}\";\n  \n// better:\n$r = mysql_query(\"SELECT username FROM user WHERE user_id = 1\");\n$d = mysql_fetch_assoc($r);\necho \"Welcome {$d['username']}\";\n  \n// the differences are more significant with bigger result sets\n```\n\n## 几乎总是有一个id字段\n在每个以id列为PRIMARY KEY的数据表中，优先选择AUTO_INCREMENT或者INT。 也可以优选使用UNSIGNED，因为该值不能为负的。\n\n即使你拥有一个具有唯一用户名字段的用户表，也不要将其作为主键。 VARCHAR字段作为主键（检索）速度较慢。通过内部ID引用所有的用户数据，你的代码中将更加结构化。\n\n有些后台操作是由MySQL引擎本身完成的，它在内部使用主键字段。当数据库设置越复杂（集群，分区等...），这就变得更加重要了。\n\n这个规则的一个可能的例外是“关联表”，用于两个表之间的多对多类型的关联。例如，“posts_tags”表中包含两列：post_id，tag_id，用于保存表名为“post”和“tags”的两个表之间的关系。这些表可以具有包含两个id字段的PRIMARY键。\n\n## 相比VARCHAR优先使用ENUM\nENUM枚举类型是非常快速和紧凑的。在内部它们像TINYINT一样存储，但它们可以包含和显示字符串值。这使他们成为某些领域的完美候选。\n\n如果有一个字段只包含几种不同的值，请使用ENUM而不是VARCHAR。例如，它可以是名为“status”的列，并且只包含诸如“active”，“inactive”，“pending”，“expired”等的值...\n\n关于如何重构你的数据表，甚至有一种方法是可以从MySQL本身得到“建议”。 当你有一个VARCHAR字段，它实际上建议你将该列类型更改为ENUM。这通过调用PROCEDURE ANALYZE()来完成。 \n\n## 使用PROCEDURE ANALYSE()获取建议\nPROCEDURE ANALYSE() 将使用MySQL分析列结构和表中的实际数据，为你提供一些建议。它只有在数据表中有实际数据时才有用，因为这在分析决策时很重要。\n例如，如果你创建了一个INT类型的主键，但没有太多行，MySQL则可能建议您改用MEDIUMINT。或者如果你使用VARCHAR字段，如果表里只有很少的取值，你可能会得到一个建议是将其转换为ENUM。\n你也可以在其中一个表视图中单击phpmyadmin中的“建议表结构”链接来执行此操作。\n请记住，这些只是建议。 如果你的数据表变得越来越大，他们甚至可能不是正确的建议。至于如何修改最终是你来决定。\n\n## 如果可以的话使用NOT NULL\n除非你有非常重要的理由使用NULL值，否则你应该设置你的列为NOT NULL。\n首先，问一下你自己在空字符串值和NULL值之间（对应INT字段：0 vs. NULL）是否有任何的不同.如果没有理由一起使用这两个，那么你就不需要一个NULL字段（你知道在Oracle中NULL和空字符串是一样的吗？）。\nNULL列需要额外的空间，他们增加了你的比较语句的复杂度。如果可以的话尽量避免它们。当然，我理解一些人，他们也许有非常重要的理由使用NULL值，这不总是一件坏事。\n摘自MySQL 文档：\n“NULL列在行记录它们的值是否为NULL时需要额外的空间。例如MyISAM 表，每一个NULL列拥有额外的一个比特，聚集在最近的字节。\"\n\n##  预处理语句\n使用预处理语句有诸多好处，包括更高的性能和更好的安全性。\n预处理语句默认情况下会过滤绑定到它的变量，这对于避免SQL注入攻击极为有效。当然你也可以指定要过滤的变量。但这些方法更容易出现人为错误，也更容易被程序员遗忘。这在使用框架或 ORM 的时候会出现一些问题。\n既然我们关注性能，那就应该说说这个方面的好处。当在应用中多次使用同一个查询的时候，它的好处特别明显。既然向同一个预备好的语句中传入不同的参数值，MySQL 对这个语句也只会进行一次解析。\n同时，最新版本的 MySQL 在传输预备好的语句时会采用二进制形式，这样做的作用非常明显，而且对减少网络延迟很有帮助。\n曾经有一段时间，许多程序员为了一个重要的原因则避免使用预处理语句。这个原因就是，它们不会被MySQL 缓存。不过在 5.1 版本的某个时候，查询缓存也得到的支持。\n想在 PHP 中使用预处理语句，你可以看看 mysqli 扩展 或使用数据抽象层，如 PDO。\n```\n // create a prepared statement\nif ($stmt = $mysqli->prepare(\"SELECT username FROM user WHERE state=?\")) {\n  \n    // bind parameters\n    $stmt->bind_param(\"s\", $state);\n  \n    // execute\n    $stmt->execute();\n  \n    // bind result variables\n    $stmt->bind_result($username);\n  \n    // fetch value\n    $stmt->fetch();\n  \n    printf(\"%s is from %s\\n\", $username, $state);\n  \n    $stmt->close();\n}\n```\n\n## 无缓冲查询\n通常当你从脚本执行一个查询，在它可以继续后面的任务之前将需要等待查询执行完成。你可以使用无缓冲的查询来改变这一情况。\n在PHP 文档中对  mysql_unbuffered_query() f函数有一个很好的解释： \n“\n \"mysql_unbuffered_query() 发送SQL查询语句到MySQL不会像 mysql_query()那样自动地取并缓冲结果行。这让产生大量结果集的查询节省了大量的内存，在第一行已经被取回时你就可以立即在结果集上继续工作，而不用等到SQL查询被执行完成。\"\n然而，它有一定的局限性。你必须在执行另一个查询之前读取所有的行或调用mysql_free_result() 。另外你不能在结果集上使用mysql_num_rows() 或 mysql_data_seek() 。\n\n## 使用 UNSIGNED INT 存储IP地址\n很多程序员没有意识到可以使用整数类型的字段来存储 IP 地址，所以一直使用 VARCHAR(15) 类型的字段。使用 INT 只需要 4 个字节的空间，而且字段长度固定。\n\n必须确保列是 UNSINGED INT 类型，因为 IP 地址可能会用到 32 位无符号整型数据的每一个位。\n\n在查询中可以使用 INET_ATON() 来把一个IP转换为整数，用 INET_NTOA() 来进行相反的操作。在 PHP 也有类似的函数，ip2long() 和 long2ip()。\n$r = \"UPDATE users SET ip = INET_ATON('{$_SERVER['REMOTE_ADDR']}') WHERE user_id = $user_id\";\n\n## 固定长度（静态）的表会更快\n（译者注：这里提到的表的长度，实际是指表头的长度，即表中每条数据占用的空间大小，而不是指表的数据量）\n\n如果表中所有列都是“固定长度”，那么这个表被认为是“静态”或“固定长度”的。不固定的列类型包括 VARCHAR、TEXT、BLOB等。即使表中只包含一个这些类型的列，这个表就不再是固定长度的，MySQL 引擎会以不同的方式来处理它。\n固定长度的表会提高性能，因为 MySQL 引擎在记录中检索的时候速度会更快。如果想读取表中的某一地，它可以直接计算出这一行的位置。如果行的大小不固定，那就需要在主键中进行检索。\n\n它们也易于缓存，崩溃后容易重建。不过它们也会占用更多空间。例如，如果你把一个 VARCHAR(20) 的字符改为 CHAR(20) 类型，它会总是占用 20 个字节，不管里面存的是什么内容。\n\n你可以使用“垂直分区”技术，将长度变化的列拆分到另一张表中。来看看：\n\n## 垂直分区\n垂直分区是为了优化表结构而对其进行纵向拆分的行为。\n\n示例 1: 你可能会有一张用户表，包含家庭住址，而这个不是一个常用数据。这时候你可以选择把表拆分开，将住址信息保存到另一个表中。这样你的主用户表就会更小。如你所知，表越小越快。\n\n示例 2: 表中有一个 \"last_login\" 字段，用户每次登录网站都会更新这个字段，而每次更新都会导致这个表缓存的查询数据被清空。这种情况下你可以将那个字段放到另一张表里，保持用户表更新量最小。\n\n不过你也需要确保不会经常联合查询分开后的两张表，要不然你就得忍受由这带来的性能下降。\n\n## 拆分大型DELETE或INSERT语句\n如果你需要在网站上执行大型DELETE或INSERT查询，则需要注意不要影响网络流量。当执行大型语句时，它会锁表并使你的Web应用程序停止。\nApach运行许多并行进程/线程。 因此它执行脚本效率很高。所以服务器不期望打开过多的连接和进程，这很消耗资源，特别是内存。\n\n如果你锁表很长时间（如30秒或更长），在一个高流量的网站，会导致进程和查询堆积，处理这些进程和查询可能需要很长时间，最终甚至使你的网站崩溃。\n如果你的维护脚本需要删除大量的行，只需使用LIMIT子句，以避免阻塞。\n```\nwhile (1) {\n    mysql_query(\"DELETE FROM logs WHERE log_date <= '2009-10-01' LIMIT 10000\");\n    if (mysql_affected_rows() == 0) {\n        // done deleting\n        break;\n    }\n    // you can even pause a bit\n    usleep(50000);\n}\n```\n\n## 越少的列越快\n对于数据库引擎，磁盘可能是最重要的瓶颈。更小更紧凑的数据、减少磁盘传输量，通常有助于性能提高。\n\nMySQL文档Storage Requirements 有所有数据类型清单。\n\n如果已知表具有很少的行，则没有理由是主键类型为INT，可以用MEDIUMINT、SMALLINT代替，甚至在某些情况下使用TINYINT。 如果不需要完整时间记录，请使用DATE而不是DATETIME。\n\n确保留下合理的扩展空间，不然你可能会像Slashdot这样。\n\n## 选择正确的存储引擎\nMySQL有两个主要存储引擎，MyISAM和InnoDB。 每个都有自己的优点和缺点。\n\nMyISAM适用于读取繁重的应用程序，但是当有很多写入时它不能很好地扩展。 即使你正在更新一行的一个字段，整个表也被锁定，并且在语句执行完成之前，其他进程甚至无法读取该字段。 MyISAM在计算SELECT COUNT（*）的查询时非常快。\n\nInnoDB是一个更复杂的存储引擎，对于大多数小的应用程序，它比MyISAM慢。 但它支持基于行的锁定，使其更好地扩展。 它还支持一些更高级的功能，比如事务。\n- MyISAM存储引擎\n- InnoDB存储引擎\n\n## 使用对象关系映射器（ORM, Object Relational Mapper）\n通过使用ORM（对象关系映射器），你可以获得一定的性能提升。ORM可以完成的一切事情，手动编码也可完成。但这可能意味着需要太多额外的工作，并且需要高水平的专业知识。\n\nORM以“延迟加载”著称。这意味着它们仅在需要时获取实际值。但是你需要小心处理他们，否则你可能最终创建了许多微型查询，这会降低数据库性能。\n\nORM还可以将多个查询批处理到事务中，其操作速度比向数据库发送单个查询快得多。\n\n目前我最喜欢的PHP-ORM是Doctrine。我写了一篇关于如何安装Doctrine与CodeIgniter的文章（install Doctrine with CodeIgniter）。\n\n## 小心使用持久连接\n持久连接意味着减少重建连接到MySQL的成本。 当持久连接被创建时，它将保持打开状态直到脚本完成运行。 因为Apache重用它的子进程，下一次进程运行一个新的脚本时，它将重用相同的MySQL连接。\n```\n● PHP：mysql_pconnect()\n```\n\n理论上看起来不错。 但从我个人（和许多其他人）的经验看来，这个功能可能会导致更多麻烦。 你可能会出现连接数限制问题、内存问题等等。\n\nApache总是并行运行的，它创建许多子进程。 这是持久连接在这种环境中不能很好工作的主要原因。 在你考虑使用mysql_pconnect()之前，请咨询你的系统管理员。","source":"_posts/mysql_bestpractice.md","raw":"---\ntitle: MySQL最佳实践\ntags: [Mysql,DB,数据库]\ncategories: DB\ntoc: true\ndate: 2016-12-06\n\n---\n\n## 优化查询的查询缓存\n大部分MySQL服务器都有查询缓存功能。这是提高性能的最有效的方法之一，这是由数据库引擎私下处理的。当同一个查询被多次执行，结果会直接从缓存里提取，这样速度就很快。\n\n主要的问题是，这对程序员来说太简单了，不容易看到，我们很多人都容易忽略。我们实际上是可以组织查询缓存执行任务的。\n```\n// query cache does NOT work\n$r = mysql_query(\"SELECT username FROM user WHERE signup_date >= CURDATE()\");\n  \n// query cache works!\n$today = date(\"Y-m-d\");\n$r = mysql_query(\"SELECT username FROM user WHERE signup_date >= '$today'\");\n```\n查询缓存在第一行不执行的原因在于CURDTE()功能的使用。这适用于所有的非确定性功能，就像NOW()和RAND()等等。。。因为功能返回的结果是可变的。MySQL决定禁用查询器的查询缓存。我们所需要做的是通过添加一额外一行PHP，在查询前阻止它发生。\n\n##EXPLAIN你的选择查询\n使用EXPLAIN关键词可以帮助了解MySQL是怎样运行你的查询的。这有助于发现瓶颈和查询或表结构的其它问题。\n\nEXPLAIN的查询结果会展示哪一个索引被使用过，表示怎样扫描和储存的，等等。。。\n\n选择一个SELECT查询（一个有连接的复杂查询会更好），在它的前面添加关键词EXPLAIN，这样就可以直接使用数据库了。结果会以一个漂亮的表来展示。例如，就好比我执行连接时忘了添加一栏的索引：\n\n\n\n现在它只会从表2里面扫描9和16行，而非扫描7883行。经验法则是乘以所有“行”那一栏的数字，你的查询性能会跟结果数字成比例的。\n\n##获取唯一行时使用LIMIT 1\n有时当你查表时，你已经知道你正在查找的结果只有一行。你可能正在获取唯一记录，或者你可能只是查询是否存在满足你的WHERE子句条件的记录。\n\n在这种情况下，将LIMIT 1添加到查询条件中可以提高性能。这样，数据库引擎将在找到刚刚第一个记录之后停止扫描记录，而不是遍历整个表或索引。\n```\n// do I have any users from Alabama?\n  \n// what NOT to do:\n$r = mysql_query(\"SELECT * FROM user WHERE state = 'Alabama'\");\nif (mysql_num_rows($r) > 0) {\n    // ...\n}\n  \n// much better:\n$r = mysql_query(\"SELECT 1 FROM user WHERE state = 'Alabama' LIMIT 1\");\nif (mysql_num_rows($r) > 0) {\n    // ...\n}\n```\n\n##索引搜索字段\n索引不仅仅是为了主键或唯一键。如果你会在你的表中按照任何列搜索，你就都应该索引它们。\n\n\n正如你所看到的，这个规则也适用于如 \"last_name LIKE 'a%'\"的部分字符串搜索。当从字符串的开头搜索时，MySQL就可以使用那一列的索引。\n\n你也应该明白什么样搜索可以不使用有规律的索引。例如，当搜索一个单词时（例如，\"WHERE post_content LIKE '%apple%'\"），你将不会看到普通索引的好处。你最好使用 mysql 全文搜索或者构建你自己的索引解决方案。\n\n## 索引并对连接使用同样的字段类型\n如果你的应用程序包含许多连接查询, 你需要确保连接的字段在两张表上都建立了索引。 这会影响MySQL如何内部优化连接操作。\n\n此外,被连接的字段,需要使用同样类型。例如, 如果你使用一个DECIMAL字段, 连接另一张表的INT字段, MySQL将无法使用至少一个索引。 即使字符编码也需要使用相同的字符类型。\n```\n// looking for companies in my state\n$r = mysql_query(\"SELECT company_name FROM users\n    LEFT JOIN companies ON (users.state = companies.state)\n    WHERE users.id = $user_id\");\n  \n// both state columns should be indexed\n// and they both should be the same type and character encoding\n// or MySQL might do full table scans\n```\n\n## 不要ORDER BY RAND()\n起初这是一个听起来挺酷的技巧, 让许多菜鸟程序员陷入了这个陷阱。但你可能不知道，一旦你开始在查询中使用它，你创建了非常可怕的查询瓶颈。\n\n如果你真的需要对结果随机排序, 这有一个更好的方法。补充一些额外代码,你将可以防止当数据成指数级增长时造成的瓶颈。关键问题是，MySQL必须在排序之前对表中的每一行执行RAND()操作（这需要处理能力），并且仅仅给出一行。\n```\n// what NOT to do:\n$r = mysql_query(\"SELECT username FROM user ORDER BY RAND() LIMIT 1\");\n  \n// much better:\n  \n$r = mysql_query(\"SELECT count(*) FROM user\");\n$d = mysql_fetch_row($r);\n$rand = mt_rand(0,$d[0] - 1);\n  \n$r = mysql_query(\"SELECT username FROM user LIMIT $rand, 1\");\n```\n所以挑选一个小于结果数的随机数，并将其用作LIMIT子句中的偏移量。\n\n## 避免使用SELECT *\n从数据表中读取的数据越多，查询操作速度就越慢。它增加了磁盘操作所需的时间。此外，当数据库服务器与Web服务器分开时，由于必须在服务器之间传输数据，将会有更长的网络延迟。\n\n这是一个好习惯：当你使用SELECT语句时总是指定你需要的列。\n```\n// not preferred\n$r = mysql_query(\"SELECT * FROM user WHERE user_id = 1\");\n$d = mysql_fetch_assoc($r);\necho \"Welcome {$d['username']}\";\n  \n// better:\n$r = mysql_query(\"SELECT username FROM user WHERE user_id = 1\");\n$d = mysql_fetch_assoc($r);\necho \"Welcome {$d['username']}\";\n  \n// the differences are more significant with bigger result sets\n```\n\n## 几乎总是有一个id字段\n在每个以id列为PRIMARY KEY的数据表中，优先选择AUTO_INCREMENT或者INT。 也可以优选使用UNSIGNED，因为该值不能为负的。\n\n即使你拥有一个具有唯一用户名字段的用户表，也不要将其作为主键。 VARCHAR字段作为主键（检索）速度较慢。通过内部ID引用所有的用户数据，你的代码中将更加结构化。\n\n有些后台操作是由MySQL引擎本身完成的，它在内部使用主键字段。当数据库设置越复杂（集群，分区等...），这就变得更加重要了。\n\n这个规则的一个可能的例外是“关联表”，用于两个表之间的多对多类型的关联。例如，“posts_tags”表中包含两列：post_id，tag_id，用于保存表名为“post”和“tags”的两个表之间的关系。这些表可以具有包含两个id字段的PRIMARY键。\n\n## 相比VARCHAR优先使用ENUM\nENUM枚举类型是非常快速和紧凑的。在内部它们像TINYINT一样存储，但它们可以包含和显示字符串值。这使他们成为某些领域的完美候选。\n\n如果有一个字段只包含几种不同的值，请使用ENUM而不是VARCHAR。例如，它可以是名为“status”的列，并且只包含诸如“active”，“inactive”，“pending”，“expired”等的值...\n\n关于如何重构你的数据表，甚至有一种方法是可以从MySQL本身得到“建议”。 当你有一个VARCHAR字段，它实际上建议你将该列类型更改为ENUM。这通过调用PROCEDURE ANALYZE()来完成。 \n\n## 使用PROCEDURE ANALYSE()获取建议\nPROCEDURE ANALYSE() 将使用MySQL分析列结构和表中的实际数据，为你提供一些建议。它只有在数据表中有实际数据时才有用，因为这在分析决策时很重要。\n例如，如果你创建了一个INT类型的主键，但没有太多行，MySQL则可能建议您改用MEDIUMINT。或者如果你使用VARCHAR字段，如果表里只有很少的取值，你可能会得到一个建议是将其转换为ENUM。\n你也可以在其中一个表视图中单击phpmyadmin中的“建议表结构”链接来执行此操作。\n请记住，这些只是建议。 如果你的数据表变得越来越大，他们甚至可能不是正确的建议。至于如何修改最终是你来决定。\n\n## 如果可以的话使用NOT NULL\n除非你有非常重要的理由使用NULL值，否则你应该设置你的列为NOT NULL。\n首先，问一下你自己在空字符串值和NULL值之间（对应INT字段：0 vs. NULL）是否有任何的不同.如果没有理由一起使用这两个，那么你就不需要一个NULL字段（你知道在Oracle中NULL和空字符串是一样的吗？）。\nNULL列需要额外的空间，他们增加了你的比较语句的复杂度。如果可以的话尽量避免它们。当然，我理解一些人，他们也许有非常重要的理由使用NULL值，这不总是一件坏事。\n摘自MySQL 文档：\n“NULL列在行记录它们的值是否为NULL时需要额外的空间。例如MyISAM 表，每一个NULL列拥有额外的一个比特，聚集在最近的字节。\"\n\n##  预处理语句\n使用预处理语句有诸多好处，包括更高的性能和更好的安全性。\n预处理语句默认情况下会过滤绑定到它的变量，这对于避免SQL注入攻击极为有效。当然你也可以指定要过滤的变量。但这些方法更容易出现人为错误，也更容易被程序员遗忘。这在使用框架或 ORM 的时候会出现一些问题。\n既然我们关注性能，那就应该说说这个方面的好处。当在应用中多次使用同一个查询的时候，它的好处特别明显。既然向同一个预备好的语句中传入不同的参数值，MySQL 对这个语句也只会进行一次解析。\n同时，最新版本的 MySQL 在传输预备好的语句时会采用二进制形式，这样做的作用非常明显，而且对减少网络延迟很有帮助。\n曾经有一段时间，许多程序员为了一个重要的原因则避免使用预处理语句。这个原因就是，它们不会被MySQL 缓存。不过在 5.1 版本的某个时候，查询缓存也得到的支持。\n想在 PHP 中使用预处理语句，你可以看看 mysqli 扩展 或使用数据抽象层，如 PDO。\n```\n // create a prepared statement\nif ($stmt = $mysqli->prepare(\"SELECT username FROM user WHERE state=?\")) {\n  \n    // bind parameters\n    $stmt->bind_param(\"s\", $state);\n  \n    // execute\n    $stmt->execute();\n  \n    // bind result variables\n    $stmt->bind_result($username);\n  \n    // fetch value\n    $stmt->fetch();\n  \n    printf(\"%s is from %s\\n\", $username, $state);\n  \n    $stmt->close();\n}\n```\n\n## 无缓冲查询\n通常当你从脚本执行一个查询，在它可以继续后面的任务之前将需要等待查询执行完成。你可以使用无缓冲的查询来改变这一情况。\n在PHP 文档中对  mysql_unbuffered_query() f函数有一个很好的解释： \n“\n \"mysql_unbuffered_query() 发送SQL查询语句到MySQL不会像 mysql_query()那样自动地取并缓冲结果行。这让产生大量结果集的查询节省了大量的内存，在第一行已经被取回时你就可以立即在结果集上继续工作，而不用等到SQL查询被执行完成。\"\n然而，它有一定的局限性。你必须在执行另一个查询之前读取所有的行或调用mysql_free_result() 。另外你不能在结果集上使用mysql_num_rows() 或 mysql_data_seek() 。\n\n## 使用 UNSIGNED INT 存储IP地址\n很多程序员没有意识到可以使用整数类型的字段来存储 IP 地址，所以一直使用 VARCHAR(15) 类型的字段。使用 INT 只需要 4 个字节的空间，而且字段长度固定。\n\n必须确保列是 UNSINGED INT 类型，因为 IP 地址可能会用到 32 位无符号整型数据的每一个位。\n\n在查询中可以使用 INET_ATON() 来把一个IP转换为整数，用 INET_NTOA() 来进行相反的操作。在 PHP 也有类似的函数，ip2long() 和 long2ip()。\n$r = \"UPDATE users SET ip = INET_ATON('{$_SERVER['REMOTE_ADDR']}') WHERE user_id = $user_id\";\n\n## 固定长度（静态）的表会更快\n（译者注：这里提到的表的长度，实际是指表头的长度，即表中每条数据占用的空间大小，而不是指表的数据量）\n\n如果表中所有列都是“固定长度”，那么这个表被认为是“静态”或“固定长度”的。不固定的列类型包括 VARCHAR、TEXT、BLOB等。即使表中只包含一个这些类型的列，这个表就不再是固定长度的，MySQL 引擎会以不同的方式来处理它。\n固定长度的表会提高性能，因为 MySQL 引擎在记录中检索的时候速度会更快。如果想读取表中的某一地，它可以直接计算出这一行的位置。如果行的大小不固定，那就需要在主键中进行检索。\n\n它们也易于缓存，崩溃后容易重建。不过它们也会占用更多空间。例如，如果你把一个 VARCHAR(20) 的字符改为 CHAR(20) 类型，它会总是占用 20 个字节，不管里面存的是什么内容。\n\n你可以使用“垂直分区”技术，将长度变化的列拆分到另一张表中。来看看：\n\n## 垂直分区\n垂直分区是为了优化表结构而对其进行纵向拆分的行为。\n\n示例 1: 你可能会有一张用户表，包含家庭住址，而这个不是一个常用数据。这时候你可以选择把表拆分开，将住址信息保存到另一个表中。这样你的主用户表就会更小。如你所知，表越小越快。\n\n示例 2: 表中有一个 \"last_login\" 字段，用户每次登录网站都会更新这个字段，而每次更新都会导致这个表缓存的查询数据被清空。这种情况下你可以将那个字段放到另一张表里，保持用户表更新量最小。\n\n不过你也需要确保不会经常联合查询分开后的两张表，要不然你就得忍受由这带来的性能下降。\n\n## 拆分大型DELETE或INSERT语句\n如果你需要在网站上执行大型DELETE或INSERT查询，则需要注意不要影响网络流量。当执行大型语句时，它会锁表并使你的Web应用程序停止。\nApach运行许多并行进程/线程。 因此它执行脚本效率很高。所以服务器不期望打开过多的连接和进程，这很消耗资源，特别是内存。\n\n如果你锁表很长时间（如30秒或更长），在一个高流量的网站，会导致进程和查询堆积，处理这些进程和查询可能需要很长时间，最终甚至使你的网站崩溃。\n如果你的维护脚本需要删除大量的行，只需使用LIMIT子句，以避免阻塞。\n```\nwhile (1) {\n    mysql_query(\"DELETE FROM logs WHERE log_date <= '2009-10-01' LIMIT 10000\");\n    if (mysql_affected_rows() == 0) {\n        // done deleting\n        break;\n    }\n    // you can even pause a bit\n    usleep(50000);\n}\n```\n\n## 越少的列越快\n对于数据库引擎，磁盘可能是最重要的瓶颈。更小更紧凑的数据、减少磁盘传输量，通常有助于性能提高。\n\nMySQL文档Storage Requirements 有所有数据类型清单。\n\n如果已知表具有很少的行，则没有理由是主键类型为INT，可以用MEDIUMINT、SMALLINT代替，甚至在某些情况下使用TINYINT。 如果不需要完整时间记录，请使用DATE而不是DATETIME。\n\n确保留下合理的扩展空间，不然你可能会像Slashdot这样。\n\n## 选择正确的存储引擎\nMySQL有两个主要存储引擎，MyISAM和InnoDB。 每个都有自己的优点和缺点。\n\nMyISAM适用于读取繁重的应用程序，但是当有很多写入时它不能很好地扩展。 即使你正在更新一行的一个字段，整个表也被锁定，并且在语句执行完成之前，其他进程甚至无法读取该字段。 MyISAM在计算SELECT COUNT（*）的查询时非常快。\n\nInnoDB是一个更复杂的存储引擎，对于大多数小的应用程序，它比MyISAM慢。 但它支持基于行的锁定，使其更好地扩展。 它还支持一些更高级的功能，比如事务。\n- MyISAM存储引擎\n- InnoDB存储引擎\n\n## 使用对象关系映射器（ORM, Object Relational Mapper）\n通过使用ORM（对象关系映射器），你可以获得一定的性能提升。ORM可以完成的一切事情，手动编码也可完成。但这可能意味着需要太多额外的工作，并且需要高水平的专业知识。\n\nORM以“延迟加载”著称。这意味着它们仅在需要时获取实际值。但是你需要小心处理他们，否则你可能最终创建了许多微型查询，这会降低数据库性能。\n\nORM还可以将多个查询批处理到事务中，其操作速度比向数据库发送单个查询快得多。\n\n目前我最喜欢的PHP-ORM是Doctrine。我写了一篇关于如何安装Doctrine与CodeIgniter的文章（install Doctrine with CodeIgniter）。\n\n## 小心使用持久连接\n持久连接意味着减少重建连接到MySQL的成本。 当持久连接被创建时，它将保持打开状态直到脚本完成运行。 因为Apache重用它的子进程，下一次进程运行一个新的脚本时，它将重用相同的MySQL连接。\n```\n● PHP：mysql_pconnect()\n```\n\n理论上看起来不错。 但从我个人（和许多其他人）的经验看来，这个功能可能会导致更多麻烦。 你可能会出现连接数限制问题、内存问题等等。\n\nApache总是并行运行的，它创建许多子进程。 这是持久连接在这种环境中不能很好工作的主要原因。 在你考虑使用mysql_pconnect()之前，请咨询你的系统管理员。","slug":"mysql_bestpractice","published":1,"updated":"2016-12-05T13:54:25.191Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwc5273m0005o8l0lnn26n77","content":"<h2 id=\"优化查询的查询缓存\"><a href=\"#优化查询的查询缓存\" class=\"headerlink\" title=\"优化查询的查询缓存\"></a>优化查询的查询缓存</h2><p>大部分MySQL服务器都有查询缓存功能。这是提高性能的最有效的方法之一，这是由数据库引擎私下处理的。当同一个查询被多次执行，结果会直接从缓存里提取，这样速度就很快。</p>\n<p>主要的问题是，这对程序员来说太简单了，不容易看到，我们很多人都容易忽略。我们实际上是可以组织查询缓存执行任务的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">// query cache does NOT work</div><div class=\"line\">$r = mysql_query(&quot;SELECT username FROM user WHERE signup_date &gt;= CURDATE()&quot;);</div><div class=\"line\">  </div><div class=\"line\">// query cache works!</div><div class=\"line\">$today = date(&quot;Y-m-d&quot;);</div><div class=\"line\">$r = mysql_query(&quot;SELECT username FROM user WHERE signup_date &gt;= &apos;$today&apos;&quot;);</div></pre></td></tr></table></figure></p>\n<p>查询缓存在第一行不执行的原因在于CURDTE()功能的使用。这适用于所有的非确定性功能，就像NOW()和RAND()等等。。。因为功能返回的结果是可变的。MySQL决定禁用查询器的查询缓存。我们所需要做的是通过添加一额外一行PHP，在查询前阻止它发生。</p>\n<p>##EXPLAIN你的选择查询<br>使用EXPLAIN关键词可以帮助了解MySQL是怎样运行你的查询的。这有助于发现瓶颈和查询或表结构的其它问题。</p>\n<p>EXPLAIN的查询结果会展示哪一个索引被使用过，表示怎样扫描和储存的，等等。。。</p>\n<p>选择一个SELECT查询（一个有连接的复杂查询会更好），在它的前面添加关键词EXPLAIN，这样就可以直接使用数据库了。结果会以一个漂亮的表来展示。例如，就好比我执行连接时忘了添加一栏的索引：</p>\n<p>现在它只会从表2里面扫描9和16行，而非扫描7883行。经验法则是乘以所有“行”那一栏的数字，你的查询性能会跟结果数字成比例的。</p>\n<p>##获取唯一行时使用LIMIT 1<br>有时当你查表时，你已经知道你正在查找的结果只有一行。你可能正在获取唯一记录，或者你可能只是查询是否存在满足你的WHERE子句条件的记录。</p>\n<p>在这种情况下，将LIMIT 1添加到查询条件中可以提高性能。这样，数据库引擎将在找到刚刚第一个记录之后停止扫描记录，而不是遍历整个表或索引。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">// do I have any users from Alabama?</div><div class=\"line\">  </div><div class=\"line\">// what NOT to do:</div><div class=\"line\">$r = mysql_query(&quot;SELECT * FROM user WHERE state = &apos;Alabama&apos;&quot;);</div><div class=\"line\">if (mysql_num_rows($r) &gt; 0) &#123;</div><div class=\"line\">    // ...</div><div class=\"line\">&#125;</div><div class=\"line\">  </div><div class=\"line\">// much better:</div><div class=\"line\">$r = mysql_query(&quot;SELECT 1 FROM user WHERE state = &apos;Alabama&apos; LIMIT 1&quot;);</div><div class=\"line\">if (mysql_num_rows($r) &gt; 0) &#123;</div><div class=\"line\">    // ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>##索引搜索字段<br>索引不仅仅是为了主键或唯一键。如果你会在你的表中按照任何列搜索，你就都应该索引它们。</p>\n<p>正如你所看到的，这个规则也适用于如 “last_name LIKE ‘a%’”的部分字符串搜索。当从字符串的开头搜索时，MySQL就可以使用那一列的索引。</p>\n<p>你也应该明白什么样搜索可以不使用有规律的索引。例如，当搜索一个单词时（例如，”WHERE post_content LIKE ‘%apple%’”），你将不会看到普通索引的好处。你最好使用 mysql 全文搜索或者构建你自己的索引解决方案。</p>\n<h2 id=\"索引并对连接使用同样的字段类型\"><a href=\"#索引并对连接使用同样的字段类型\" class=\"headerlink\" title=\"索引并对连接使用同样的字段类型\"></a>索引并对连接使用同样的字段类型</h2><p>如果你的应用程序包含许多连接查询, 你需要确保连接的字段在两张表上都建立了索引。 这会影响MySQL如何内部优化连接操作。</p>\n<p>此外,被连接的字段,需要使用同样类型。例如, 如果你使用一个DECIMAL字段, 连接另一张表的INT字段, MySQL将无法使用至少一个索引。 即使字符编码也需要使用相同的字符类型。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">// looking for companies in my state</div><div class=\"line\">$r = mysql_query(&quot;SELECT company_name FROM users</div><div class=\"line\">    LEFT JOIN companies ON (users.state = companies.state)</div><div class=\"line\">    WHERE users.id = $user_id&quot;);</div><div class=\"line\">  </div><div class=\"line\">// both state columns should be indexed</div><div class=\"line\">// and they both should be the same type and character encoding</div><div class=\"line\">// or MySQL might do full table scans</div></pre></td></tr></table></figure></p>\n<h2 id=\"不要ORDER-BY-RAND\"><a href=\"#不要ORDER-BY-RAND\" class=\"headerlink\" title=\"不要ORDER BY RAND()\"></a>不要ORDER BY RAND()</h2><p>起初这是一个听起来挺酷的技巧, 让许多菜鸟程序员陷入了这个陷阱。但你可能不知道，一旦你开始在查询中使用它，你创建了非常可怕的查询瓶颈。</p>\n<p>如果你真的需要对结果随机排序, 这有一个更好的方法。补充一些额外代码,你将可以防止当数据成指数级增长时造成的瓶颈。关键问题是，MySQL必须在排序之前对表中的每一行执行RAND()操作（这需要处理能力），并且仅仅给出一行。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">// what NOT to do:</div><div class=\"line\">$r = mysql_query(&quot;SELECT username FROM user ORDER BY RAND() LIMIT 1&quot;);</div><div class=\"line\">  </div><div class=\"line\">// much better:</div><div class=\"line\">  </div><div class=\"line\">$r = mysql_query(&quot;SELECT count(*) FROM user&quot;);</div><div class=\"line\">$d = mysql_fetch_row($r);</div><div class=\"line\">$rand = mt_rand(0,$d[0] - 1);</div><div class=\"line\">  </div><div class=\"line\">$r = mysql_query(&quot;SELECT username FROM user LIMIT $rand, 1&quot;);</div></pre></td></tr></table></figure></p>\n<p>所以挑选一个小于结果数的随机数，并将其用作LIMIT子句中的偏移量。</p>\n<h2 id=\"避免使用SELECT\"><a href=\"#避免使用SELECT\" class=\"headerlink\" title=\"避免使用SELECT *\"></a>避免使用SELECT *</h2><p>从数据表中读取的数据越多，查询操作速度就越慢。它增加了磁盘操作所需的时间。此外，当数据库服务器与Web服务器分开时，由于必须在服务器之间传输数据，将会有更长的网络延迟。</p>\n<p>这是一个好习惯：当你使用SELECT语句时总是指定你需要的列。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">// not preferred</div><div class=\"line\">$r = mysql_query(&quot;SELECT * FROM user WHERE user_id = 1&quot;);</div><div class=\"line\">$d = mysql_fetch_assoc($r);</div><div class=\"line\">echo &quot;Welcome &#123;$d[&apos;username&apos;]&#125;&quot;;</div><div class=\"line\">  </div><div class=\"line\">// better:</div><div class=\"line\">$r = mysql_query(&quot;SELECT username FROM user WHERE user_id = 1&quot;);</div><div class=\"line\">$d = mysql_fetch_assoc($r);</div><div class=\"line\">echo &quot;Welcome &#123;$d[&apos;username&apos;]&#125;&quot;;</div><div class=\"line\">  </div><div class=\"line\">// the differences are more significant with bigger result sets</div></pre></td></tr></table></figure></p>\n<h2 id=\"几乎总是有一个id字段\"><a href=\"#几乎总是有一个id字段\" class=\"headerlink\" title=\"几乎总是有一个id字段\"></a>几乎总是有一个id字段</h2><p>在每个以id列为PRIMARY KEY的数据表中，优先选择AUTO_INCREMENT或者INT。 也可以优选使用UNSIGNED，因为该值不能为负的。</p>\n<p>即使你拥有一个具有唯一用户名字段的用户表，也不要将其作为主键。 VARCHAR字段作为主键（检索）速度较慢。通过内部ID引用所有的用户数据，你的代码中将更加结构化。</p>\n<p>有些后台操作是由MySQL引擎本身完成的，它在内部使用主键字段。当数据库设置越复杂（集群，分区等…），这就变得更加重要了。</p>\n<p>这个规则的一个可能的例外是“关联表”，用于两个表之间的多对多类型的关联。例如，“posts_tags”表中包含两列：post_id，tag_id，用于保存表名为“post”和“tags”的两个表之间的关系。这些表可以具有包含两个id字段的PRIMARY键。</p>\n<h2 id=\"相比VARCHAR优先使用ENUM\"><a href=\"#相比VARCHAR优先使用ENUM\" class=\"headerlink\" title=\"相比VARCHAR优先使用ENUM\"></a>相比VARCHAR优先使用ENUM</h2><p>ENUM枚举类型是非常快速和紧凑的。在内部它们像TINYINT一样存储，但它们可以包含和显示字符串值。这使他们成为某些领域的完美候选。</p>\n<p>如果有一个字段只包含几种不同的值，请使用ENUM而不是VARCHAR。例如，它可以是名为“status”的列，并且只包含诸如“active”，“inactive”，“pending”，“expired”等的值…</p>\n<p>关于如何重构你的数据表，甚至有一种方法是可以从MySQL本身得到“建议”。 当你有一个VARCHAR字段，它实际上建议你将该列类型更改为ENUM。这通过调用PROCEDURE ANALYZE()来完成。 </p>\n<h2 id=\"使用PROCEDURE-ANALYSE-获取建议\"><a href=\"#使用PROCEDURE-ANALYSE-获取建议\" class=\"headerlink\" title=\"使用PROCEDURE ANALYSE()获取建议\"></a>使用PROCEDURE ANALYSE()获取建议</h2><p>PROCEDURE ANALYSE() 将使用MySQL分析列结构和表中的实际数据，为你提供一些建议。它只有在数据表中有实际数据时才有用，因为这在分析决策时很重要。<br>例如，如果你创建了一个INT类型的主键，但没有太多行，MySQL则可能建议您改用MEDIUMINT。或者如果你使用VARCHAR字段，如果表里只有很少的取值，你可能会得到一个建议是将其转换为ENUM。<br>你也可以在其中一个表视图中单击phpmyadmin中的“建议表结构”链接来执行此操作。<br>请记住，这些只是建议。 如果你的数据表变得越来越大，他们甚至可能不是正确的建议。至于如何修改最终是你来决定。</p>\n<h2 id=\"如果可以的话使用NOT-NULL\"><a href=\"#如果可以的话使用NOT-NULL\" class=\"headerlink\" title=\"如果可以的话使用NOT NULL\"></a>如果可以的话使用NOT NULL</h2><p>除非你有非常重要的理由使用NULL值，否则你应该设置你的列为NOT NULL。<br>首先，问一下你自己在空字符串值和NULL值之间（对应INT字段：0 vs. NULL）是否有任何的不同.如果没有理由一起使用这两个，那么你就不需要一个NULL字段（你知道在Oracle中NULL和空字符串是一样的吗？）。<br>NULL列需要额外的空间，他们增加了你的比较语句的复杂度。如果可以的话尽量避免它们。当然，我理解一些人，他们也许有非常重要的理由使用NULL值，这不总是一件坏事。<br>摘自MySQL 文档：<br>“NULL列在行记录它们的值是否为NULL时需要额外的空间。例如MyISAM 表，每一个NULL列拥有额外的一个比特，聚集在最近的字节。”</p>\n<h2 id=\"预处理语句\"><a href=\"#预处理语句\" class=\"headerlink\" title=\"预处理语句\"></a>预处理语句</h2><p>使用预处理语句有诸多好处，包括更高的性能和更好的安全性。<br>预处理语句默认情况下会过滤绑定到它的变量，这对于避免SQL注入攻击极为有效。当然你也可以指定要过滤的变量。但这些方法更容易出现人为错误，也更容易被程序员遗忘。这在使用框架或 ORM 的时候会出现一些问题。<br>既然我们关注性能，那就应该说说这个方面的好处。当在应用中多次使用同一个查询的时候，它的好处特别明显。既然向同一个预备好的语句中传入不同的参数值，MySQL 对这个语句也只会进行一次解析。<br>同时，最新版本的 MySQL 在传输预备好的语句时会采用二进制形式，这样做的作用非常明显，而且对减少网络延迟很有帮助。<br>曾经有一段时间，许多程序员为了一个重要的原因则避免使用预处理语句。这个原因就是，它们不会被MySQL 缓存。不过在 5.1 版本的某个时候，查询缓存也得到的支持。<br>想在 PHP 中使用预处理语句，你可以看看 mysqli 扩展 或使用数据抽象层，如 PDO。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"> // create a prepared statement</div><div class=\"line\">if ($stmt = $mysqli-&gt;prepare(&quot;SELECT username FROM user WHERE state=?&quot;)) &#123;</div><div class=\"line\">  </div><div class=\"line\">    // bind parameters</div><div class=\"line\">    $stmt-&gt;bind_param(&quot;s&quot;, $state);</div><div class=\"line\">  </div><div class=\"line\">    // execute</div><div class=\"line\">    $stmt-&gt;execute();</div><div class=\"line\">  </div><div class=\"line\">    // bind result variables</div><div class=\"line\">    $stmt-&gt;bind_result($username);</div><div class=\"line\">  </div><div class=\"line\">    // fetch value</div><div class=\"line\">    $stmt-&gt;fetch();</div><div class=\"line\">  </div><div class=\"line\">    printf(&quot;%s is from %s\\n&quot;, $username, $state);</div><div class=\"line\">  </div><div class=\"line\">    $stmt-&gt;close();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"无缓冲查询\"><a href=\"#无缓冲查询\" class=\"headerlink\" title=\"无缓冲查询\"></a>无缓冲查询</h2><p>通常当你从脚本执行一个查询，在它可以继续后面的任务之前将需要等待查询执行完成。你可以使用无缓冲的查询来改变这一情况。<br>在PHP 文档中对  mysql_unbuffered_query() f函数有一个很好的解释：<br>“<br> “mysql_unbuffered_query() 发送SQL查询语句到MySQL不会像 mysql_query()那样自动地取并缓冲结果行。这让产生大量结果集的查询节省了大量的内存，在第一行已经被取回时你就可以立即在结果集上继续工作，而不用等到SQL查询被执行完成。”<br>然而，它有一定的局限性。你必须在执行另一个查询之前读取所有的行或调用mysql_free_result() 。另外你不能在结果集上使用mysql_num_rows() 或 mysql_data_seek() 。</p>\n<h2 id=\"使用-UNSIGNED-INT-存储IP地址\"><a href=\"#使用-UNSIGNED-INT-存储IP地址\" class=\"headerlink\" title=\"使用 UNSIGNED INT 存储IP地址\"></a>使用 UNSIGNED INT 存储IP地址</h2><p>很多程序员没有意识到可以使用整数类型的字段来存储 IP 地址，所以一直使用 VARCHAR(15) 类型的字段。使用 INT 只需要 4 个字节的空间，而且字段长度固定。</p>\n<p>必须确保列是 UNSINGED INT 类型，因为 IP 地址可能会用到 32 位无符号整型数据的每一个位。</p>\n<p>在查询中可以使用 INET_ATON() 来把一个IP转换为整数，用 INET_NTOA() 来进行相反的操作。在 PHP 也有类似的函数，ip2long() 和 long2ip()。<br>$r = “UPDATE users SET ip = INET_ATON(‘{$_SERVER[‘REMOTE_ADDR’]}’) WHERE user_id = $user_id”;</p>\n<h2 id=\"固定长度（静态）的表会更快\"><a href=\"#固定长度（静态）的表会更快\" class=\"headerlink\" title=\"固定长度（静态）的表会更快\"></a>固定长度（静态）的表会更快</h2><p>（译者注：这里提到的表的长度，实际是指表头的长度，即表中每条数据占用的空间大小，而不是指表的数据量）</p>\n<p>如果表中所有列都是“固定长度”，那么这个表被认为是“静态”或“固定长度”的。不固定的列类型包括 VARCHAR、TEXT、BLOB等。即使表中只包含一个这些类型的列，这个表就不再是固定长度的，MySQL 引擎会以不同的方式来处理它。<br>固定长度的表会提高性能，因为 MySQL 引擎在记录中检索的时候速度会更快。如果想读取表中的某一地，它可以直接计算出这一行的位置。如果行的大小不固定，那就需要在主键中进行检索。</p>\n<p>它们也易于缓存，崩溃后容易重建。不过它们也会占用更多空间。例如，如果你把一个 VARCHAR(20) 的字符改为 CHAR(20) 类型，它会总是占用 20 个字节，不管里面存的是什么内容。</p>\n<p>你可以使用“垂直分区”技术，将长度变化的列拆分到另一张表中。来看看：</p>\n<h2 id=\"垂直分区\"><a href=\"#垂直分区\" class=\"headerlink\" title=\"垂直分区\"></a>垂直分区</h2><p>垂直分区是为了优化表结构而对其进行纵向拆分的行为。</p>\n<p>示例 1: 你可能会有一张用户表，包含家庭住址，而这个不是一个常用数据。这时候你可以选择把表拆分开，将住址信息保存到另一个表中。这样你的主用户表就会更小。如你所知，表越小越快。</p>\n<p>示例 2: 表中有一个 “last_login” 字段，用户每次登录网站都会更新这个字段，而每次更新都会导致这个表缓存的查询数据被清空。这种情况下你可以将那个字段放到另一张表里，保持用户表更新量最小。</p>\n<p>不过你也需要确保不会经常联合查询分开后的两张表，要不然你就得忍受由这带来的性能下降。</p>\n<h2 id=\"拆分大型DELETE或INSERT语句\"><a href=\"#拆分大型DELETE或INSERT语句\" class=\"headerlink\" title=\"拆分大型DELETE或INSERT语句\"></a>拆分大型DELETE或INSERT语句</h2><p>如果你需要在网站上执行大型DELETE或INSERT查询，则需要注意不要影响网络流量。当执行大型语句时，它会锁表并使你的Web应用程序停止。<br>Apach运行许多并行进程/线程。 因此它执行脚本效率很高。所以服务器不期望打开过多的连接和进程，这很消耗资源，特别是内存。</p>\n<p>如果你锁表很长时间（如30秒或更长），在一个高流量的网站，会导致进程和查询堆积，处理这些进程和查询可能需要很长时间，最终甚至使你的网站崩溃。<br>如果你的维护脚本需要删除大量的行，只需使用LIMIT子句，以避免阻塞。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">while (1) &#123;</div><div class=\"line\">    mysql_query(&quot;DELETE FROM logs WHERE log_date &lt;= &apos;2009-10-01&apos; LIMIT 10000&quot;);</div><div class=\"line\">    if (mysql_affected_rows() == 0) &#123;</div><div class=\"line\">        // done deleting</div><div class=\"line\">        break;</div><div class=\"line\">    &#125;</div><div class=\"line\">    // you can even pause a bit</div><div class=\"line\">    usleep(50000);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"越少的列越快\"><a href=\"#越少的列越快\" class=\"headerlink\" title=\"越少的列越快\"></a>越少的列越快</h2><p>对于数据库引擎，磁盘可能是最重要的瓶颈。更小更紧凑的数据、减少磁盘传输量，通常有助于性能提高。</p>\n<p>MySQL文档Storage Requirements 有所有数据类型清单。</p>\n<p>如果已知表具有很少的行，则没有理由是主键类型为INT，可以用MEDIUMINT、SMALLINT代替，甚至在某些情况下使用TINYINT。 如果不需要完整时间记录，请使用DATE而不是DATETIME。</p>\n<p>确保留下合理的扩展空间，不然你可能会像Slashdot这样。</p>\n<h2 id=\"选择正确的存储引擎\"><a href=\"#选择正确的存储引擎\" class=\"headerlink\" title=\"选择正确的存储引擎\"></a>选择正确的存储引擎</h2><p>MySQL有两个主要存储引擎，MyISAM和InnoDB。 每个都有自己的优点和缺点。</p>\n<p>MyISAM适用于读取繁重的应用程序，但是当有很多写入时它不能很好地扩展。 即使你正在更新一行的一个字段，整个表也被锁定，并且在语句执行完成之前，其他进程甚至无法读取该字段。 MyISAM在计算SELECT COUNT（*）的查询时非常快。</p>\n<p>InnoDB是一个更复杂的存储引擎，对于大多数小的应用程序，它比MyISAM慢。 但它支持基于行的锁定，使其更好地扩展。 它还支持一些更高级的功能，比如事务。</p>\n<ul>\n<li>MyISAM存储引擎</li>\n<li>InnoDB存储引擎</li>\n</ul>\n<h2 id=\"使用对象关系映射器（ORM-Object-Relational-Mapper）\"><a href=\"#使用对象关系映射器（ORM-Object-Relational-Mapper）\" class=\"headerlink\" title=\"使用对象关系映射器（ORM, Object Relational Mapper）\"></a>使用对象关系映射器（ORM, Object Relational Mapper）</h2><p>通过使用ORM（对象关系映射器），你可以获得一定的性能提升。ORM可以完成的一切事情，手动编码也可完成。但这可能意味着需要太多额外的工作，并且需要高水平的专业知识。</p>\n<p>ORM以“延迟加载”著称。这意味着它们仅在需要时获取实际值。但是你需要小心处理他们，否则你可能最终创建了许多微型查询，这会降低数据库性能。</p>\n<p>ORM还可以将多个查询批处理到事务中，其操作速度比向数据库发送单个查询快得多。</p>\n<p>目前我最喜欢的PHP-ORM是Doctrine。我写了一篇关于如何安装Doctrine与CodeIgniter的文章（install Doctrine with CodeIgniter）。</p>\n<h2 id=\"小心使用持久连接\"><a href=\"#小心使用持久连接\" class=\"headerlink\" title=\"小心使用持久连接\"></a>小心使用持久连接</h2><p>持久连接意味着减少重建连接到MySQL的成本。 当持久连接被创建时，它将保持打开状态直到脚本完成运行。 因为Apache重用它的子进程，下一次进程运行一个新的脚本时，它将重用相同的MySQL连接。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">● PHP：mysql_pconnect()</div></pre></td></tr></table></figure></p>\n<p>理论上看起来不错。 但从我个人（和许多其他人）的经验看来，这个功能可能会导致更多麻烦。 你可能会出现连接数限制问题、内存问题等等。</p>\n<p>Apache总是并行运行的，它创建许多子进程。 这是持久连接在这种环境中不能很好工作的主要原因。 在你考虑使用mysql_pconnect()之前，请咨询你的系统管理员。</p>\n","excerpt":"","more":"<h2 id=\"优化查询的查询缓存\"><a href=\"#优化查询的查询缓存\" class=\"headerlink\" title=\"优化查询的查询缓存\"></a>优化查询的查询缓存</h2><p>大部分MySQL服务器都有查询缓存功能。这是提高性能的最有效的方法之一，这是由数据库引擎私下处理的。当同一个查询被多次执行，结果会直接从缓存里提取，这样速度就很快。</p>\n<p>主要的问题是，这对程序员来说太简单了，不容易看到，我们很多人都容易忽略。我们实际上是可以组织查询缓存执行任务的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">// query cache does NOT work</div><div class=\"line\">$r = mysql_query(&quot;SELECT username FROM user WHERE signup_date &gt;= CURDATE()&quot;);</div><div class=\"line\">  </div><div class=\"line\">// query cache works!</div><div class=\"line\">$today = date(&quot;Y-m-d&quot;);</div><div class=\"line\">$r = mysql_query(&quot;SELECT username FROM user WHERE signup_date &gt;= &apos;$today&apos;&quot;);</div></pre></td></tr></table></figure></p>\n<p>查询缓存在第一行不执行的原因在于CURDTE()功能的使用。这适用于所有的非确定性功能，就像NOW()和RAND()等等。。。因为功能返回的结果是可变的。MySQL决定禁用查询器的查询缓存。我们所需要做的是通过添加一额外一行PHP，在查询前阻止它发生。</p>\n<p>##EXPLAIN你的选择查询<br>使用EXPLAIN关键词可以帮助了解MySQL是怎样运行你的查询的。这有助于发现瓶颈和查询或表结构的其它问题。</p>\n<p>EXPLAIN的查询结果会展示哪一个索引被使用过，表示怎样扫描和储存的，等等。。。</p>\n<p>选择一个SELECT查询（一个有连接的复杂查询会更好），在它的前面添加关键词EXPLAIN，这样就可以直接使用数据库了。结果会以一个漂亮的表来展示。例如，就好比我执行连接时忘了添加一栏的索引：</p>\n<p>现在它只会从表2里面扫描9和16行，而非扫描7883行。经验法则是乘以所有“行”那一栏的数字，你的查询性能会跟结果数字成比例的。</p>\n<p>##获取唯一行时使用LIMIT 1<br>有时当你查表时，你已经知道你正在查找的结果只有一行。你可能正在获取唯一记录，或者你可能只是查询是否存在满足你的WHERE子句条件的记录。</p>\n<p>在这种情况下，将LIMIT 1添加到查询条件中可以提高性能。这样，数据库引擎将在找到刚刚第一个记录之后停止扫描记录，而不是遍历整个表或索引。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">// do I have any users from Alabama?</div><div class=\"line\">  </div><div class=\"line\">// what NOT to do:</div><div class=\"line\">$r = mysql_query(&quot;SELECT * FROM user WHERE state = &apos;Alabama&apos;&quot;);</div><div class=\"line\">if (mysql_num_rows($r) &gt; 0) &#123;</div><div class=\"line\">    // ...</div><div class=\"line\">&#125;</div><div class=\"line\">  </div><div class=\"line\">// much better:</div><div class=\"line\">$r = mysql_query(&quot;SELECT 1 FROM user WHERE state = &apos;Alabama&apos; LIMIT 1&quot;);</div><div class=\"line\">if (mysql_num_rows($r) &gt; 0) &#123;</div><div class=\"line\">    // ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>##索引搜索字段<br>索引不仅仅是为了主键或唯一键。如果你会在你的表中按照任何列搜索，你就都应该索引它们。</p>\n<p>正如你所看到的，这个规则也适用于如 “last_name LIKE ‘a%’”的部分字符串搜索。当从字符串的开头搜索时，MySQL就可以使用那一列的索引。</p>\n<p>你也应该明白什么样搜索可以不使用有规律的索引。例如，当搜索一个单词时（例如，”WHERE post_content LIKE ‘%apple%’”），你将不会看到普通索引的好处。你最好使用 mysql 全文搜索或者构建你自己的索引解决方案。</p>\n<h2 id=\"索引并对连接使用同样的字段类型\"><a href=\"#索引并对连接使用同样的字段类型\" class=\"headerlink\" title=\"索引并对连接使用同样的字段类型\"></a>索引并对连接使用同样的字段类型</h2><p>如果你的应用程序包含许多连接查询, 你需要确保连接的字段在两张表上都建立了索引。 这会影响MySQL如何内部优化连接操作。</p>\n<p>此外,被连接的字段,需要使用同样类型。例如, 如果你使用一个DECIMAL字段, 连接另一张表的INT字段, MySQL将无法使用至少一个索引。 即使字符编码也需要使用相同的字符类型。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">// looking for companies in my state</div><div class=\"line\">$r = mysql_query(&quot;SELECT company_name FROM users</div><div class=\"line\">    LEFT JOIN companies ON (users.state = companies.state)</div><div class=\"line\">    WHERE users.id = $user_id&quot;);</div><div class=\"line\">  </div><div class=\"line\">// both state columns should be indexed</div><div class=\"line\">// and they both should be the same type and character encoding</div><div class=\"line\">// or MySQL might do full table scans</div></pre></td></tr></table></figure></p>\n<h2 id=\"不要ORDER-BY-RAND\"><a href=\"#不要ORDER-BY-RAND\" class=\"headerlink\" title=\"不要ORDER BY RAND()\"></a>不要ORDER BY RAND()</h2><p>起初这是一个听起来挺酷的技巧, 让许多菜鸟程序员陷入了这个陷阱。但你可能不知道，一旦你开始在查询中使用它，你创建了非常可怕的查询瓶颈。</p>\n<p>如果你真的需要对结果随机排序, 这有一个更好的方法。补充一些额外代码,你将可以防止当数据成指数级增长时造成的瓶颈。关键问题是，MySQL必须在排序之前对表中的每一行执行RAND()操作（这需要处理能力），并且仅仅给出一行。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">// what NOT to do:</div><div class=\"line\">$r = mysql_query(&quot;SELECT username FROM user ORDER BY RAND() LIMIT 1&quot;);</div><div class=\"line\">  </div><div class=\"line\">// much better:</div><div class=\"line\">  </div><div class=\"line\">$r = mysql_query(&quot;SELECT count(*) FROM user&quot;);</div><div class=\"line\">$d = mysql_fetch_row($r);</div><div class=\"line\">$rand = mt_rand(0,$d[0] - 1);</div><div class=\"line\">  </div><div class=\"line\">$r = mysql_query(&quot;SELECT username FROM user LIMIT $rand, 1&quot;);</div></pre></td></tr></table></figure></p>\n<p>所以挑选一个小于结果数的随机数，并将其用作LIMIT子句中的偏移量。</p>\n<h2 id=\"避免使用SELECT\"><a href=\"#避免使用SELECT\" class=\"headerlink\" title=\"避免使用SELECT *\"></a>避免使用SELECT *</h2><p>从数据表中读取的数据越多，查询操作速度就越慢。它增加了磁盘操作所需的时间。此外，当数据库服务器与Web服务器分开时，由于必须在服务器之间传输数据，将会有更长的网络延迟。</p>\n<p>这是一个好习惯：当你使用SELECT语句时总是指定你需要的列。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">// not preferred</div><div class=\"line\">$r = mysql_query(&quot;SELECT * FROM user WHERE user_id = 1&quot;);</div><div class=\"line\">$d = mysql_fetch_assoc($r);</div><div class=\"line\">echo &quot;Welcome &#123;$d[&apos;username&apos;]&#125;&quot;;</div><div class=\"line\">  </div><div class=\"line\">// better:</div><div class=\"line\">$r = mysql_query(&quot;SELECT username FROM user WHERE user_id = 1&quot;);</div><div class=\"line\">$d = mysql_fetch_assoc($r);</div><div class=\"line\">echo &quot;Welcome &#123;$d[&apos;username&apos;]&#125;&quot;;</div><div class=\"line\">  </div><div class=\"line\">// the differences are more significant with bigger result sets</div></pre></td></tr></table></figure></p>\n<h2 id=\"几乎总是有一个id字段\"><a href=\"#几乎总是有一个id字段\" class=\"headerlink\" title=\"几乎总是有一个id字段\"></a>几乎总是有一个id字段</h2><p>在每个以id列为PRIMARY KEY的数据表中，优先选择AUTO_INCREMENT或者INT。 也可以优选使用UNSIGNED，因为该值不能为负的。</p>\n<p>即使你拥有一个具有唯一用户名字段的用户表，也不要将其作为主键。 VARCHAR字段作为主键（检索）速度较慢。通过内部ID引用所有的用户数据，你的代码中将更加结构化。</p>\n<p>有些后台操作是由MySQL引擎本身完成的，它在内部使用主键字段。当数据库设置越复杂（集群，分区等…），这就变得更加重要了。</p>\n<p>这个规则的一个可能的例外是“关联表”，用于两个表之间的多对多类型的关联。例如，“posts_tags”表中包含两列：post_id，tag_id，用于保存表名为“post”和“tags”的两个表之间的关系。这些表可以具有包含两个id字段的PRIMARY键。</p>\n<h2 id=\"相比VARCHAR优先使用ENUM\"><a href=\"#相比VARCHAR优先使用ENUM\" class=\"headerlink\" title=\"相比VARCHAR优先使用ENUM\"></a>相比VARCHAR优先使用ENUM</h2><p>ENUM枚举类型是非常快速和紧凑的。在内部它们像TINYINT一样存储，但它们可以包含和显示字符串值。这使他们成为某些领域的完美候选。</p>\n<p>如果有一个字段只包含几种不同的值，请使用ENUM而不是VARCHAR。例如，它可以是名为“status”的列，并且只包含诸如“active”，“inactive”，“pending”，“expired”等的值…</p>\n<p>关于如何重构你的数据表，甚至有一种方法是可以从MySQL本身得到“建议”。 当你有一个VARCHAR字段，它实际上建议你将该列类型更改为ENUM。这通过调用PROCEDURE ANALYZE()来完成。 </p>\n<h2 id=\"使用PROCEDURE-ANALYSE-获取建议\"><a href=\"#使用PROCEDURE-ANALYSE-获取建议\" class=\"headerlink\" title=\"使用PROCEDURE ANALYSE()获取建议\"></a>使用PROCEDURE ANALYSE()获取建议</h2><p>PROCEDURE ANALYSE() 将使用MySQL分析列结构和表中的实际数据，为你提供一些建议。它只有在数据表中有实际数据时才有用，因为这在分析决策时很重要。<br>例如，如果你创建了一个INT类型的主键，但没有太多行，MySQL则可能建议您改用MEDIUMINT。或者如果你使用VARCHAR字段，如果表里只有很少的取值，你可能会得到一个建议是将其转换为ENUM。<br>你也可以在其中一个表视图中单击phpmyadmin中的“建议表结构”链接来执行此操作。<br>请记住，这些只是建议。 如果你的数据表变得越来越大，他们甚至可能不是正确的建议。至于如何修改最终是你来决定。</p>\n<h2 id=\"如果可以的话使用NOT-NULL\"><a href=\"#如果可以的话使用NOT-NULL\" class=\"headerlink\" title=\"如果可以的话使用NOT NULL\"></a>如果可以的话使用NOT NULL</h2><p>除非你有非常重要的理由使用NULL值，否则你应该设置你的列为NOT NULL。<br>首先，问一下你自己在空字符串值和NULL值之间（对应INT字段：0 vs. NULL）是否有任何的不同.如果没有理由一起使用这两个，那么你就不需要一个NULL字段（你知道在Oracle中NULL和空字符串是一样的吗？）。<br>NULL列需要额外的空间，他们增加了你的比较语句的复杂度。如果可以的话尽量避免它们。当然，我理解一些人，他们也许有非常重要的理由使用NULL值，这不总是一件坏事。<br>摘自MySQL 文档：<br>“NULL列在行记录它们的值是否为NULL时需要额外的空间。例如MyISAM 表，每一个NULL列拥有额外的一个比特，聚集在最近的字节。”</p>\n<h2 id=\"预处理语句\"><a href=\"#预处理语句\" class=\"headerlink\" title=\"预处理语句\"></a>预处理语句</h2><p>使用预处理语句有诸多好处，包括更高的性能和更好的安全性。<br>预处理语句默认情况下会过滤绑定到它的变量，这对于避免SQL注入攻击极为有效。当然你也可以指定要过滤的变量。但这些方法更容易出现人为错误，也更容易被程序员遗忘。这在使用框架或 ORM 的时候会出现一些问题。<br>既然我们关注性能，那就应该说说这个方面的好处。当在应用中多次使用同一个查询的时候，它的好处特别明显。既然向同一个预备好的语句中传入不同的参数值，MySQL 对这个语句也只会进行一次解析。<br>同时，最新版本的 MySQL 在传输预备好的语句时会采用二进制形式，这样做的作用非常明显，而且对减少网络延迟很有帮助。<br>曾经有一段时间，许多程序员为了一个重要的原因则避免使用预处理语句。这个原因就是，它们不会被MySQL 缓存。不过在 5.1 版本的某个时候，查询缓存也得到的支持。<br>想在 PHP 中使用预处理语句，你可以看看 mysqli 扩展 或使用数据抽象层，如 PDO。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"> // create a prepared statement</div><div class=\"line\">if ($stmt = $mysqli-&gt;prepare(&quot;SELECT username FROM user WHERE state=?&quot;)) &#123;</div><div class=\"line\">  </div><div class=\"line\">    // bind parameters</div><div class=\"line\">    $stmt-&gt;bind_param(&quot;s&quot;, $state);</div><div class=\"line\">  </div><div class=\"line\">    // execute</div><div class=\"line\">    $stmt-&gt;execute();</div><div class=\"line\">  </div><div class=\"line\">    // bind result variables</div><div class=\"line\">    $stmt-&gt;bind_result($username);</div><div class=\"line\">  </div><div class=\"line\">    // fetch value</div><div class=\"line\">    $stmt-&gt;fetch();</div><div class=\"line\">  </div><div class=\"line\">    printf(&quot;%s is from %s\\n&quot;, $username, $state);</div><div class=\"line\">  </div><div class=\"line\">    $stmt-&gt;close();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"无缓冲查询\"><a href=\"#无缓冲查询\" class=\"headerlink\" title=\"无缓冲查询\"></a>无缓冲查询</h2><p>通常当你从脚本执行一个查询，在它可以继续后面的任务之前将需要等待查询执行完成。你可以使用无缓冲的查询来改变这一情况。<br>在PHP 文档中对  mysql_unbuffered_query() f函数有一个很好的解释：<br>“<br> “mysql_unbuffered_query() 发送SQL查询语句到MySQL不会像 mysql_query()那样自动地取并缓冲结果行。这让产生大量结果集的查询节省了大量的内存，在第一行已经被取回时你就可以立即在结果集上继续工作，而不用等到SQL查询被执行完成。”<br>然而，它有一定的局限性。你必须在执行另一个查询之前读取所有的行或调用mysql_free_result() 。另外你不能在结果集上使用mysql_num_rows() 或 mysql_data_seek() 。</p>\n<h2 id=\"使用-UNSIGNED-INT-存储IP地址\"><a href=\"#使用-UNSIGNED-INT-存储IP地址\" class=\"headerlink\" title=\"使用 UNSIGNED INT 存储IP地址\"></a>使用 UNSIGNED INT 存储IP地址</h2><p>很多程序员没有意识到可以使用整数类型的字段来存储 IP 地址，所以一直使用 VARCHAR(15) 类型的字段。使用 INT 只需要 4 个字节的空间，而且字段长度固定。</p>\n<p>必须确保列是 UNSINGED INT 类型，因为 IP 地址可能会用到 32 位无符号整型数据的每一个位。</p>\n<p>在查询中可以使用 INET_ATON() 来把一个IP转换为整数，用 INET_NTOA() 来进行相反的操作。在 PHP 也有类似的函数，ip2long() 和 long2ip()。<br>$r = “UPDATE users SET ip = INET_ATON(‘{$_SERVER[‘REMOTE_ADDR’]}’) WHERE user_id = $user_id”;</p>\n<h2 id=\"固定长度（静态）的表会更快\"><a href=\"#固定长度（静态）的表会更快\" class=\"headerlink\" title=\"固定长度（静态）的表会更快\"></a>固定长度（静态）的表会更快</h2><p>（译者注：这里提到的表的长度，实际是指表头的长度，即表中每条数据占用的空间大小，而不是指表的数据量）</p>\n<p>如果表中所有列都是“固定长度”，那么这个表被认为是“静态”或“固定长度”的。不固定的列类型包括 VARCHAR、TEXT、BLOB等。即使表中只包含一个这些类型的列，这个表就不再是固定长度的，MySQL 引擎会以不同的方式来处理它。<br>固定长度的表会提高性能，因为 MySQL 引擎在记录中检索的时候速度会更快。如果想读取表中的某一地，它可以直接计算出这一行的位置。如果行的大小不固定，那就需要在主键中进行检索。</p>\n<p>它们也易于缓存，崩溃后容易重建。不过它们也会占用更多空间。例如，如果你把一个 VARCHAR(20) 的字符改为 CHAR(20) 类型，它会总是占用 20 个字节，不管里面存的是什么内容。</p>\n<p>你可以使用“垂直分区”技术，将长度变化的列拆分到另一张表中。来看看：</p>\n<h2 id=\"垂直分区\"><a href=\"#垂直分区\" class=\"headerlink\" title=\"垂直分区\"></a>垂直分区</h2><p>垂直分区是为了优化表结构而对其进行纵向拆分的行为。</p>\n<p>示例 1: 你可能会有一张用户表，包含家庭住址，而这个不是一个常用数据。这时候你可以选择把表拆分开，将住址信息保存到另一个表中。这样你的主用户表就会更小。如你所知，表越小越快。</p>\n<p>示例 2: 表中有一个 “last_login” 字段，用户每次登录网站都会更新这个字段，而每次更新都会导致这个表缓存的查询数据被清空。这种情况下你可以将那个字段放到另一张表里，保持用户表更新量最小。</p>\n<p>不过你也需要确保不会经常联合查询分开后的两张表，要不然你就得忍受由这带来的性能下降。</p>\n<h2 id=\"拆分大型DELETE或INSERT语句\"><a href=\"#拆分大型DELETE或INSERT语句\" class=\"headerlink\" title=\"拆分大型DELETE或INSERT语句\"></a>拆分大型DELETE或INSERT语句</h2><p>如果你需要在网站上执行大型DELETE或INSERT查询，则需要注意不要影响网络流量。当执行大型语句时，它会锁表并使你的Web应用程序停止。<br>Apach运行许多并行进程/线程。 因此它执行脚本效率很高。所以服务器不期望打开过多的连接和进程，这很消耗资源，特别是内存。</p>\n<p>如果你锁表很长时间（如30秒或更长），在一个高流量的网站，会导致进程和查询堆积，处理这些进程和查询可能需要很长时间，最终甚至使你的网站崩溃。<br>如果你的维护脚本需要删除大量的行，只需使用LIMIT子句，以避免阻塞。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">while (1) &#123;</div><div class=\"line\">    mysql_query(&quot;DELETE FROM logs WHERE log_date &lt;= &apos;2009-10-01&apos; LIMIT 10000&quot;);</div><div class=\"line\">    if (mysql_affected_rows() == 0) &#123;</div><div class=\"line\">        // done deleting</div><div class=\"line\">        break;</div><div class=\"line\">    &#125;</div><div class=\"line\">    // you can even pause a bit</div><div class=\"line\">    usleep(50000);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"越少的列越快\"><a href=\"#越少的列越快\" class=\"headerlink\" title=\"越少的列越快\"></a>越少的列越快</h2><p>对于数据库引擎，磁盘可能是最重要的瓶颈。更小更紧凑的数据、减少磁盘传输量，通常有助于性能提高。</p>\n<p>MySQL文档Storage Requirements 有所有数据类型清单。</p>\n<p>如果已知表具有很少的行，则没有理由是主键类型为INT，可以用MEDIUMINT、SMALLINT代替，甚至在某些情况下使用TINYINT。 如果不需要完整时间记录，请使用DATE而不是DATETIME。</p>\n<p>确保留下合理的扩展空间，不然你可能会像Slashdot这样。</p>\n<h2 id=\"选择正确的存储引擎\"><a href=\"#选择正确的存储引擎\" class=\"headerlink\" title=\"选择正确的存储引擎\"></a>选择正确的存储引擎</h2><p>MySQL有两个主要存储引擎，MyISAM和InnoDB。 每个都有自己的优点和缺点。</p>\n<p>MyISAM适用于读取繁重的应用程序，但是当有很多写入时它不能很好地扩展。 即使你正在更新一行的一个字段，整个表也被锁定，并且在语句执行完成之前，其他进程甚至无法读取该字段。 MyISAM在计算SELECT COUNT（*）的查询时非常快。</p>\n<p>InnoDB是一个更复杂的存储引擎，对于大多数小的应用程序，它比MyISAM慢。 但它支持基于行的锁定，使其更好地扩展。 它还支持一些更高级的功能，比如事务。</p>\n<ul>\n<li>MyISAM存储引擎</li>\n<li>InnoDB存储引擎</li>\n</ul>\n<h2 id=\"使用对象关系映射器（ORM-Object-Relational-Mapper）\"><a href=\"#使用对象关系映射器（ORM-Object-Relational-Mapper）\" class=\"headerlink\" title=\"使用对象关系映射器（ORM, Object Relational Mapper）\"></a>使用对象关系映射器（ORM, Object Relational Mapper）</h2><p>通过使用ORM（对象关系映射器），你可以获得一定的性能提升。ORM可以完成的一切事情，手动编码也可完成。但这可能意味着需要太多额外的工作，并且需要高水平的专业知识。</p>\n<p>ORM以“延迟加载”著称。这意味着它们仅在需要时获取实际值。但是你需要小心处理他们，否则你可能最终创建了许多微型查询，这会降低数据库性能。</p>\n<p>ORM还可以将多个查询批处理到事务中，其操作速度比向数据库发送单个查询快得多。</p>\n<p>目前我最喜欢的PHP-ORM是Doctrine。我写了一篇关于如何安装Doctrine与CodeIgniter的文章（install Doctrine with CodeIgniter）。</p>\n<h2 id=\"小心使用持久连接\"><a href=\"#小心使用持久连接\" class=\"headerlink\" title=\"小心使用持久连接\"></a>小心使用持久连接</h2><p>持久连接意味着减少重建连接到MySQL的成本。 当持久连接被创建时，它将保持打开状态直到脚本完成运行。 因为Apache重用它的子进程，下一次进程运行一个新的脚本时，它将重用相同的MySQL连接。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">● PHP：mysql_pconnect()</div></pre></td></tr></table></figure></p>\n<p>理论上看起来不错。 但从我个人（和许多其他人）的经验看来，这个功能可能会导致更多麻烦。 你可能会出现连接数限制问题、内存问题等等。</p>\n<p>Apache总是并行运行的，它创建许多子进程。 这是持久连接在这种环境中不能很好工作的主要原因。 在你考虑使用mysql_pconnect()之前，请咨询你的系统管理员。</p>\n"},{"title":"VIM必备快捷键","date":"2016-09-18T16:00:00.000Z","_content":"\n<kbd>ta</kbd> 跳到下一个a 前面，配合d，dt) 一直删除到这行的) \n<kbd>fa</kbd> 跳到下一个a \n<kbd>CTRL-F</kbd> 向前一页 <kbd>CTRL-B</kbd> 向后一页 \n<kbd>CTRL-D</kbd> 向下半页 <kbd>CTRL-U</kbd> 向上半页\n<kbd>ctrl+i</kbd> 跳转到函数、变量和#define\n<kbd>ctrl+i</kbd> 向前跳到前几次光标位置\n<kbd>ctrl+o</kbd> 向后跳到后几次光标位置\n\n<kbd>vi{</kbd> 选中{}中间的内容,不包括{}， 可以([{'\"<\n<kbd>va{</kbd> 选中{}中间内容，包括{}\n\n<kbd>:e!</kbd>重新读进上次保存的此文件内容\n<kbd>:ab myname william_djj</kbd>\n以后再编辑时键入myname，然后空格或回车myname串就会被william_djj代替\n<kbd>:r !command</kbd> 在当前位置插入command结果\n<kbd>:r filename</kbd> 当前位置插入文件内容\n不退出vim，直接执行命令，例如在perl文件中，直接执行不退出，<kbd>:!perl %</kbd> 。 如果前面已经执行过了，则重复前面的命令时，只需要<kbd>:!!</kbd>\n插入模式下<kbd>ctrl +r</kbd>，=算式，回车插入结果\n<kbd>% </kbd>跳转到相配对的括号，或流控\n<kbd>D</kbd> 表示删除从当前光标到光标所在行尾的内容.\n删除某行后面的换行符号：在命令状态下，在某一行上按\"J\"键将Join下一行，呵呵\n<kbd>u</kbd> 撤销上次的操作，<kbd>ctrl+r</kbd>恢复上次的撤销。 \n\n<kbd>:n,$s/vivian/sky/g</kbd> 替换第 n 行开始到最后一行中每一行所有 vivian 为 sky\nn 为数字，若 n 为 .，表示从当前行开始到最后一行\n可以使用 # 作为分隔符，此时中间出现的 / 不会作为分隔符\n<kbd>:s#vivian/#sky/#</kbd> 替换当前行第一个 vivian/ 为 sky/\n\n\n<kbd>:f</kbd>查看当前文件\n<kbd>v</kbd>选择模式  ，<kbd>ctrl+v</kbd>块选择模式，<kbd>V</kbd>行选择模式\n\n\n<kbd>^</kbd> 行首 \n<kbd>$</kbd>行尾\n<kbd>0</kbd> 第一个字符\n\n<kbd>y</kbd> 复制\n<kbd>d</kbd> 删除\n<kbd>x</kbd> 剪切\n<kbd>p</kbd> 粘贴\n","source":"_posts/vim_keyboard_shortcuts.md","raw":"\n---\ntitle: VIM必备快捷键\ntags: [Linux,vim]\ncategories: Linux\ndate: 2016-09-19\n\n---\n\n<kbd>ta</kbd> 跳到下一个a 前面，配合d，dt) 一直删除到这行的) \n<kbd>fa</kbd> 跳到下一个a \n<kbd>CTRL-F</kbd> 向前一页 <kbd>CTRL-B</kbd> 向后一页 \n<kbd>CTRL-D</kbd> 向下半页 <kbd>CTRL-U</kbd> 向上半页\n<kbd>ctrl+i</kbd> 跳转到函数、变量和#define\n<kbd>ctrl+i</kbd> 向前跳到前几次光标位置\n<kbd>ctrl+o</kbd> 向后跳到后几次光标位置\n\n<kbd>vi{</kbd> 选中{}中间的内容,不包括{}， 可以([{'\"<\n<kbd>va{</kbd> 选中{}中间内容，包括{}\n\n<kbd>:e!</kbd>重新读进上次保存的此文件内容\n<kbd>:ab myname william_djj</kbd>\n以后再编辑时键入myname，然后空格或回车myname串就会被william_djj代替\n<kbd>:r !command</kbd> 在当前位置插入command结果\n<kbd>:r filename</kbd> 当前位置插入文件内容\n不退出vim，直接执行命令，例如在perl文件中，直接执行不退出，<kbd>:!perl %</kbd> 。 如果前面已经执行过了，则重复前面的命令时，只需要<kbd>:!!</kbd>\n插入模式下<kbd>ctrl +r</kbd>，=算式，回车插入结果\n<kbd>% </kbd>跳转到相配对的括号，或流控\n<kbd>D</kbd> 表示删除从当前光标到光标所在行尾的内容.\n删除某行后面的换行符号：在命令状态下，在某一行上按\"J\"键将Join下一行，呵呵\n<kbd>u</kbd> 撤销上次的操作，<kbd>ctrl+r</kbd>恢复上次的撤销。 \n\n<kbd>:n,$s/vivian/sky/g</kbd> 替换第 n 行开始到最后一行中每一行所有 vivian 为 sky\nn 为数字，若 n 为 .，表示从当前行开始到最后一行\n可以使用 # 作为分隔符，此时中间出现的 / 不会作为分隔符\n<kbd>:s#vivian/#sky/#</kbd> 替换当前行第一个 vivian/ 为 sky/\n\n\n<kbd>:f</kbd>查看当前文件\n<kbd>v</kbd>选择模式  ，<kbd>ctrl+v</kbd>块选择模式，<kbd>V</kbd>行选择模式\n\n\n<kbd>^</kbd> 行首 \n<kbd>$</kbd>行尾\n<kbd>0</kbd> 第一个字符\n\n<kbd>y</kbd> 复制\n<kbd>d</kbd> 删除\n<kbd>x</kbd> 剪切\n<kbd>p</kbd> 粘贴\n","slug":"vim_keyboard_shortcuts","published":1,"updated":"2016-12-05T14:10:17.618Z","_id":"ciwc5273s0006o8l0oya7x2bj","comments":1,"layout":"post","photos":[],"link":"","content":"<p><kbd>ta</kbd> 跳到下一个a 前面，配合d，dt) 一直删除到这行的)<br><kbd>fa</kbd> 跳到下一个a<br><kbd>CTRL-F</kbd> 向前一页 <kbd>CTRL-B</kbd> 向后一页<br><kbd>CTRL-D</kbd> 向下半页 <kbd>CTRL-U</kbd> 向上半页<br><kbd>ctrl+i</kbd> 跳转到函数、变量和#define<br><kbd>ctrl+i</kbd> 向前跳到前几次光标位置<br><kbd>ctrl+o</kbd> 向后跳到后几次光标位置</p>\n<p><kbd>vi{</kbd> 选中{}中间的内容,不包括{}， 可以([{‘“&lt;<br><kbd>va{</kbd> 选中{}中间内容，包括{}</p>\n<p><kbd>:e!</kbd>重新读进上次保存的此文件内容<br><kbd>:ab myname william_djj</kbd><br>以后再编辑时键入myname，然后空格或回车myname串就会被william_djj代替<br><kbd>:r !command</kbd> 在当前位置插入command结果<br><kbd>:r filename</kbd> 当前位置插入文件内容<br>不退出vim，直接执行命令，例如在perl文件中，直接执行不退出，<kbd>:!perl %</kbd> 。 如果前面已经执行过了，则重复前面的命令时，只需要<kbd>:!!</kbd><br>插入模式下<kbd>ctrl +r</kbd>，=算式，回车插入结果<br><kbd>% </kbd>跳转到相配对的括号，或流控<br><kbd>D</kbd> 表示删除从当前光标到光标所在行尾的内容.<br>删除某行后面的换行符号：在命令状态下，在某一行上按”J”键将Join下一行，呵呵<br><kbd>u</kbd> 撤销上次的操作，<kbd>ctrl+r</kbd>恢复上次的撤销。 </p>\n<p><kbd>:n,$s/vivian/sky/g</kbd> 替换第 n 行开始到最后一行中每一行所有 vivian 为 sky<br>n 为数字，若 n 为 .，表示从当前行开始到最后一行<br>可以使用 # 作为分隔符，此时中间出现的 / 不会作为分隔符<br><kbd>:s#vivian/#sky/#</kbd> 替换当前行第一个 vivian/ 为 sky/</p>\n<p><kbd>:f</kbd>查看当前文件<br><kbd>v</kbd>选择模式  ，<kbd>ctrl+v</kbd>块选择模式，<kbd>V</kbd>行选择模式</p>\n<p><kbd>^</kbd> 行首<br><kbd>$</kbd>行尾<br><kbd>0</kbd> 第一个字符</p>\n<p><kbd>y</kbd> 复制<br><kbd>d</kbd> 删除<br><kbd>x</kbd> 剪切<br><kbd>p</kbd> 粘贴</p>\n","excerpt":"","more":"<p><kbd>ta</kbd> 跳到下一个a 前面，配合d，dt) 一直删除到这行的)<br><kbd>fa</kbd> 跳到下一个a<br><kbd>CTRL-F</kbd> 向前一页 <kbd>CTRL-B</kbd> 向后一页<br><kbd>CTRL-D</kbd> 向下半页 <kbd>CTRL-U</kbd> 向上半页<br><kbd>ctrl+i</kbd> 跳转到函数、变量和#define<br><kbd>ctrl+i</kbd> 向前跳到前几次光标位置<br><kbd>ctrl+o</kbd> 向后跳到后几次光标位置</p>\n<p><kbd>vi{</kbd> 选中{}中间的内容,不包括{}， 可以([{‘“&lt;<br><kbd>va{</kbd> 选中{}中间内容，包括{}</p>\n<p><kbd>:e!</kbd>重新读进上次保存的此文件内容<br><kbd>:ab myname william_djj</kbd><br>以后再编辑时键入myname，然后空格或回车myname串就会被william_djj代替<br><kbd>:r !command</kbd> 在当前位置插入command结果<br><kbd>:r filename</kbd> 当前位置插入文件内容<br>不退出vim，直接执行命令，例如在perl文件中，直接执行不退出，<kbd>:!perl %</kbd> 。 如果前面已经执行过了，则重复前面的命令时，只需要<kbd>:!!</kbd><br>插入模式下<kbd>ctrl +r</kbd>，=算式，回车插入结果<br><kbd>% </kbd>跳转到相配对的括号，或流控<br><kbd>D</kbd> 表示删除从当前光标到光标所在行尾的内容.<br>删除某行后面的换行符号：在命令状态下，在某一行上按”J”键将Join下一行，呵呵<br><kbd>u</kbd> 撤销上次的操作，<kbd>ctrl+r</kbd>恢复上次的撤销。 </p>\n<p><kbd>:n,$s/vivian/sky/g</kbd> 替换第 n 行开始到最后一行中每一行所有 vivian 为 sky<br>n 为数字，若 n 为 .，表示从当前行开始到最后一行<br>可以使用 # 作为分隔符，此时中间出现的 / 不会作为分隔符<br><kbd>:s#vivian/#sky/#</kbd> 替换当前行第一个 vivian/ 为 sky/</p>\n<p><kbd>:f</kbd>查看当前文件<br><kbd>v</kbd>选择模式  ，<kbd>ctrl+v</kbd>块选择模式，<kbd>V</kbd>行选择模式</p>\n<p><kbd>^</kbd> 行首<br><kbd>$</kbd>行尾<br><kbd>0</kbd> 第一个字符</p>\n<p><kbd>y</kbd> 复制<br><kbd>d</kbd> 删除<br><kbd>x</kbd> 剪切<br><kbd>p</kbd> 粘贴</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ciwc527330000o8l0ywv3c4w9","category_id":"ciwc5273f0002o8l07f8bpjw1","_id":"ciwc5273w0009o8l0wz36qtvf"},{"post_id":"ciwc527390001o8l04mus8v0q","category_id":"ciwc5273f0002o8l07f8bpjw1","_id":"ciwc5273y000co8l0olo4f2e4"},{"post_id":"ciwc5273j0004o8l0qbdy1nrn","category_id":"ciwc5273f0002o8l07f8bpjw1","_id":"ciwc52740000go8l0luukq4q7"},{"post_id":"ciwc5273m0005o8l0lnn26n77","category_id":"ciwc5273y000do8l0skjp66hv","_id":"ciwc52744000lo8l0tlptcg6y"},{"post_id":"ciwc5273s0006o8l0oya7x2bj","category_id":"ciwc52741000ho8l0flwucetx","_id":"ciwc52747000po8l0x2jqyc9o"}],"PostTag":[{"post_id":"ciwc527330000o8l0ywv3c4w9","tag_id":"ciwc5273i0003o8l0cmy78kkh","_id":"ciwc52740000fo8l0r2cshvsv"},{"post_id":"ciwc527330000o8l0ywv3c4w9","tag_id":"ciwc5273u0008o8l0phi5azu9","_id":"ciwc52742000io8l0d4glw1ze"},{"post_id":"ciwc527330000o8l0ywv3c4w9","tag_id":"ciwc5273x000bo8l0257j9sha","_id":"ciwc52743000ko8l0nd379bqp"},{"post_id":"ciwc527390001o8l04mus8v0q","tag_id":"ciwc5273i0003o8l0cmy78kkh","_id":"ciwc52744000mo8l0gd1mp6c9"},{"post_id":"ciwc5273j0004o8l0qbdy1nrn","tag_id":"ciwc52742000jo8l07trw3i23","_id":"ciwc52747000oo8l0wf08ja7l"},{"post_id":"ciwc5273m0005o8l0lnn26n77","tag_id":"ciwc52746000no8l0yqj8fbo4","_id":"ciwc5274f000to8l0cuskaoiz"},{"post_id":"ciwc5273m0005o8l0lnn26n77","tag_id":"ciwc52748000qo8l04l32xhyy","_id":"ciwc5274g000uo8l0gb7ldi6s"},{"post_id":"ciwc5273m0005o8l0lnn26n77","tag_id":"ciwc5274a000ro8l0fjxuw0rm","_id":"ciwc5274h000wo8l0bhuznhv6"},{"post_id":"ciwc5273s0006o8l0oya7x2bj","tag_id":"ciwc5274e000so8l0gc9u4apa","_id":"ciwc5274i000xo8l0mfj4jfx7"},{"post_id":"ciwc5273s0006o8l0oya7x2bj","tag_id":"ciwc5274h000vo8l0umhz3d4i","_id":"ciwc5274i000yo8l0cmonm4w0"}],"Tag":[{"name":"Java","_id":"ciwc5273i0003o8l0cmy78kkh"},{"name":"jvm","_id":"ciwc5273u0008o8l0phi5azu9"},{"name":"虚拟机","_id":"ciwc5273x000bo8l0257j9sha"},{"name":"Tomcat","_id":"ciwc52742000jo8l07trw3i23"},{"name":"Mysql","_id":"ciwc52746000no8l0yqj8fbo4"},{"name":"DB","_id":"ciwc52748000qo8l04l32xhyy"},{"name":"数据库","_id":"ciwc5274a000ro8l0fjxuw0rm"},{"name":"Linux","_id":"ciwc5274e000so8l0gc9u4apa"},{"name":"vim","_id":"ciwc5274h000vo8l0umhz3d4i"}]}}